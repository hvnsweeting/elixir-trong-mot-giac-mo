<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>After basic - Lá ngón</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->
	
	<script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="..">Lá ngón</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li >
                        <a href="..">Home</a>
                    </li>
                    <li class="active">
                        <a href="./">After basic</a>
                    </li>
                    <li >
                        <a href="../http-client/">Http client</a>
                    </li>
                    <li >
                        <a href="../process/">Process</a>
                    </li>
                </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                    <li >
                        <a rel="next" href="..">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../http-client/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#sau-bat-au">Sau bắt đầu</a></li>
        <li class="main "><a href="#todo-tai-sao">TODO tại sao?</a></li>
        <li class="main "><a href="#todo">TODO</a></li>
            <li><a href="#filter-odd-element">Filter odd element:</a></li>
        <li class="main "><a href="#process">Process</a></li>
        <li class="main "><a href="#todo-otp">TODO OTP</a></li>
            <li><a href="#module-attributes">Module attributes</a></li>
        <li class="main "><a href="#constant">Constant</a></li>
        <li class="main "><a href="#todo-later">TODO later</a></li>
            <li><a href="#struct">Struct</a></li>
            <li><a href="#protocol">Protocol</a></li>
        <li class="main "><a href="#protocol-consolidation">Protocol consolidation</a></li>
        <li class="main "><a href="#sigils">Sigils</a></li>
            <li><a href="#typespec">Typespec</a></li>
            <li><a href="#behaviours">Behaviours</a></li>
        <li class="main "><a href="#function12520324582-in-erl_evalexpr5">Function&lt;12.52032458/2 in :erl_eval.expr/5&gt;</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="sau-bat-au">Sau bắt đầu</h1>
<p>Sau khi đã nắm được cú pháp cơ bản của Elixir, ta cần gì đó để code. Mặc dù làm website là một thế mạnh của Elixir, nhưng nếu trong đầu bạn không nghĩ ra ngay một webapp nào bạn cần làm, thì đi theo con đường ấy là không tối ưu. Bởi nếu chỉ làm xong tutorial và làm ra một trang web ví dụ nào đó, mọi kiến thức lại trôi vào quên lãng.</p>
<p>Vậy nên trong thời gian chờ các ý tưởng hiện lên, ta tiếp tục đào sâu vào Elixir, nhưng bằng cách giải các bài toán trên website: hackerrank.com. Mục "Functional programming":
https://www.hackerrank.com/domains/fp/intro</p>
<p>Các vấn đề sẽ đi từ dễ đến khó. Hãy bắt đầu với dễ:</p>
<p>https://www.hackerrank.com/challenges/fp-list-replication</p>
<p>Bài này yêu cầu cho đầu vào là 1 số N, và một dãy số theo sau, mục tiêu là tạo ra một dãy số mà mỗi số lắp lại N lần.
Ví dụ cho N=3, dãy số 2 3 4, cần in ra màn hình:</p>
<pre><code>2
2
2
3
3
3
4
4
4
</code></pre>

<p>Hai điểm cần chú ý:
- Ta cần biết đọc dữ liệu đầu vào trên Elixir</p>
<p>Khi viết code trong bài này, mình sử dụng một tên biến là "S", và mọi lỗi kỳ lạ bắt đầu xảy ra, mọi thứ trở lại bình thường nếu sử dụng tên biến là chữ s viết thường. TODO tìm hiểu tại sao.</p>
<p>Vấn đề thứ 2 là khi viết function trả về 1 list, nếu bật iex lên và in kết quả function trả về sẽ thấy list đó, nhưng nếu viết code IO.puts myfunc() thì chỉ thấy kết quả in ra dòng trắng.</p>
<h1 id="todo-tai-sao">TODO tại sao?</h1>
<p>https://www.hackerrank.com/challenges/fp-filter-array</p>
<h1 id="todo">TODO</h1>
<p>why it still can compare string with number</p>
<p>why [head|tail] and there is a case head == "" ?
because of how I split string</p>
<p>data = IO.read(:stdio, :all) |&gt; String.trim |&gt; String.split([" ", "\n"])</p>
<p>Add String.trim to clean thing up</p>
<h2 id="filter-odd-element">Filter odd element:</h2>
<p>iex(1)&gt; Enum.with_index ["a", "b", "c"]
[{"a", 0}, {"b", 1}, {"c", 2}]</p>
<h1 id="process">Process</h1>
<p>extremely lightweight not like thread in other lang</p>
<p>spawn/1 : spawning new process
spawn/1 takes a function
return a PID</p>
<p>Process.alive?(pid)</p>
<p>Retrieve the PID of the current process by calling self/0</p>
<p>send message:
send/2: TO, MESSAGE</p>
<p>when msg is sent to a process, the msg is stored in the process mailbox.</p>
<p>receive/1 searching for 1 msg that match a given pattern in mailbox.</p>
<p>send/2 does not block</p>
<p>receive block or can be timeout.</p>
<p>flush/0 flushes and print all msgs in the mailbox</p>
<p>spawn_link/1: like spawn, but link to parrent</p>
<p>"failing fast" is a common philosophy in Elixir world</p>
<p>Task.start/1 and Task.start_link/1</p>
<p>return {:ok, pid}</p>
<p>Storing "state": http://elixir-lang.org/getting-started/processes.html</p>
<p>Process.register(pid, NAME)
send NAME, VALUE</p>
<p>Agent is an abstract for that.</p>
<h1 id="todo-otp">TODO OTP</h1>
<p>http://elixir-lang.org/getting-started/processes.html</p>
<p>====
Module</p>
<p>alias Foo.Bar, as Bar
like import FooBar as Bar  # Python</p>
<p>require Foo # ensuring the module is compiled and available (usually for macro)</p>
<p>import Foo # import functions from Foo module, so can call without <code>Foo.</code> - auto require it</p>
<p>use Foo # chạy custom code trong Foo</p>
<p>alias/require/import : directive vì có lexical scope
Vì là lexical scope nên có thể set alias trong function
và chỉ có thể dùng trong function đó.</p>
<p>Macro:
code that generates code.
Executed and expanded at compilation time.</p>
<p>iex(14)&gt; require Integer
Integer
iex(15)&gt; In
Inspect    Integer
iex(15)&gt; Integer.is_
is_even/1    is_odd/1
iex(15)&gt; Integer.is_odd(3)
true</p>
<p>iex(16)&gt; import List, only: [duplicate: 2]
List</p>
<p>only: :macros
 only: :functions
 except: somethign</p>
<p>An alias in Elixir is a capitalized identifier which is converted to an atom during compilation.</p>
<h2 id="module-attributes">Module attributes</h2>
<p>annotate the module
constant
temporary module storage</p>
<p>@moduledoc # doc for module
@doc # doc for func
@behaviour
@before_compile</p>
<p>defmodule Math do
  @moduledoc """  &lt;--- heredocs: Markdown
  doc go
  """</p>
<p>@doc """
  calculate ...
  """
  def sum(a,b), do: a + b
end</p>
<h1 id="constant">Constant</h1>
<p>Exist only during compilation time</p>
<p>@initial_state %{host: "127.0.0.1", port:3456}</p>
<h1 id="todo-later">TODO later</h1>
<h2 id="struct">Struct</h2>
<p>Built on top of maps
provide: compile-time checks and default value</p>
<p>defmodule User do
  defstruct name: "HVN", age: 27
  end</p>
<p>Structs take the name of the module they’re defined in.</p>
<p>Same syntax with map</p>
<p>structs are bare maps (just storage,access, no protocol</p>
<p>default is nil
@enforce_keys [:make]</p>
<h2 id="protocol">Protocol</h2>
<p>http://elixir-lang.org/getting-started/protocols.html</p>
<p>English: dispatching on a protocol
dispatch : send off to a dest</p>
<p>Protocol definition:</p>
<pre><code>defprotocol Size do
  @doc &quot;Calculate the size of a data structure&quot;
  def size(data)
end
</code></pre>

<pre><code>defimpl Size, for: Map do
  def size(map), do: map_size(map)
end
</code></pre>

<p>Then we can use it for multiple data type =&gt; polymophism</p>
<h3 id="protocol-and-struct">Protocol and struct</h3>
<pre><code>defimpl Size, for: MapSet do
  def size(set), do: MapSet.size(set)
  end
</code></pre>

<h3 id="derive-a-protocol-impolementation-for-all-t-ype">Derive a protocol impolementation for all t ype:</h3>
<p>use <code>Any</code></p>
<pre><code>defimpl Size, for: Any do
  def size(_), do: 0
</code></pre>

<pre><code>defmodule OtherUser do
  @derive [Size]
  defstruct [:name, :age]
end
</code></pre>

<p>Fallback</p>
<p>@fallback_to_any true</p>
<p>Builtin protocol
Enumerable (map/reduce ...)
String.Chars (to_string)
Inspect protocol</p>
<h1 id="protocol-consolidation">Protocol consolidation</h1>
<p>English: consolidation : strengthen, make stronger.</p>
<h1 id="sigils">Sigils</h1>
<p>Sigil: start with the tilde (<code>~</code>), followed by a letter (which identify the sigil)</p>
<p>Regular expression
~r/foo|bar/</p>
<p>"foo" =~ regex # match regex</p>
<p>PRARE.</p>
<p>"HELLO" =~ ~r/hello/i # i is modifier</p>
<p>Sigils support 8 different delimiters.</p>
<p>/ | " ' ( [ { &lt;</p>
<p>Sigils
- Regex: ~r
- String: ~s
- Char list: ~c
- Word list: ~w(foo bar bat)
- ~S no escappe/interpolation</p>
<h3 id="_1"></h3>
<p>https://www.hackerrank.com/challenges/fp-array-of-n-elements
inspect(list, limit: -1)
dùng limit -1 để in ra không giới hạn ký tự, vd list có 100 phần tử, mặc định elixir chỉ in ra phần đầu rồi ...</p>
<p>để không in ra chữ (charlist),
dùng
 inspect(charlists: :as_lists)</p>
<p>iex(20)&gt; inspect (List.duplicate 1, 100), char_lists: :as_lists, limit: -1
"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"</p>
<h4 id="typespec">Typespec</h4>
<p>Function spec</p>
<p>:: means that the function on the left side returns a value whose type is what’s on the right side. Function specs are written with the @spec directive, placed right before the function definition. The round/1 function could be written as:</p>
<p>@spec round(number) :: integer
def round(number), do: # implementation..</p>
<h4 id="behaviours">Behaviours</h4>
<p>is a specification for composable module</p>
<p>defmodule Parser do
  @callback parse(String.t) :: any
  @callback extensions() :: [String.t]
end</p>
<p>Adopting behaviours:</p>
<pre><code>defmodule JSONParser do
  @behaviour Parser

  def parse(str), do: ...


end



## Erlang Library

:io.format(&quot;Pi ~10.3f~n&quot;, [:math.pi])

# :crypto
- not standard,

:crypto.hash(:sha256, &quot;Elixir&quot;)

# :digraph
Dealing with directed graphs

# ETS - Erlang term storage
Dets: disk ETS
allow to create a table containing tuples.

Function in ets module wil modify the state of the table as
a side-effect.



iex(8)&gt; :ets.insert(table, {&quot;HVN&quot;, 27})
true
iex(9)&gt; :ets.i(table)
&lt;1   &gt; {&lt;&lt;&quot;HVN&quot;&gt;&gt;,27}
EOT  (q)uit (p)Digits (k)ill /Regexp --&gt;1
EOT  (q)uit (p)Digits (k)ill /Regexp --&gt;2
EOT  (q)uit (p)Digits (k)ill /Regexp --&gt;q
:ok


## :math

:math.sin
:math.exp
:math.log



## :queue
FIFO


q = :queue.new
q = :queue.in(&quot;A&quot;, q)

{value, q} = :queue.out(q)


## :rand

:rand.uniform
:rand.seed


## :zip

:zip.foldl(...)

:zlib


## Mix and OTP

### Agent
is simple wrapper around state.



atoms are not garbage collected.

### GenServer

call: sync
cast: async




http://erlang.org/pipermail/erlang-questions/2014-November/081570.html#
https://blog.codeship.com/concurrency-in-elixir/





### Enum functions

Enum.concat/1 : nối các enumerable trong 1 enumerable (e.g flatten a list)

Enum.chunk/2 

def chunk(enumerable, count)
Shortcut to chunk(enumerable, count, count).

Cắt enum thành `count` enum nhỏ hơn:

iex(3)&gt; Enum.chunk([1,2,3,4,5,6], 3)
[[1, 2, 3], [4, 5, 6]]
iex(4)&gt; Enum.chunk([1,2,3,4,5,6], 2)
[[1, 2], [3, 4], [5, 6]]


iex(6)&gt; Enum.dedup([1,2,2,1,2,2,2,1,1,])
[1, 2, 1, 2, 1]
iex(7)&gt; Enum.uniq([1,2,2,1,2,2,2,1,1,])
[1, 2]

iex(8)&gt; Enum.empty?([])
true

iex(9)&gt; Enum.zip([1,2,3], [&quot;meo&quot;, &quot;cho&quot;, &quot;ga&quot;, &quot;trau&quot;])
[{1, &quot;meo&quot;}, {2, &quot;cho&quot;}, {3, &quot;ga&quot;}]

Trong Elixir, function không phải first-class citizen.
Ta không thể pass 1 function có tên thành argument cho function khác.

</code></pre>

<p>iex(10)&gt; is_function(rem)
** (CompileError) iex:10: undefined function rem/0</p>
<p>iex(10)&gt; is_function(rem/2)
** (CompileError) iex:10: undefined function rem/0
    (stdlib) lists.erl:1354: :lists.mapfoldl/3</p>
<pre><code>
Function capturing cho phép &quot;capture&quot; một function có tên thành một anonymous function, và lúc đó ta có thể gán nó, gọi nó như argument:

Có 2 cú pháp để capture function, một là dùng function/arity, cách khác là dùng capture để biểu diễn lượng argument mà function nhận vào:

iex(12)&gt; fun = &amp;rem/2
&amp;:erlang.rem/2
iex(13)&gt; fun = &amp;rem(&amp;1, &amp;2)
&amp;:erlang.rem/2
iex(14)&gt; fun.(5,2)
1

Để gọi anonymous function, phải dùng dấu `.` giữa tên biến và dấu gọi function `()`.

Hai anonymous function sau là tương đương 

</code></pre>

<p>iex(16)&gt; fun = &amp;(&amp;1 + &amp;2)
&amp;:erlang.+/2
iex(17)&gt; fun.(4, 9)
13</p>
<p>iex(18)&gt; fun = fn(x,y) -&gt; x + y end</p>
<h1 id="function12520324582-in-erl_evalexpr5">Function&lt;12.52032458/2 in :erl_eval.expr/5&gt;</h1>
<p>iex(19)&gt; fun.(4, 9)
13</p>
<pre><code>
Pass function đó khi gọi Enum.map

</code></pre>

<p>iex(20)&gt; Enum.map([1,2,3], &amp;(&amp;1 * 2))
[2, 4, 6]
iex(21)&gt; Enum.map([1,2,3], fn x -&gt; x * 2 end)
[2, 4, 6]
```</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../js/base.js"></script><div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
