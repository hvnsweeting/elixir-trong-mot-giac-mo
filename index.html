<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="H·ªçc l·∫≠p tr√¨nh Elixir trong m·ªôt gi·∫•c m∆°">
        
        
        <link rel="shortcut icon" href="./img/favicon.ico">
        <title>L√° ng√≥n</title>
        <link href="./css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="./css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="./css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="./css/highlight.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->
	
	<script src="./js/jquery-1.10.2.min.js"></script>
        <script src="./js/bootstrap-3.0.3.min.js"></script>
        <script src="./js/highlight.pack.js"></script> 
    </head>

    <body class="homepage">

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href=".">L√° ng√≥n</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li class="active">
                        <a href=".">Home</a>
                    </li>
                    <li >
                        <a href="db/">Db</a>
                    </li>
                    <li >
                        <a href="http-client/">Http client</a>
                    </li>
                    <li >
                        <a href="process/">Process</a>
                    </li>
                    <li >
                        <a href="why-elixir/">Why elixir</a>
                    </li>
                </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                    <li class="disabled">
                        <a rel="next" >
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="db/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#hoc-elixir-trong-mot-giac-mo">H·ªçc Elixir trong m·ªôt gi·∫•c m∆°</a></li>
            <li><a href="#cac-kieu-du-lieu-co-ban">C√°c ki·ªÉu d·ªØ li·ªáu c∆° b·∫£n</a></li>
            <li><a href="#cac-thao-tac-co-ban-voi-cac-kieu-du-lieu">C√°c thao t√°c c∆° b·∫£n v·ªõi c√°c ki·ªÉu d·ªØ li·ªáu</a></li>
            <li><a href="#pattern-matching">Pattern matching</a></li>
            <li><a href="#control-flow-case-cond-if-unless-doend">Control flow: case, cond, if, unless, do/end</a></li>
            <li><a href="#function">Function</a></li>
            <li><a href="#module">Module</a></li>
            <li><a href="#loop-bang-recursion-reduce-va-map">Loop b·∫±ng recursion, reduce v√† map</a></li>
            <li><a href="#io-xu-ly-du-lieu-vao-ra">IO - x·ª≠ l√Ω d·ªØ li·ªáu v√†o ra.</a></li>
            <li><a href="#xu-ly-loi">X·ª≠ l√Ω l·ªói</a></li>
            <li><a href="#bat-au-code-mot-project">B·∫Øt ƒë·∫ßu code m·ªôt project</a></li>
            <li><a href="#faqs">FAQs</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="hoc-elixir-trong-mot-giac-mo">H·ªçc Elixir trong m·ªôt gi·∫•c m∆°</h1>
<p>[BETA]</p>
<p>L√Ω do b·∫°n th√≠ch h·ªçc Haskell, LISP, Erlang, Elixir, Ocaml, Scala... nh·ªØng ng√¥n ng·ªØ l·∫≠p tr√¨nh h√†m (functional programming language) c√≥ v·∫ª hay ho, m√† kh√¥ng bao gi·ªù th√†nh c√¥ng l√† g√¨?</p>
<p>Sau ƒë√¢y l√† v√†i l√Ω do m√¨nh g·∫∑p ph·∫£i:</p>
<ul>
<li>Qu√° nhi·ªÅu kh√°i ni·ªám m·ªõi</li>
<li>Nh·ªìi nh√©t h·∫øt c√°c kh√°i ni·ªám xong kh√¥ng c√≥ g√¨ ƒë·ªÉ l√†m</li>
<li>Ch·ªçn ng√¥n ng·ªØ "x·ªãn" nh·∫•t: trong m·∫£nh ƒë·∫•t functional programming, r·∫•t nhi·ªÅu c√°i t√™n h·∫•p d·∫´n kh√°c nh∆∞ Haskell, Ocaml, Racket, Scheme, CLisp, Scala,...</li>
</ul>
<p>ƒê·ªÉ kh·∫Øc ph·ª•c ƒëi·ªÅu n√†y, ta s·∫Ω:</p>
<ul>
<li>Ch·ªâ t·∫≠p trung v√†o nh·ªØng kh√°i ni·ªám ƒë√£ quen thu·ªôc, h·ªçc th·∫≠t nhanh, tra c·ª©u khi c·∫ßn</li>
<li>C√≥ m·ªôt √Ω t∆∞·ªüng ƒë·ªÉ th·ª±c hi·ªán</li>
<li>T·∫≠p trung v√†o Elixir v√¨ m·ªói ng√¥n ng·ªØ ƒë·ªÅu c√≥ ƒëi·ªÉm m·∫°nh/ y·∫øu ri√™ng, nh∆∞ng khi n·∫Øm ƒë∆∞·ª£c m·ªôt ng√¥n ng·ªØ, h·ªçc c√°c ng√¥n ng·ªØ kh√°c s·∫Ω tr·ªü n√™n d·ªÖ d√†ng h∆°n nhi·ªÅu do ƒë√£ quen thu·ªôc c√°c kh√°i  ni·ªám v√† l·ªëi t∆∞ duy c·ªßa functional programming.</li>
</ul>
<p>N·∫øu kh√¥ng c√≥ g√¨ ƒë·ªÉ l√†m, nu·ªët xong c√°c kh√°i ni·ªám, 1 tu·∫ßn sau b·∫°n s·∫Ω l·∫°i qu√™n.</p>
<p>Elixir/Erlang ho√†n to√†n ƒë·ªß kh·∫£ nƒÉng ƒë·ªÉ cho b·∫°n l·∫≠p tr√¨nh loanh quanh m·∫•y thu·∫≠t to√°n, gi·∫£i c√°c b√†i to√°n / v·∫•n ƒë·ªÅ tr√™n HackerRank. Nh∆∞ng ƒëi·ªÉm s√°ng c·ªßa ng√¥n ng·ªØ n√†y, th·ª±c ra ch·ªâ to·∫£ s√°ng khi ta d√πng n√≥ ƒë·ªÉ ph√°t tri·ªÉn c√°c h·ªá th·ªëng l·ªõn, c·∫ßn ch·∫°y ph√¢n t√°n, hay ch·∫°y song song... √çt khi m·ªôt ng∆∞·ªùi s·∫Ω l√†m h·∫≥n m·ªôt project l·ªõn nh∆∞ v·∫≠y. V√¨ v·∫≠y, ta th∆∞·ªùng kh√¥ng c√≥ ƒë·∫•t d√πng cho Elixir hay Erlang.</p>
<p>M·ªôt c√°ch ·ª©ng d·ª•ng ƒë·ªÉ ch∆°i v·ªõi ng√¥n ng·ªØ m·ªõi n·ªØa "nh·ªè h∆°n", l√† vi·∫øt c√°c c√¢u l·ªánh th·ª±c hi·ªán m·ªôt vi·ªác g√¨ ƒë√≥ (CLI). V·∫≠y nh∆∞ng Elixir/Erlang kh√¥ng to·∫£ s√°ng/ ƒë∆°n gi·∫£n trong c√¥ng vi·ªác n√†y, n√≥ C√ì TH·ªÇ l√†m ƒë∆∞·ª£c, nh∆∞ng tr√™n th·ª±c t·∫ø kh√¥ng m·∫•y ai l√†m.</p>
<p>V√≠ d·ª• standard khi h·ªçc Erlang l√† l√†m m·ªôt h·ªá th·ªëng chat. Tr√™n th·ª±c t·∫ø, h·ªá th·ªëng chat c·ªßa "Whatsapp" ƒë∆∞·ª£c vi·∫øt b·∫±ng Erlang <a href="http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html">h·ªá th·ªëng n√†y ƒë√£ ƒë∆∞·ª£c b√°n l·∫°i cho FaceBook v·ªõi gi√° 19 T·ª∂ ƒë√¥ la M·ªπ</a> (PS: FaceBook tr∆∞·ªõc ƒë√≥ c≈©ng ƒë√£ mua l·∫°i Instagram - m·ªôt h·ªá th·ªëng vi·∫øt b·∫±ng Django/Python v·ªõi gi√° 1 T·ª∂ ƒë√¥ la M·ªπ)</p>
<p>Ta c√≥ th·ªÉ l√†m 1 website sau khi h·ªçc Elixir, ƒë√¢y l√† lƒ©nh v·ª±c hi·ªán t·∫°i m√† Elixir m·∫°nh nh·∫•t.</p>
<p>ƒê√£ xong ph·∫ßn √Ω t∆∞·ªüng, b√¢y gi·ªù h√£y h·ªçc Elixir.</p>
<p>Th·ª±c hi·ªán tr√™n:</p>
<pre><code>$ elixir --version
Erlang/OTP 19 [erts-8.0.2] [source] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Elixir 1.3.2
</code></pre>

<p>PS: trong b√†i c√≥ m·ªôt s·ªë ƒëo·∫°n so s√°nh v·ªõi t√≠nh nƒÉng t∆∞∆°ng t·ª± tr√™n Python - b·ªüi t√°c gi·∫£ l√† ng∆∞·ªùi c√≥ kinh nghi·ªám v·ªõi Python - gi√∫p c√°c l·∫≠p tr√¨nh vi√™n Python d·ªÖ k·∫øt n·ªëi c√°c kh√°i ni·ªám. Ph·∫ßn so s√°nh n√†y ho√†n to√†n kh√¥ng c·∫ßn thi·∫øt v·ªõi ng∆∞·ªùi kh√¥ng bi·∫øt Python v√† c√≥ th·ªÉ b·ªè qua.</p>
<h2 id="cac-kieu-du-lieu-co-ban">C√°c ki·ªÉu d·ªØ li·ªáu c∆° b·∫£n</h2>
<h3 id="integer">Integer</h3>
<pre><code>iex(33)&gt; 42
42
iex(34)&gt; i 42
Term
  42
Data type
  Integer
Reference modules
  Integer

D√πng ``i OBJECT`` ƒë·ªÉ hi·ªÉn th·ªã th√¥ng tin v·ªÅ gi√° tr·ªã/ ki·ªÉu c·ªßa object. Nh∆∞ &quot;type(object)&quot; trong Python hay &quot;typeof object&quot; trong JavaScript.
</code></pre>

<h3 id="float">Float</h3>
<pre><code>iex(35)&gt; i 3.14
Term
  3.14
Data type
  Float
Reference modules
  Float

iex(36)&gt; 0.1 + 0.1 + 0.1
0.30000000000000004
</code></pre>

<h3 id="atom">Atom</h3>
<pre><code>iex(39)&gt; i true
Term
  true
Data type
  Atom
Reference modules
  Atom
iex(40)&gt; i false
Term
  false
Data type
  Atom
Reference modules
  Atom
</code></pre>

<h3 id="string">String</h3>
<pre><code>iex(42)&gt; i &quot;Elixir&quot;
Term
  &quot;Elixir&quot;
Data type
  BitString
Byte size
  6
Description
  This is a string: a UTF-8 encoded binary. It's printed surrounded by
  &quot;double quotes&quot; because all UTF-8 encoded codepoints in it are printable.
Raw representation
  &lt;&lt;69, 108, 105, 120, 105, 114&gt;&gt;
Reference modules
  String, :binary
</code></pre>

<p>C√°c ki·ªÉu d·ªØ li·ªáu ch·ª©a ƒë∆∞·ª£c ki·ªÉu kh√°c: list, tuple, dict</p>
<h3 id="list">List</h3>
<pre><code>iex(44)&gt; i 'abc'
Term
  'abc'
Data type
  List
Description
  This is a list of integers that is printed as a sequence of characters
  delimited by single quotes because all the integers in it represent valid
  ASCII characters. Conventionally, such lists of integers are referred to as
  &quot;charlists&quot; (more precisely, a charlist is a list of Unicode codepoints,
  and ASCII is a subset of Unicode).
Raw representation
  [97, 98, 99]
Reference modules
  List


iex(45)&gt; i [1,2,3,3.14]
Term
  [1, 2, 3, 3.14]
Data type
  List
Reference modules
  List

iex(46)&gt; i []
Term
  []
Data type
  List
Reference modules
  List
</code></pre>

<p>M·ªôt list c√≥ th·ªÉ ch·ª©a b·∫•t k·ª≥ ki·ªÉu d·ªØ li·ªáu n√†o:</p>
<pre><code>iex(6)&gt; i [&quot;abc&quot;, 1]
Term
  [&quot;abc&quot;, 1]
Data type
  List
Reference modules
  List
</code></pre>

<p>V·ªõi list ch·ª©a c√°c ph·∫ßn t·ª≠ tuple-2 {atom: value}, Elixir h·ªó tr·ª£ th√™m c√∫ ph√°p ng·∫Øn g·ªçn ƒë·ªÉ t·∫°o ra list n√†y v√† g·ªçi l√† "keyword list" (b·∫£n ch·∫•t v·∫´n l√† 1 list b√¨nh th∆∞·ªùng):</p>
<pre><code>iex(38)&gt; [{:name, &quot;PyMi&quot;}, {:est, 2015}]
[name: &quot;PyMi&quot;, est: 2015]
iex(39)&gt; [name: &quot;PyMi&quot;, est: 2015]
[name: &quot;PyMi&quot;, est: 2015]

iex(38)&gt; [{:name, &quot;PyMi&quot;}, {:est, 2015}]
[name: &quot;PyMi&quot;, est: 2015]
iex(39)&gt; [name: &quot;PyMi&quot;, est: 2015]
[name: &quot;PyMi&quot;, est: 2015]

</code></pre>

<p>C√≥ th·ªÉ truy c·∫≠p ph·∫ßn t·ª≠ c·ªßa keyword list b·∫±ng key, khi nhi·ªÅu key tr√πng nhau,
truy c·∫≠p s·∫Ω tr·∫£ v·ªÅ gi√° tr·ªã ƒë·∫ßu ti√™n ·ª©ng v·ªõi key.</p>
<pre><code>iex(16)&gt; [foo: &quot;pika&quot;, foo: &quot;pikachu&quot;]
[foo: &quot;pika&quot;, foo: &quot;pikachu&quot;]
iex(17)&gt; [foo: &quot;pika&quot;, foo: &quot;pikachu&quot;][:foo]
&quot;pika&quot;
</code></pre>

<h3 id="tuple">Tuple</h3>
<pre><code>iex(48)&gt; i {100, 'abc'}
Term
  {100, 'abc'}
Data type
  Tuple
Reference modules
  Tuple
iex(49)&gt; i {}
Term
  {}
Data type
  Tuple
Reference modules
  Tuple

</code></pre>

<p>Kh√¥ng gi·ªëng Python, trong Elixir, T·∫§T C·∫¢ c√°c ki·ªÉu d·ªØ li·ªáu ƒë·ªÅu l√† immutable, t·ª©c m·ªôt khi ƒë√£ t·∫°o ra, kh√¥ng th·ªÉ thay ƒë·ªïi. Mu·ªën "thay ƒë·ªïi", ta ph·∫£i t·∫°o m·ªõi.</p>
<p>Tr√™n Python, nh·ªØng ƒëi·ªÅu sau ƒë·ªÅu c√≥ th·ªÉ l√†m tr√™n list hay tuple:
- duy·ªát qua t·ª´ng ph·∫ßn t·ª≠ (loop)
- truy c·∫≠p index
- slice ƒë·ªÉ thu ƒë∆∞·ª£c m·ªôt t·∫≠p con</p>
<p>S·ª± gi·ªëng nhau v·ªÅ t√≠nh nƒÉng khi·∫øn ng∆∞·ªùi d√πng th∆∞·ªùng h·ªèi khi n√†o d√πng list, khi n√†o d√πng tuple.
V·ªõi Python, ta c√≥ th·ªÉ thay ƒë·ªïi 1 list, nh∆∞ng kh√¥ng th·ªÉ thay ƒë·ªïi m·ªôt tuple sau khi ƒë√£ t·∫°o ra n√≥.
V·ªõi Elixir, c·∫£ list v√† tuple ƒë·ªÅu kh√¥ng th·ªÉ thay ƒë·ªïi ƒë∆∞·ª£c (immutable).
ƒê·∫∑c ƒëi·ªÉm n√†y s·∫Ω gi√∫p th·∫•y r√µ h∆°n khi n√†o d√πng tuple v√† khi n√†o n√™n d√πng list:
- list TH∆Ø·ªúNG d√πng ƒë·ªÉ ch·ª©a c√°c d·ªØ li·ªáu t∆∞∆°ng t·ª± nhau (heterogenious)
- tuple th∆∞·ªùng ƒë·ªÉ ch·ª©a c√°c th√¥ng tin li√™n quan ƒë·∫øn nhau, nh∆∞ c√°c c·ªôt trong 1 d√≤ng c·ªßa database, c√°c to·∫° ƒë·ªô c·ªßa m·ªôt ƒëi·ªÉm, c√°c ƒë·∫∑c t√≠nh c·ªßa m·ªôt con m√®o...</p>
<p>Khi ƒë√≥, ta s·∫Ω th∆∞·ªùng loop qua 1 list, v√† th∆∞·ªùng truy c·∫≠p ƒë·∫øn c√°c ph·∫ßn t·ª≠ c·ªßa tuple th√¥ng qua indexing/unpacking.</p>
<pre><code>iex(52)&gt; person = {&quot;HVN&quot;, 27, &quot;Python&quot;}
{&quot;HVN&quot;, 27, &quot;Python&quot;}
iex(53)&gt; {name, age, language} = person
{&quot;HVN&quot;, 27, &quot;Python&quot;}
iex(54)&gt; name
&quot;HVN&quot;
</code></pre>

<p>http://elixir-lang.org/getting-started/basic-types.html#lists-or-tuples
http://stackoverflow.com/questions/31192923/lists-vs-tuples-what-to-use-and-when</p>
<h3 id="map-dictionary">Map (dictionary)</h3>
<pre><code>iex(51)&gt; i %{&quot;name&quot;: &quot;FAMILUG&quot;}
Term
  %{name: &quot;FAMILUG&quot;}
Data type
  Map
Reference modules
  Map
</code></pre>

<h3 id="mapset-kieu-du-lieu-tap-hop">MapSet - ki·ªÉu d·ªØ li·ªáu t·∫≠p h·ª£p</h3>
<p>Ch·ª©a m·ªói ph·∫ßn t·ª≠ 1 l·∫ßn, kh√¥ng c√≥ th·ª© t·ª± <a href="http://stackoverflow.com/a/40408469">tr·ª´ 32 ph·∫ßn t·ª≠ ƒë·∫ßu</a> (t·ª©c kh√¥ng th·ªÉ s·∫Øp x·∫øp, ph·∫£i ƒë·ªïi th√†nh ki·ªÉu list m·ªõi s·∫Øp x·∫øp ƒë∆∞·ª£c.)</p>
<pre><code>iex(2)&gt; i MapSet.new([1,2,2,3,2,1])
Term
  #MapSet&lt;[1, 2, 3]&gt;
Data type
  MapSet
Description
  This is a struct. Structs are maps with a __struct__ key.
Reference modules
  MapSet, Map
Implemented protocols
  IEx.Info, Enumerable, Inspect, Collectable
</code></pre>

<h3 id="struct">Struct</h3>
<p>Struct l√† d·∫°ng ƒë·∫∑c bi·ªát c·ªßa Map, d√πng ƒë·ªÉ bi·ªÉu di·ªÖn c√°c ki·ªÉu d·ªØ li·ªáu
do ng∆∞·ªùi d√πng t·ª± ƒë·ªãnh nghƒ©a.</p>
<pre><code>iex(1)&gt; defmodule Person do
...(1)&gt;   defstruct [:name, :age]
...(1)&gt; end
{:module, Person,
 &lt;&lt;70, 79, 82, 49, 0, 0, 8, 20, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0,
   234, 0, 0, 0, 22, 13, 69, 108, 105, 120, 105, 114, 46, 80, 101, 114,
   115, 111, 110, 8, 95, 95, 105, 110, 102, 111, 95, 95, ...&gt;&gt;,
 %Person{age: nil, name: nil}}
iex(2)&gt; i %Person{name: &quot;HVN&quot;, age: 27}
Term
  %Person{age: 27, name: &quot;HVN&quot;}
Data type
  Person
Description
  This is a struct. Structs are maps with a __struct__ key.
Reference modules
  Person, Map
Implemented protocols
  IEx.Info, Inspect
</code></pre>

<h2 id="cac-thao-tac-co-ban-voi-cac-kieu-du-lieu">C√°c thao t√°c c∆° b·∫£n v·ªõi c√°c ki·ªÉu d·ªØ li·ªáu</h2>
<h3 id="thao-tac-voi-so">Thao t√°c v·ªõi s·ªë</h3>
<ul>
<li>T√≠nh b√¨nh ph∆∞∆°ng, cƒÉn, sin, cos... s·ª≠ d·ª•ng module <code>:math</code> c·ªßa Erlang</li>
</ul>
<pre><code>iex(11)&gt; :math.pow(2,4)
16.0
iex(12)&gt; :math.sin(2 * :math.pi)
-2.4492935982947064e-16
iex(17)&gt; :math.sqrt(4)
2.0
</code></pre>

<ul>
<li>Convert float th√†nh integer (b·ªè ph·∫ßn th·∫≠p ph√¢n)</li>
</ul>
<pre><code>iex(24)&gt; trunc 5.7
5
iex(25)&gt; trunc 5.1
5
</code></pre>

<ul>
<li>Convert string th√†nh integer:</li>
</ul>
<pre><code>iex(26)&gt; &quot;5&quot; |&gt; String.to_integer
5
</code></pre>

<ul>
<li>L√†m tr√≤n float th√†nh integer g·∫ßn nh·∫•t</li>
</ul>
<pre><code>iex(28)&gt; round 6.5
7
iex(29)&gt; round 7.5
8
iex(30)&gt; round 7.1
7
</code></pre>

<h3 id="thao-tac-voi-string">Thao t√°c v·ªõi String</h3>
<p>Ch√∫ √Ω: ƒê·ªÉ t∆∞∆°ng th√≠ch v·ªõi Unicode, c√°c function trong String h·∫ßu h·∫øt c√≥ ƒë·ªô ph·ª©c t·∫°p
l√† O(n), kh√° ch·∫≠m. Th·∫≠m ch√≠ n·∫øu b·∫°n c·∫ßn l·∫•y k√Ω t·ª± ·ªü v·ªã tr√≠ th·ª© N, Elixir c≈©ng ph·∫£i
ƒëi l·∫ßn l∆∞·ª£t t·ª´ng k√Ω t·ª± cho ƒë·∫øn k√Ω t·ª± th·ª© N.
N·∫øu kh√¥ng c·∫ßn x·ª≠ l√Ω string Unicode, c√≥ th·ªÉ d√πng c√°c binary function ƒë·ªÉ c√≥ t·ªëc ƒë·ªô O(1).
(Xem chi ti·∫øt trong t√†i li·ªáu c·ªßa String module).</p>
<pre><code>iex(30)&gt; String.length(&quot;abcdef&quot;)
6
iex(31)&gt; byte_size(&quot;abcdef&quot;)
6
iex(32)&gt; String.at(&quot;abcdef&quot;, 5)
&quot;f&quot;
iex(33)&gt; :binary.at(&quot;abcdef&quot;, 5)
102
iex(34)&gt; binary_part(&quot;abcdef&quot;, 5, 1)
&quot;f&quot;
</code></pre>

<ul>
<li>T·∫°o string t·ª´ ki·ªÉu d·ªØ li·ªáu kh√°c:</li>
</ul>
<pre><code>iex(2)&gt; Integer.to_string(42) &lt;&gt; List.to_string([&quot;a&quot;, &quot;b&quot;])
&quot;42ab&quot;
</code></pre>

<ul>
<li>Ki·ªÉm tra string con:</li>
</ul>
<pre><code>iex(9)&gt; String.contains?(&quot;Python&quot;, &quot;on&quot;)
true
iex(10)&gt; String.contains?(&quot;Python&quot;, &quot;ON&quot;)
false
</code></pre>

<p>Ch√∫ √Ω t√™n function c√≥ d·∫•u ?</p>
<ul>
<li>Ki·ªÉm tra b·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c:</li>
</ul>
<pre><code>iex(11)&gt; String.starts_with?(&quot;Python&quot;, &quot;Py&quot;)
true
iex(12)&gt; String
String      StringIO
iex(12)&gt; String.ends_with?(&quot;Python.mp3&quot;, &quot;.mp3&quot;)
true
</code></pre>

<p>D·ªÖ th·∫•y, nh·ªØng function tr·∫£ v·ªÅ true/false ƒë·ªÅu ƒë∆∞·ª£c ƒë·∫∑t t√™n k·∫øt th√∫c b·∫±ng d·∫•u ?</p>
<ul>
<li>
<p>L·∫•y index #TODO</p>
</li>
<li>
<p>N·ªëi c√°c ph·∫ßn t·ª≠ c·ªßa list (KH√îNG TH·ªÇ N·ªêI TUPLE):</p>
</li>
</ul>
<pre><code>iex(55)&gt; Enum.join([&quot;Python&quot;, &quot;PyMi.vn&quot;], &quot; &quot;)
&quot;Python PyMi.vn&quot;
iex(57)&gt; [&quot;Elixir&quot;, &quot;PyMi.vn&quot;] |&gt; Enum.join(&quot;+&quot;)
&quot;Elixir+PyMi.vn&quot;
iex(61)&gt; &quot;H·ªçc Python&quot; &lt;&gt; &quot; &quot; &lt;&gt; &quot;t·∫°i PyMi.vn&quot;
&quot;H·ªçc Python t·∫°i PyMi.vn&quot;

iex(7)&gt; Enum.join {1, 2}
** (Protocol.UndefinedError) protocol Enumerable not implemented for {1, 2}
    (elixir) lib/enum.ex:1: Enumerable.impl_for!/1
    (elixir) lib/enum.ex:116: Enumerable.reduce/3
    (elixir) lib/enum.ex:1636: Enum.reduce/3
    (elixir) lib/enum.ex:1154: Enum.join/2
iex(7)&gt; Enum.join [1, 2]
&quot;12&quot;
</code></pre>

<ul>
<li>C·∫Øt string, bi·∫øn th√†nh list:</li>
</ul>
<pre><code>iex(63)&gt; String.split(&quot;M√¨nh th√≠ch th√¨ m√¨nh h·ªçc \tth√¥i&quot;, &quot; &quot;)
[&quot;M√¨nh&quot;, &quot;th√≠ch&quot;, &quot;th√¨&quot;, &quot;m√¨nh&quot;, &quot;h·ªçc&quot;, &quot;\tth√¥i&quot;]
iex(64)&gt; String.split(&quot;M√¨nh th√≠ch th√¨ m√¨nh     h·ªçc \tth√¥i&quot;)
[&quot;M√¨nh&quot;, &quot;th√≠ch&quot;, &quot;th√¨&quot;, &quot;m√¨nh&quot;, &quot;h·ªçc&quot;, &quot;th√¥i&quot;]
</code></pre>

<p>Gi·ªëng nh∆∞ Python.</p>
<p>Nh∆∞ng Elixir c√≤n c√≥ th·ªÉ Split t·∫°i nhi·ªÅu "separator":</p>
<pre><code>iex(7)&gt; String.split(&quot;a-b+c&quot;, [&quot;-&quot;, &quot;+&quot;])
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre>

<ul>
<li>trim/trim_leading/trim_trailing</li>
</ul>
<pre><code>iex(14)&gt; String.trim(&quot;   a\t abc\n&quot;)
&quot;a\t abc&quot;
iex(15)&gt; String.trim_leading(&quot;   a\t abc\n&quot;)
&quot;a\t abc\n&quot;
iex(16)&gt; String.trim_trailing(&quot;   a\t abc\n&quot;)
&quot;   a\t abc&quot;
</code></pre>

<ul>
<li>replace</li>
</ul>
<pre><code>iex(17)&gt; String.replace(&quot;Python&quot;, &quot;Py&quot;, &quot;Jy&quot;)
&quot;Jython&quot;
</code></pre>

<ul>
<li>Ch·ªØ hoa, ch·ªØ th∆∞·ªùng:</li>
</ul>
<pre><code>iex(18)&gt; String.upcase(&quot;Python&quot;)
&quot;PYTHON&quot;
iex(19)&gt; String.downcase(&quot;PYThon&quot;)
&quot;python&quot;
iex(20)&gt; String.capitalize(&quot;python is an animal&quot;)
&quot;Python is an animal&quot;
</code></pre>

<ul>
<li>Bi·∫øn th√†nh ki·ªÉu integer</li>
</ul>
<pre><code>iex(22)&gt; String.to_integer(&quot;   42  &quot;)
** (ArgumentError) argument error
    :erlang.binary_to_integer(&quot;   42  &quot;)
iex(22)&gt; String.to_integer(&quot;42&quot;)
42

</code></pre>

<p>Function n√†y trong Elixir kh√¥ng c√≥ kh·∫£ nƒÉng b·ªè ƒëi whitespace nh∆∞ Python:</p>
<pre><code>In [1]: int(&quot;   42 \n\t   &quot;)
Out[1]: 42
</code></pre>

<ul>
<li>L·∫•y ƒë·ªô d√†i</li>
</ul>
<pre><code>iex(59)&gt;  String.length(&quot;L·∫°c tr√¥i&quot;)
8
iex(60)&gt;  String.length(&quot;L·∫°c tr√¥iüòù&quot;)
9
</code></pre>

<ul>
<li>Slice: slice(string, start, len)</li>
</ul>
<pre><code>iex(1)&gt; String.slice(&quot;Python&quot;, 0, 2)
&quot;Py&quot;
iex(2)&gt; String.slice(&quot;Python&quot;, 2, 10)
&quot;thon&quot;
</code></pre>

<ul>
<li>ƒê·∫£o ng∆∞·ª£c:</li>
</ul>
<pre><code>iex(4)&gt; String.reverse(&quot;DOICAN&quot;)
&quot;NACIOD&quot;
</code></pre>

<p>https://hexdocs.pm/elixir/1.4.2/String.html#content</p>
<h3 id="list_1">List</h3>
<p>S·ª≠ d·ª•ng module <code>List</code>. C√°c function c√≥ s·∫µn c·ªßa module List kh√¥ng gi·ªëng nh∆∞ trong Python, b·ªüi List trong Python c√≥ th·ªÉ thay ƒë·ªïi ƒë∆∞·ª£c (th√™m b·ªõt, s·ª≠a ph·∫ßn t·ª≠) c√≤n List trong Elixir th√¨ kh√¥ng.</p>
<ul>
<li>T·∫°o list</li>
</ul>
<pre><code>iex(8)&gt; li = [1, &quot;PyMi&quot;, &quot;Python&quot;, &quot;Elixir&quot;]
[1, &quot;PyMi&quot;, &quot;Python&quot;, &quot;Elixir&quot;]
iex(10)&gt; i li
Term
  [1, &quot;PyMi&quot;, &quot;Python&quot;, &quot;Elixir&quot;]
Data type
  List
Reference modules
  List
</code></pre>

<p>T·ª´ c√°c ki·ªÉu d·ªØ li·ªáu kh√°c:</p>
<p>String th√†nh charlist:</p>
<pre><code>iex(5)&gt; String.to_charlist &quot;Elixir&quot;
'Elixir'

</code></pre>

<p>String th√†nh list</p>
<pre><code>iex(7)&gt; String.graphemes(&quot;Vi·ªát Nam&quot;)
[&quot;V&quot;, &quot;i&quot;, &quot;·ªá&quot;, &quot;t&quot;, &quot; &quot;, &quot;N&quot;, &quot;a&quot;, &quot;m&quot;]
</code></pre>

<ul>
<li>L·∫•y ƒë·∫ßu (head)</li>
</ul>
<pre><code>iex(11)&gt; hd li
1
</code></pre>

<ul>
<li>L·∫•y ƒëu√¥i (tail)</li>
</ul>
<pre><code>iex(12)&gt; tl li
[&quot;PyMi&quot;, &quot;Python&quot;, &quot;Elixir&quot;]
</code></pre>

<ul>
<li>L·∫•y ƒë·∫ßu v√† ƒëu√¥i:</li>
</ul>
<pre><code>iex(24)&gt; [head | tail] = [&quot;Python&quot;, &quot;PyMi&quot;, &quot;Golang&quot;, &quot;FAMILUG.org&quot;]
[&quot;Python&quot;, &quot;PyMi&quot;, &quot;Golang&quot;, &quot;FAMILUG.org&quot;]
iex(25)&gt; head
&quot;Python&quot;
iex(26)&gt; tail
[&quot;PyMi&quot;, &quot;Golang&quot;, &quot;FAMILUG.org&quot;]
</code></pre>

<ul>
<li>L·∫•y ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n, cu·ªëi c√πng</li>
</ul>
<pre><code>iex(9)&gt; List.first [&quot;Python&quot;, &quot;Golang&quot;, &quot;Elixir&quot;]
&quot;Python&quot;
iex(10)&gt; List.last [&quot;Python&quot;, &quot;Golang&quot;, &quot;Elixir&quot;]
&quot;Elixir&quot;
</code></pre>

<ul>
<li>G√≥i d·ªØ li·ªáu v√†o m·ªôt list (n·∫øu n√≥ ch∆∞a ph·∫£i 1 list)</li>
</ul>
<pre><code>iex(13)&gt; List.wrap(&quot;Lac troi&quot;)
[&quot;Lac troi&quot;]
iex(14)&gt; List.wrap(0)
[0]
iex(15)&gt; List.wrap(nil)
[]
</code></pre>

<ul>
<li>Ki·ªÉm tra s·ªë ph·∫ßn t·ª≠</li>
</ul>
<pre><code>iex(14)&gt; length li
4
</code></pre>

<ul>
<li>Ki·ªÉm tra m·ªôt ph·∫ßn t·ª≠ c√≥ trong list kh√¥ng</li>
</ul>
<pre><code>iex(5)&gt; Enum.member?([1,2,4], 3)
false
</code></pre>

<p>Hay d√πng c√∫ ph√°p <code>left in right</code>:</p>
<pre><code>iex(21)&gt; 1 in [1, 2, 3]
true
</code></pre>

<p>Ch√∫ √Ω c√∫ ph√°p <code>in</code> n√†y kh√¥ng ho·∫°t ƒë·ªông v·ªõi tuple, map (nh∆∞ trong Python).</p>
<pre><code>iex(21)&gt; 1 in {1, 2, 3}
** (Protocol.UndefinedError) protocol Enumerable not implemented for {1, 2, 3}
    (elixir) lib/enum.ex:1: Enumerable.impl_for!/1
    (elixir) lib/enum.ex:131: Enumerable.member?/2
    (elixir) lib/enum.ex:1352: Enum.member?/2
iex(22)&gt; :a in %{:a =&gt; value}
** (CompileError) iex:22: undefined function value/0
    (elixir) expanding macro: Kernel.in/2
             iex:22: (file)
</code></pre>

<ul>
<li>N·ªëi 2 list <em>concatenate</em></li>
</ul>
<pre><code>iex(18)&gt; li ++ [2, &quot;Erlang&quot;]
[1, &quot;PyMi&quot;, &quot;Python&quot;, &quot;Elixir&quot;, 2, &quot;Erlang&quot;]
</code></pre>

<ul>
<li>Tr·ª´ 2 list <em>subtract</em></li>
</ul>
<pre><code>iex(22)&gt; [1, 2, 3, 2, 1] -- [2]
[1, 3, 2, 1]
iex(23)&gt; [1, 2, 3, 2, 1] -- [2, 3]
[1, 2, 1]
</code></pre>

<ul>
<li>"Th√™m" ph·∫ßn t·ª≠ v√†o list: th·ª±c ra l√† t·∫°o m·ªôt list m·ªõi
Th√™m "Zero" v√†o index 0</li>
</ul>
<pre><code>iex(21)&gt; List.insert_at(li, 0, &quot;Zero&quot;)
[&quot;Zero&quot;, 1, &quot;PyMi&quot;, &quot;Python&quot;, &quot;Elixir&quot;]
</code></pre>

<ul>
<li>"Th√™m" m·ªôt ph·∫ßn t·ª≠ v√†o ƒë·∫ßu list (si√™u t·ªëc - constant time O(1)):</li>
</ul>
<pre><code>iex(27)&gt; l3 = [&quot;Python&quot;, &quot;PyMi&quot;, &quot;Golang&quot;, &quot;FAMILUG.org&quot;]
[&quot;Python&quot;, &quot;PyMi&quot;, &quot;Golang&quot;, &quot;FAMILUG.org&quot;]
iex(28)&gt; [&quot;h&quot; | l3]
[&quot;h&quot;, &quot;Python&quot;, &quot;PyMi&quot;, &quot;Golang&quot;, &quot;FAMILUG.org&quot;]
</code></pre>

<ul>
<li>"Th√™m" m·ªôt ph·∫ßn t·ª≠ xu·ªëng cu·ªëi list (ch·∫≠m, linear time O(n))</li>
</ul>
<pre><code>iex(30)&gt; l3 ++ [&quot;t&quot;]
[&quot;Python&quot;, &quot;PyMi&quot;, &quot;Golang&quot;, &quot;FAMILUG.org&quot;, &quot;t&quot;]
</code></pre>

<ul>
<li>Thay m·ªôt ph·∫ßn t·ª≠ c·ªßa list t·∫°i 1 index:</li>
</ul>
<pre><code>iex(33)&gt; List.replace_at([&quot;Python&quot;, &quot;PyMi&quot;, &quot;Golang&quot;, &quot;FAMILUG.org&quot;, &quot;t&quot;], 2, &quot;Elixir&quot;)
[&quot;Python&quot;, &quot;PyMi&quot;, &quot;Elixir&quot;, &quot;FAMILUG.org&quot;, &quot;t&quot;]
</code></pre>

<ul>
<li>"Xo√°" ph·∫ßn t·ª≠ kh·ªèi list (d√πng value c·ªßa ph·∫ßn t·ª≠ v√† d√πng index):</li>
</ul>
<pre><code>iex(31)&gt; List.delete([&quot;Python&quot;, &quot;PyMi&quot;, &quot;Golang&quot;, &quot;FAMILUG.org&quot;, &quot;t&quot;], &quot;Golang&quot;)
[&quot;Python&quot;, &quot;PyMi&quot;, &quot;FAMILUG.org&quot;, &quot;t&quot;]
iex(32)&gt; List.delete_at([&quot;Python&quot;, &quot;PyMi&quot;, &quot;Golang&quot;, &quot;FAMILUG.org&quot;, &quot;t&quot;], 2)
[&quot;Python&quot;, &quot;PyMi&quot;, &quot;FAMILUG.org&quot;, &quot;t&quot;]
</code></pre>

<ul>
<li>L√†m ph·∫≥ng 1 list (ch·ª©a c√°c list kh√°c)</li>
</ul>
<pre><code>iex(11)&gt; List.flatten [&quot;Python&quot;, [&quot;Erlang&quot;, &quot;Elixir&quot;]]
[&quot;Python&quot;, &quot;Erlang&quot;, &quot;Elixir&quot;]
</code></pre>

<ul>
<li>L·∫•y m·ªôt list con t·ª´ list (slice):
slice(enumerable, start, amount)</li>
</ul>
<pre><code>iex(36)&gt;  Enum.slice([&quot;Python&quot;, &quot;PyMi&quot;, &quot;Elixir&quot;, &quot;FAMILUG.org&quot;], 1, 10)
[&quot;PyMi&quot;, &quot;Elixir&quot;, &quot;FAMILUG.org&quot;]
</code></pre>

<p><strong>Ch√∫ √Ω</strong> argument th·ª© 3 l√† s√≥ ph·∫ßn t·ª≠ s·∫Ω slice,
kh√¥ng ph·∫£i index k·∫øt th√∫c nh∆∞ trong Python.</p>
<ul>
<li>S·∫Øp x·∫øp 1 list</li>
</ul>
<p>Theo b·∫£ng ch·ªØ c√°i</p>
<pre><code>iex(37)&gt; Enum.sort([&quot;Python&quot;, &quot;PyMi&quot;, &quot;Elixir&quot;, &quot;FAMILUG.org&quot;, &quot;t&quot;])
[&quot;Elixir&quot;, &quot;FAMILUG.org&quot;, &quot;PyMi&quot;, &quot;Python&quot;, &quot;t&quot;]
</code></pre>

<p>Theo ti√™u ch√≠ nh·∫•t ƒë·ªãnh (function)</p>
<pre><code>iex(35)&gt; Enum.sort_by([&quot;Python&quot;, &quot;PyMi&quot;, &quot;Elixir&quot;, &quot;FAMILUG.org&quot;, &quot;t&quot;], &amp;String.length/1)
[&quot;t&quot;, &quot;PyMi&quot;, &quot;Python&quot;, &quot;Elixir&quot;, &quot;FAMILUG.org&quot;]
</code></pre>

<p>https://hexdocs.pm/elixir/Enum.html#content</p>
<h3 id="tuple_1">Tuple</h3>
<p>Lu√¥n ch√∫ √Ω r·∫±ng trong Elixir, m·ªçi ki·ªÉu d·ªØ li·ªáu ƒë·ªÅu l√† immutable, n√™n m·ªçi
function thay ƒë·ªïi d·ªØ li·ªáu ƒë·ªÅu tr·∫£ v·ªÅ m·ªôt gi√° tr·ªã m·ªõi, kh√¥ng thay ƒë·ªïi ƒë·∫ßu v√†o ƒë√£
g·ªçi v·ªõi function.</p>
<p>Thay m·ªôt ph·∫ßn t·ª≠ t·∫°i index</p>
<pre><code>iex(2)&gt; put_elem {:foo, &quot;bar&quot;}, 1, &quot;bye&quot;
{:foo, &quot;bye&quot;}
</code></pre>

<p>Th√™m m·ªôt gi√° tr·ªã v√†o index</p>
<pre><code>iex(4)&gt; Tuple.insert_at {&quot;toi&quot;, &quot;em&quot;}, 1, &quot;thang ay&quot;
{&quot;toi&quot;, &quot;thang ay&quot;, &quot;em&quot;}

</code></pre>

<p>Th√™m v√†o cu·ªëi tuple:</p>
<pre><code>iex(5)&gt; Tuple.append {6, 9}, &quot;Tail&quot;
{6, 9, &quot;Tail&quot;}
</code></pre>

<p>X√≥a t·∫°i index</p>
<pre><code>iex(6)&gt; Tuple.delete_at {&quot;Elixir&quot;, &quot;is&quot;, :not, &quot;great&quot;}, 2
{&quot;Elixir&quot;, &quot;is&quot;, &quot;great&quot;}
</code></pre>

<p>Bi·∫øn th√†nh list</p>
<pre><code>iex(7)&gt; Tuple.to_list {:x, :y, :z}
[:x, :y, :z]
</code></pre>

<h3 id="map">Map</h3>
<p>l√† m·ªôt c·∫•u tr√∫c d·ªØ li·ªáu c√≥ th·ªÉ g·ªçi l√† "key-value" store.
T√™n kh√°c (trong ng√¥n ng·ªØ kh√°c): dictionary, associative array</p>
<pre><code>map = %{:a =&gt; 1, :b =&gt; 2}
</code></pre>

<ul>
<li>T·∫°o map:
%{key =&gt; value1, key =&gt; value2}</li>
</ul>
<pre><code>iex(47)&gt;  %{:a =&gt; 1, :b =&gt;2}
%{a: 1, b: 2}
iex(48)&gt; %{&quot;name&quot; =&gt; &quot;PYMI&quot;, &quot;country&quot; =&gt; &quot;VN&quot;}
%{&quot;country&quot; =&gt; &quot;VN&quot;, &quot;name&quot; =&gt; &quot;PYMI&quot;}
</code></pre>

<ul>
<li>T·∫°o map t·ª´ list c·ªßa c√°c tuple-2:</li>
</ul>
<pre><code>iex(59)&gt; [{1, 7}, {2, 3}] |&gt; Map.new
%{1 =&gt; 7, 2 =&gt; 3}
</code></pre>

<ul>
<li>T·∫°o list t·ª´ map:</li>
</ul>
<pre><code>iex(60)&gt; [{1, 7}, {2, 3}] |&gt; Map.new |&gt; Map.to_list
[{1, 7}, {2, 3}]
</code></pre>

<ul>
<li>ƒê·∫øm s·ªë ph·∫ßn t·ª≠</li>
<li>Truy c·∫≠p value:</li>
</ul>
<pre><code>iex(68)&gt; %{:name =&gt; who} = %{:name =&gt; &quot;HVN&quot;}
%{name: &quot;HVN&quot;}
iex(69)&gt; who
&quot;HVN&quot;

iex(44)&gt; map = %{:a =&gt; 1, :b =&gt;2}
%{a: 1, b: 2}
iex(46)&gt; map[:b]
2
iex(47)&gt; map[:c]
nil
</code></pre>

<p>Hay</p>
<pre><code>iex(60)&gt; Map.get(map, :b)
2
iex(64)&gt; Map.get(%{first_name: &quot;Jon&quot;, last_name: &quot;Snow&quot;}, :age)
nil
</code></pre>

<p>Ho·∫∑c</p>
<pre><code>iex(2)&gt; Map.fetch(%{first_name: &quot;Jon&quot;, last_name: &quot;Snow&quot;}, :last_name)
{:ok, &quot;Snow&quot;}
iex(3)&gt; Map.fetch(%{first_name: &quot;Jon&quot;, last_name: &quot;Snow&quot;}, :age)
:error
</code></pre>

<ul>
<li>Ki·ªÉm tra key c√≥ trong map kh√¥ng</li>
</ul>
<pre><code>iex(3)&gt; Map.has_key?(%{:name =&gt; &quot;HVN&quot;}, :age)
false
</code></pre>

<ul>
<li>"Th√™m" key-value m·ªõi:</li>
</ul>
<pre><code>iex(62)&gt; Map.put(%{:a =&gt; 1}, :h, 4)
%{a: 1, h: 4}
</code></pre>

<ul>
<li>Xo√° key-value:</li>
</ul>
<pre><code>iex(1)&gt; Map.delete(%{:name =&gt; &quot;HVN&quot;, :age =&gt; 27}, :age)
%{name: &quot;HVN&quot;}
</code></pre>

<p>Xo√° key kh√¥ng t·ªìn t·∫°i kh√¥ng ·∫£nh h∆∞·ªüng g√¨:</p>
<pre><code>iex(2)&gt; Map.delete(%{:name =&gt; &quot;HVN&quot;, :age =&gt; 27}, :language)
%{age: 27, name: &quot;HVN&quot;}
</code></pre>

<ul>
<li>
<p>Duy·ªát qua t·ª´ng key # TODO</p>
</li>
<li>
<p>G·ªôp (merge) 2 map</p>
</li>
</ul>
<pre><code>iex(6)&gt; Map.merge(%{first_name: &quot;Jon&quot;, last_name: &quot;Snow&quot;}, %{last_name: &quot;Water&quot;, age: 27})
%{age: 27, first_name: &quot;Jon&quot;, last_name: &quot;Water&quot;}
</code></pre>

<ul>
<li>Bi·∫øn th√†nh list c√°c tuple key-value:</li>
</ul>
<pre><code>iex(63)&gt; Map.to_list(%{:name =&gt; &quot;HVN&quot;, :age =&gt; 27})
[age: 27, name: &quot;HVN&quot;]
</code></pre>

<ul>
<li>Update value c·ªßa 1 key ƒë√£ trong map (kh√¥ng th√™m):</li>
</ul>
<pre><code>iex(65)&gt; %{ map | :b =&gt; 5}
%{a: 1, b: 5}
iex(66)&gt; %{ map | :c =&gt; 5}
** (KeyError) key :c not found in: %{a: 1, b: 2}
</code></pre>

<ul>
<li>Truy c·∫≠p c√°c atom key b·∫±ng <code>.</code>:</li>
</ul>
<pre><code>iex(66)&gt; student = %{:name =&gt; &quot;HVN&quot;}
%{name: &quot;HVN&quot;}
iex(67)&gt; student.name
&quot;HVN&quot;
</code></pre>

<ul>
<li>Update value nested dict v·ªõi <code>put_in/2</code>:</li>
</ul>
<pre><code>iex(70)&gt; users = [hvn: %{name: &quot;HVN&quot;, age: 27, language: [&quot;Erlang&quot;, &quot;Elixir&quot;, &quot;Python&quot;]},
hails: %{name: &quot;HaiLS&quot;, age: 26, language: [&quot;Golang&quot;, &quot;JS&quot;]}]
[hvn: %{age: 27, language: [&quot;Erlang&quot;, &quot;Elixir&quot;, &quot;Python&quot;], name: &quot;HVN&quot;},
 hails: %{age: 26, language: [&quot;Golang&quot;, &quot;JS&quot;], name: &quot;HaiLS&quot;}]

iex(72)&gt; put_in users[:hvn].age, 29
[hvn: %{age: 29, language: [&quot;Erlang&quot;, &quot;Elixir&quot;, &quot;Python&quot;], name: &quot;HVN&quot;},
 hails: %{age: 26, language: [&quot;Golang&quot;, &quot;JS&quot;], name: &quot;HaiLS&quot;}]
</code></pre>

<ul>
<li>Bi·∫øn map n√†y th√†nh map kh√°c, s·ª≠ d·ª•ng <code>Enum.into/3</code>:</li>
</ul>
<pre><code>iex(2)&gt;  %{a: [1, 2, 3], b: [&quot;meo&quot;, &quot;ga&quot;]} |&gt; Enum.into(%{}, fn {k, v} -&gt; {k, length(v)} end)
%{a: 3, b: 2}
</code></pre>

<p>M·ªói ki·ªÉu d·ªØ li·ªáu ƒë·ªÅu c√≥ m·ªôt module t∆∞∆°ng ·ª©ng cung c·∫•p c√°c function c·∫ßn thi·∫øt: List, Map, String. Module <code>Enum</code> d√πng chung cho c√°c ki·ªÉu d·ªØ li·ªáu cho ph√©p duy·ªát qua t·ª´ng ph·∫ßn t·ª≠: nh∆∞ <code>List</code></p>
<h3 id="mapset">MapSet</h3>
<ul>
<li>Ki·ªÉm tra ph·∫ßn t·ª≠</li>
</ul>
<pre><code>iex(12)&gt; MapSet.member?(MapSet.new([1, 3, 43, 98]) , 9)
false
</code></pre>

<ul>
<li>C√°c ph√©p to√°n t·∫≠p h·ª£p (giao - intersection, h·ª£p - union,...)</li>
</ul>
<pre><code>iex(16)&gt; MapSet.intersection(MapSet.new([1,3,5]), MapSet.new([1,5,2]))
#MapSet&lt;[1, 5]&gt;
#MapSet&lt;[1, 2, 3, 5]&gt;
</code></pre>

<h3 id="struct_1">Struct</h3>
<p>L·∫•y gi√° tr·ªã c·ªßa field</p>
<pre><code>iex(1)&gt; defmodule Person do
...(1)&gt;   defstruct [:name, :age]
...(1)&gt; end
...
iex(3)&gt; Map.fetch %Person{name: &quot;HVN&quot;, age: 27}, :name
{:ok, &quot;HVN&quot;}
</code></pre>

<p>Thay ƒë·ªïi gi√° tr·ªã c·ªßa c√°c field trong struct</p>
<pre><code>iex(4)&gt; hvn = %Person{name: &quot;HVN&quot;, age: 27}
%Person{age: 27, name: &quot;HVN&quot;}
iex(5)&gt; %{hvn | age: hvn.age + 1}
%Person{age: 28, name: &quot;HVN&quot;}
</code></pre>

<p>Thay ƒë·ªïi gi√° tr·ªã c·ªßa nested value (value c·ªßa field trong struct trong struct kh√°c ...)</p>
<pre><code>iex(2)&gt; defmodule Class do
...(2)&gt;   defstruct person: %Person{}, name: &quot;PyMI&quot;
...(2)&gt; end
...
iex(4)&gt; pymi = %Class{person: %Person{name: &quot;HVN&quot;, age: 27}}
%Class{name: &quot;PyMI&quot;, person: %Person{age: 27, name: &quot;HVN&quot;}}
iex(5)&gt; put_in pymi.person.age, 28
%Class{name: &quot;PyMI&quot;, person: %Person{age: 28, name: &quot;HVN&quot;}}
</code></pre>

<h2 id="pattern-matching">Pattern matching</h2>
<p><code>=</code> : the match operator
- Khi g√°n bi·∫øn, bi·∫øn ph·∫£i n·∫±m b√™n tr√°i d·∫•u <code>=</code></p>
<pre><code>iex(7)&gt; x = 5
5
iex(8)&gt; 6 = y
** (CompileError) iex:8: undefined function y/0
</code></pre>

<ul>
<li>V·∫ø tr√°i c√≥ th·ªÉ l√† ki·ªÉu d·ªØ li·ªáu ph·ª©c t·∫°p h∆°n, d√πng ƒë·ªÉ "destructuring" hay "unpacking" d·ªØ li·ªáu ph√≠a tay ph·∫£i.
S·ªë ph·∫ßn t·ª≠ 2 b√™n ph·∫£i b·∫±ng nhau, c√πng ki·ªÉu:</li>
</ul>
<pre><code>iex(18)&gt; {name, age} = {&quot;PyMI.vn&quot;, 2}
{&quot;PyMI.vn&quot;, 2}
iex(19)&gt; name
&quot;PyMI.vn&quot;
iex(20)&gt; age
2

iex(1)&gt; [x, y, z] = [1, 2, 4]  # list
[1, 2, 4]
iex(2)&gt; x
1
iex(3)&gt; z
4
</code></pre>

<p>Khi b√™n ph·∫£i ch·ª©a gi√° tr·ªã thay v√¨ bi·∫øn, 2 b√™n ch·ªâ match nhau n·∫øu gi√° tr·ªã b√™n tay tr√°i match gi√° tr·ªã b√™n tay ph·∫£i:</p>
<pre><code>iex(4)&gt; {:ok, 1, salary} = {:ok, 1, 15}
{:ok, 1, 15}
iex(5)&gt; {:ok, 1, income} = {:ok, 3, 20}
** (MatchError) no match of right hand side value: {:ok, 3, 20}

iex(10)&gt; {x, x} = {1, 1}
{1, 1}
iex(11)&gt; {x, x} = {1, 2}
** (MatchError) no match of right hand side value: {1, 2}


</code></pre>

<p>Khi 2 b√™n kh√¥ng "match", MatchError s·∫Ω x·∫£y ra.</p>
<ul>
<li>Matching v·ªõi c√∫ ph√°p [head | tail]:</li>
</ul>
<pre><code>iex(5)&gt; [h | t] = [1, 2, 3, 4]
[1, 2, 3, 4]
iex(6)&gt; h
1
iex(7)&gt; t
[2, 3, 4]
</code></pre>

<p>Gi·ªëng nh∆∞ g·ªçi function <code>hd</code> v√† <code>tl</code>:</p>
<pre><code>iex(8)&gt; hd [1, 2, 3, 4]
1
iex(9)&gt; tl [1, 2, 3, 4]
[2, 3, 4]
</code></pre>

<p>C√∫ ph√°p n√†y r√µ r√†ng kh√¥ng match list r·ªóng:</p>
<pre><code>iex(10)&gt; [h | t] = []
** (MatchError) no match of right hand side value: []

</code></pre>

<ul>
<li>Truy c·∫≠p gi√° tr·ªã c·ªßa m·ªôt bi·∫øn thay v√¨ g√°n l·∫°i n√≥ b·∫±ng <code>^</code> - pin operator:</li>
</ul>
<pre><code>iex(11)&gt; x = 5
5
iex(12)&gt; x = 7
7
iex(13)&gt; x
7
iex(14)&gt; ^x = 8
** (MatchError) no match of right hand side value: 8
V√¨ gi·ªëng nh∆∞ vi·∫øt: 7 = 8
iex(14)&gt; 7 = 8
** (MatchError) no match of right hand side value: 8
</code></pre>

<h2 id="control-flow-case-cond-if-unless-doend">Control flow: case, cond, if, unless, do/end</h2>
<h3 id="if">if</h3>
<p>if/2 l√† m·ªôt function, t·ª©c n√≥ s·∫Ω tr·∫£ v·ªÅ m·ªôt gi√° tr·ªã sau khi ch·∫°y. Kh√°c v·ªõi Python hay nhi·ªÅu ng√¥n ng·ªØ kh√°c, if trong Python l√† m·ªôt "statement" (c√¢u l·ªánh), v√† n√≥ ch·ªâ th·ª±c hi·ªán ƒëi·ªÅu khi·ªÉn lu·ªìng ch·ª© kh√¥ng tr·∫£ v·ªÅ gi√° tr·ªã n√†o.
(PS: th·ª±c s·ª± if/2 m√† 1 macro - kh√°i ni·ªám macro s·∫Ω ƒë∆∞·ª£c n√≥i sau)</p>
<pre><code>iex(15)&gt; k = if 5 &gt; 4 do
...(15)&gt; &quot;yeah&quot;
...(15)&gt; end
&quot;yeah&quot;
iex(16)&gt; k
&quot;yeah&quot;
</code></pre>

<p>if/2 tr·∫£ v·ªÅ nil n·∫øu ƒëi·ªÅu ki·ªán n√≥ nh·∫≠n ƒë∆∞·ª£c tr·∫£ v·ªÅ false hay nil.</p>
<pre><code>iex(17)&gt; h = if 5 &lt; 4 do
...(17)&gt; &quot;hey&quot;
...(17)&gt; end
nil
iex(18)&gt; h
nil
</code></pre>

<p>M·∫´u c√∫ ph√°p:</p>
<pre><code>if condition do
SOMETHING
end
</code></pre>

<p><code>if</code> c√≥ th·ªÉ ƒëi k√®m v·ªõi <code>else</code>:</p>
<pre><code>iex(19)&gt; m = if 5 &lt; 4 do
...(19)&gt; &quot;smaller&quot;
...(19)&gt; else
...(19)&gt; &quot;bigger&quot;
...(19)&gt; end
&quot;bigger&quot;
iex(20)&gt; m
&quot;bigger&quot;
</code></pre>

<p>Trong Elixir ch·ªâ c√≥ <code>if/else/end</code> kh√¥ng c√≥ elif nh∆∞ trong Python, khi c·∫ßn x·ª≠ l√Ω nhi·ªÅu tr∆∞·ªùng h·ª£p, ta c√≥ th·ªÉ d√πng cond.</p>
<p>ƒê·ªçc th√™m: https://hexdocs.pm/elixir/Kernel.html#if/2</p>
<h3 id="cond">cond</h3>
<p><code>cond do ... end</code> cho ph√©p x·ª≠ l√Ω nhi·ªÅu ƒëi·ªÅu ki·ªán, gi·ªëng nh∆∞ elif hay else if trong c√°c ng√¥n ng·ªØ kh√°c:</p>
<pre><code>iex(24)&gt; x = 18
18
iex(25)&gt; cond do
...(25)&gt;   x &lt; 18 -&gt;
...(25)&gt;     &quot;Not permitted&quot;
...(25)&gt;   x == 18 -&gt;
...(25)&gt;     &quot;Okay&quot;
...(25)&gt;   x &gt; 18 -&gt;
...(25)&gt;     &quot;Too old&quot;
...(25)&gt; end
&quot;Okay&quot;
</code></pre>

<h3 id="unless">unless</h3>
<p>Nh∆∞ if, nh∆∞ng ng∆∞·ª£c l·∫°i.</p>
<pre><code>iex(26)&gt; x = 18
18
iex(27)&gt; unless x &lt; 18 do
...(27)&gt;   &quot;got this&quot;
...(27)&gt; end
&quot;got this&quot;
iex(28)&gt; if x &lt; 18 do
...(28)&gt;   &quot;no&quot;
...(28)&gt; end
nil
</code></pre>

<h3 id="case">case</h3>
<p><code>case</code> s·ª≠ d·ª•ng pattern matching, v√† ch·ªâ d·ª´ng l·∫°i khi ta t√¨m th·∫•y gi√° tr·ªã n√†o match. Ta th·∫•y <code>case</code> ch·ªâ d√πng ƒë·ªÉ ki·ªÉm tra xem 1 gi√° tr·ªã c√≥ b·∫±ng m·ªôt gi√° tr·ªã kh√°c, ch·ª© kh√¥ng d√πng so s√°nh &gt;, &lt; ... nh∆∞ <code>if</code>.</p>
<pre><code>iex(22)&gt; case 5 do
...(22)&gt;   4 -&gt;
...(22)&gt;
...(22)&gt; &quot;Won't match&quot;
...(22)&gt; _ -&gt;
...(22)&gt; &quot;will match&quot;
...(22)&gt; end
&quot;will match&quot;
</code></pre>

<pre><code>iex(23)&gt; case {1, 2, 3} do
...(23)&gt;   {1, x, 3} when x &gt; 0 -&gt;
...(23)&gt;     &quot;will match&quot;
...(23)&gt;   _ -&gt;
...(23)&gt;     &quot;Would match, if guard cond were not sastified&quot;
...(23)&gt; end
&quot;will match&quot;
</code></pre>

<p><code>when x &gt; 0</code> g·ªçi l√† guard condition. Ta th·∫•y <code>case</code> c≈©ng l√† m·ªôt macro ch·ª© kh√¥ng ph·∫£i "statement" nh∆∞ trong c√°c ng√¥n ng·ªØ kh√°c.</p>
<p>C√∫ ph√°p:</p>
<pre><code>case SOMETHING do
  CLAUSE1 [GUARD] -&gt;
      &quot;OTHERTHING&quot;
  CLAUSE2 [GUARD] -&gt;
     ...
  _ -&gt;
     &quot;LAST PATTERN MATCH REMAIN&quot;
end
</code></pre>

<p>N·∫øu kh√¥ng clause n√†o match, error s·∫Ω ƒë∆∞·ª£c raise:</p>
<pre><code>iex(24)&gt; case :ok do
...(24)&gt;   :error -&gt;
...(24)&gt;     &quot;Not match&quot;
...(24)&gt; end
** (CaseClauseError) no case clause matching: :ok

</code></pre>

<h3 id="guard">Guard</h3>
<p>Trong guard kh√¥ng ƒë∆∞·ª£c d√πng &amp;&amp; || !
Error trong guard s·∫Ω khi·∫øn guard fail.</p>
<h3 id="doend">do/end</h3>
<p>Trong <code>if</code> <code>unless</code> <code>cond</code> <code>case</code> ƒë·ªÅu c√≥ d√πng <code>do</code> v√†
k·∫øt th√∫c b·∫±ng <code>end</code>.</p>
<pre><code>if true do
...
end
</code></pre>

<p>T∆∞∆°ng ƒë∆∞∆°ng v·ªõi:</p>
<pre><code>if true, do: (
...
)
</code></pre>

<p><code>do/end</code> l√† syntactix sugar (c√∫ ph√°p ƒë·ªÉ vi·∫øt cho d·ªÖ).</p>
<h2 id="function">Function</h2>
<h3 id="goi-function-calling">G·ªçi function (calling):</h3>
<p>C√∫ ph√°p th√¥ng th∆∞·ªùng:</p>
<pre><code>iex(1)&gt; String.to_integer(String.trim(&quot;  42 \n &quot;))
42
iex(7)&gt; String.split(&quot;42-15\n17&quot;, [&quot;-&quot;, &quot;\n&quot;])
[&quot;42&quot;, &quot;15&quot;, &quot;17&quot;]
</code></pre>

<p>C√∫ ph√°p b·ªè d·∫•u <code>()</code>:</p>
<pre><code>iex(8)&gt; String.split &quot;42-15\n17&quot;, [&quot;-&quot;, &quot;\n&quot;]
[&quot;42&quot;, &quot;15&quot;, &quot;17&quot;]

iex(10)&gt; Enum.map(String.split(&quot;42-15\n17&quot;, [&quot;-&quot;, &quot;\n&quot;]), fn(x) -&gt; String.to_integer(x) end)
[42, 15, 17]
</code></pre>

<h4 id="toan-tu-pipe-pipe-operator">To√°n t·ª≠ pipe (pipe operator)</h4>
<p>C√∫ ph√°p s·ª≠ d·ª•ng "pipe", d·ªØ li·ªáu s·∫Ω ch·∫°y t·ª´ output c·ªßa 1 function, qua pipe v√† tr·ªü th√†nh argument ƒë·∫ßu ti√™n c·ªßa function ti·∫øp theo (gi·ªëng Pipeline tr√™n UNIX shell).</p>
<pre><code>iex(11)&gt; String.split(&quot;42-15\n17&quot;, [&quot;-&quot;, &quot;\n&quot;]) |&gt; Enum.map(fn(x) -&gt; String.to_integer(x) end)
[42, 15, 17]

iex(23)&gt; 1..1000 |&gt; Enum.filter(fn(x) -&gt; (rem(x, 3) == 0 || rem(x, 5) == 0) end) |&gt; Enum.sum
234168
</code></pre>

<h3 id="inh-nghia-function">ƒê·ªãnh nghƒ©a function</h3>
<p>Function c√≥ t√™n ph·∫£i ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a trong module.
Function s·∫Ω tr·∫£ v·ªÅ gi√° tr·ªã cu·ªëi c√πng n√≥ t√≠nh ƒë∆∞·ª£c - kh√¥ng c√≥ c√¢u l·ªánh "return".
ƒêo·∫°n code sau ƒë·ªãnh nghƒ©a module <code>Math</code> v√† function <code>sum</code> tr·∫£ v·ªÅ t·ªïng c·ªßa 2 argument a, b:</p>
<pre><code>defmodule Math do
  def sum(a, b) do
    a + b
  end
end
</code></pre>

<p>ho·∫∑c</p>
<pre><code>defmodule Hacker, do: def hack(x), do: x*2
</code></pre>

<p>khi ch·ªâ c√≥ 1 function v√† function ch·ªâ c√≥ 1 d√≤ng.</p>
<p><code>defmodule</code> v√† <code>def</code> ƒë·ªÅu l√† c√°c macro.</p>
<h3 id="private-function">Private function</h3>
<p>ƒê·ªãnh nghƒ©a b·∫±ng macro <code>defp/2</code>, t·ª´ module kh√°c kh√¥ng th·ªÉ ch·∫°y c√°c function n√†y.</p>
<h3 id="ky-hieu-notation">K√Ω hi·ªáu (notation)</h3>
<p>Khi nh·∫Øc t·ªõi function, trong Elixir d√πng k√Ω hi·ªáu:
<code>name/arity</code> v·ªõi name l√† t√™n , v√† arity l√† s·ªë argument function ƒë√≥ nh·∫≠n.</p>
<p>Math.sum ·ªü tr√™n k√Ω hi·ªáu l√† <code>Math.sum/2</code></p>
<h3 id="multiple-clause-function">Multiple clause function</h3>
<p>M·ªôt function c√≥ th·ªÉ c√≥ nhi·ªÅu <code>clause</code>:</p>
<p>M·ªói "clause" th∆∞·ªùng ƒëi k√®m m·ªôt "guard", n·∫øu argument pass v√†o match v·ªõi argument c·ªßa clause v√† guard ƒëi k√®m tr·∫£ v·ªÅ <code>true</code>, clause ƒë√≥ s·∫Ω ƒë∆∞·ª£c g·ªçi.</p>
<pre><code>defmodule Foo do
  def rprint(msg, n) when n &lt;= 1 do
    IO.puts msg
  end

  def rprint(msg, n) do
    IO.puts msg
    rprint(msg, n - 1)
  end
end

Foo.rprint(&quot;Hello&quot;, 5)
</code></pre>

<h3 id="function-capturing">Function capturing</h3>
<h4 id="todo">TODO</h4>
<h3 id="default-argument">Default argument</h3>
<pre><code>def join(a, b, sep \\ &quot;,&quot;) do
  a &lt;&gt; sep &lt;&gt; b
end
</code></pre>

<p>"," l√† default argument, khi g·ªçi funtion m√† kh√¥ng pass gi√° tr·ªã cho argument <code>sep</code>, <code>sep</code> s·∫Ω s·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh ",".</p>
<h3 id="cac-phan-cua-mot-function">C√°c ph·∫ßn c·ªßa m·ªôt function</h3>
<pre><code>def sum(a, b) do
  a + b
end
</code></pre>

<ul>
<li>Function head: <code>def sum(a, b)</code></li>
<li>Function body: t·ª´ <code>do</code> ƒë·∫øn <code>end</code></li>
</ul>
<p>Khi function v·ªõi default value c√≥ nhi·ªÅu m·ªánh ƒë·ªÅ, ph·∫£i khai b√°o m·ªôt function head ƒë·ªÉ khai b√°o gi√° tr·ªã default.</p>
<h4 id="todo-more-detail">TODO more detail</h4>
<h2 id="module">Module</h2>
<h3 id="compile">Compile</h3>
<p>C√≥ th·ªÉ vi·∫øt module v√†o file <code>NAME.ex</code>: <code>math.ex</code>.</p>
<p>Compile module:</p>
<pre><code>$ elixirc math.ex  # t·∫°o ra file Elixir.Math.beam
</code></pre>

<p>B·∫≠t <code>iex</code> c√πng th∆∞ m·ª•c s·∫Ω t·ª± ƒë·ªông load module, ch·ªâ vi·ªác g·ªçi.</p>
<h3 id="script">Script</h3>
<p>L∆∞u file v·ªõi ƒëu√¥i .exs, Elixir s·∫Ω hi·ªÉu ƒë√≥ l√† 1 "script" v√† s·∫Ω kh√¥ng t·∫°o file c√≥ ƒëu√¥i .beam n·ªØa, ch·∫°y n√≥ nh∆∞ ch·∫°y c√°c script kh√°c (Python, bash...):</p>
<pre><code>$ elixir math.exs
</code></pre>

<h2 id="loop-bang-recursion-reduce-va-map">Loop b·∫±ng recursion, reduce v√† map</h2>
<p>Trong Elixir, m·ªçi th·ª© ƒë·ªÅu l√† "immutable" (kh√¥ng thay ƒë·ªïi ƒë∆∞·ª£c), v√¨ v·∫≠y nh·ªØng kh√°i ni·ªám ƒë·ªÉ l·∫∑p nh∆∞ trong c√°c ng√¥n ng·ªØ C, Python, Java, PHP, Golang ... s·∫Ω kh√¥ng ƒë∆∞·ª£c ·ª©ng d·ª•ng:</p>
<pre><code>for i in 'Elixir':
    print(i)
</code></pre>

<p>·ªû v√≤ng l·∫∑p for n√†y, gi√° tr·ªã c·ªßa i l·∫ßn l∆∞·ª£t thay ƒë·ªïi th√†nh c√°c k√Ω t·ª± trong "Elixir" -&gt; kh√¥ng ƒë·∫£m b·∫£o ƒë∆∞·ª£c t√≠nh immutable c·ªßa Elixir.</p>
<pre><code>i = 0
while True:
    print(i)
    i = i + 1
</code></pre>

<p>T∆∞∆°ng t·ª±, trong v√≤ng l·∫∑p while n√†y i c≈©ng thay ƒë·ªïi sau m·ªói v√≤ng l·∫∑p, kh√¥ng ƒë·∫£m b·∫£o t√≠nh immutable.</p>
<p>Elixir hay c√°c ng√¥n ng·ªØ l·∫≠p tr√¨nh h√†m (functional programming language) kh√°c s·ª≠ d·ª•ng recursive function ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng/ k·∫øt qu·∫£ nh∆∞ loop.</p>
<h3 id="recursive-function">Recursive function</h3>
<p>L√† function m√† b√™n trong ph·∫ßn body, n√≥ t·ª± g·ªçi ƒë·∫øn ch√≠nh n√≥ cho ƒë·∫øn khi g·∫∑p m·ªôt ƒëi·ªÅu ki·ªán ƒë·ªÉ d·ª´ng l·∫°i. S·∫Ω kh√¥ng c√≥ g√¨ b·ªã thay ƒë·ªïi khi d√πng recursive function, b·ªüi ta s·∫Ω sinh ra gi√° tr·ªã m·ªõi, ch·ª© kh√¥ng thay ƒë·ªïi gi√° tr·ªã c≈©. M·ªçi kh√°i ni·ªám s·∫Ω r√µ r√†ng khi th·ª≠ v·ªõi function t√≠nh giai th·ª´a c·ªßa 1 s·ªë:</p>
<p>Giai th·ª´a c·ªßa m·ªôt s·ªë nguy√™n kh√¥ng √¢m ƒë∆∞·ª£c t√≠nh b·∫±ng t√≠ch c·ªßa s·ªë ƒë√≥ nh√¢n v·ªõi giai th·ª≠a c·ªßa s·ªë nh·ªè h∆°n n√≥ 1 ƒë∆°n v·ªã. Hay vi·∫øt ·ªü d·∫°ng c√¥ng th·ª©c to√°n:
factorial(n) = n * factorial(n - 1)
khi n = 0 th√¨ factorial(0) = 1. # ƒëi·ªÅu ki·ªán d·ª´ng</p>
<p>Th·ª≠ t√≠nh factorial c·ªßa 3:</p>
<p>factorial(3) = 3 * factorial(2)
factorial(2) = 2 * factorial(1)
factorial(1) = 1 * factorial(0)
factorial(0) = 1</p>
<p>Sau khi ƒë√£ ch·∫°m ƒë·∫øn ƒëi·ªÅu ki·ªán d·ª±ng, ta l·∫•y k·∫øt qu·∫£ thu ƒë∆∞·ª£c thay ng∆∞·ª£c l√™n tr√™n.
factorial(1) = 1 * factorial(0) = 1 * 1 = 1
factorial(2) = 2 * factorial(1) = 2 * 1 = 2
factorial(3) = 3 * factorial(2) = 3 * 2 = 6</p>
<p>K·∫øt qu·∫£ l√† factorial(3) b·∫±ng 6.</p>
<pre><code>defmodule Rescusion do
  def fact(n) when n &lt;= 0 do
    1
  end

  def fact(n) do
    n * fact(n - 1)
  end
end
</code></pre>

<p>Trong b√†i n√†y, code c·ªßa Elixir ch·ªâ ƒë∆°n gi·∫£n l√† chuy·ªÉn c√¥ng th·ª©c to√°n h·ªçc th√†nh code.</p>
<h3 id="map_1">Map</h3>
<p>M·ªôt vi·ªác l√†m th∆∞·ªùng xuy√™n khi s·ª≠ d·ª•ng loop l√† ƒë·ªÉ bi·∫øn 1 t·∫≠p gi√° tr·ªã, th√†nh 1 t·∫≠p gi√° tr·ªã kh√°c.</p>
<p>V√≠ d·ª•, cho m·ªôt list <code>L = [1, 2, 3 ,4]</code>, c·∫ßn thu ƒë∆∞·ª£c k·∫øt qu·∫£ l√† m·ªôt list m√† ph·∫ßn t·ª≠ c·ªßa n√≥ l√† m·ªói ph·∫ßn t·ª≠ c·ªßa <code>L</code> nh√¢n v·ªõi 2.</p>
<p>Vi·ªác bi·∫øn m·ªôt t·∫≠p th√†nh m·ªôt t·∫≠p kh√°c b·∫±ng c√°ch g·ªçi function v·ªõi m·ªói ph·∫ßn t·ª≠ c·ªßa t·∫≠p g·ªçi l√† "mapping" (√°nh x·∫° trong to√°n h·ªçc).
Ta "map" m·ªôt ph·∫ßn t·ª≠ t·ª´ t·∫≠p ban ƒë·∫ßu th√†nh ph·∫ßn t·ª≠ trong t·∫≠p m·ªõi.</p>
<p>Vi·∫øt function ƒë·ªÉ map list n√≥i tr√™n:</p>
<pre><code>iex(41)&gt; defmodule Double do
...(41)&gt;   def double_each([head | tail]) do
...(41)&gt;     [head * 2 | double_each(tail)]
...(41)&gt;   end
...(41)&gt;
...(41)&gt;   def double_each([]) do
...(41)&gt;     []
...(41)&gt;   end
...(41)&gt; end
{:module, Double,
...
iex(42)&gt; Double.double_each([1,2,3,4])
[2, 4, 6, 8]
</code></pre>

<p>C√≥ th·ªÉ d√πng function c√≥ s·∫µn <code>Enum.map/2</code> ƒë·ªÉ th·ª±c hi·ªán mapping:</p>
<pre><code>iex(45)&gt; Enum.map([1,2,3,4], fn(x) -&gt; x * 2 end)
[2, 4, 6, 8]
</code></pre>

<h3 id="reduce">Reduce</h3>
<p>M·ªôt ·ª©ng d·ª•ng kh√°c th∆∞·ªùng d√πng khi l·∫∑p l√† ƒë·ªÉ t√≠nh m·ªôt gi√° tr·ªã n√†o ƒë√≥ s·∫Ω thu ƒë∆∞·ª£c sau khi duy·ªát qua t·∫•t c·∫£ gi√° tr·ªã trong t·∫≠p, nh∆∞ t√≠nh t·ªïng, t√≠ch c·ªßa t·∫≠p.</p>
<p>·ªû ƒë√¢y ta bi·∫øn t·ª´ 1 t·∫≠p nhi·ªÅu ph·∫ßn t·ª≠ th√†nh 1 gi√° tr·ªã cu·ªëi c√πng. Vi·ªác "thu g·ªçn" n√†y c√≥ t√™n l√† "reducing".</p>
<p>Map v√† reduce l√† 2 thu·∫≠t to√°n c·ªët l√µi c·ªßa "big data".</p>
<pre><code>iex(46)&gt; defmodule Reduce do
...(46)&gt;   def sum_list([head | tail], accumulator) do
...(46)&gt;     sum_list(tail, head + accumulator)
...(46)&gt;   end
...(46)&gt;
...(46)&gt;   def sum_list([], accumulator) do
...(46)&gt;     accumulator
...(46)&gt;   end
...(46)&gt; end

iex(47)&gt; Reduce.sum_list([1,2,3], 0)
6
</code></pre>

<p>Hay d√πng module c√≥ s·∫µn <code>Enum.reduce/2</code>:</p>
<pre><code>iex(48)&gt; Enum.reduce([1,2,3], 0, fn(x, acc) -&gt; x + acc end)
6
</code></pre>

<h2 id="io-xu-ly-du-lieu-vao-ra">IO - x·ª≠ l√Ω d·ªØ li·ªáu v√†o ra.</h2>
<h3 id="in-ra-man-hinh">In ra m√†n h√¨nh</h3>
<p>M·∫∑c d√π h·∫ßu h·∫øt c√°c s√°ch d·∫°y l·∫≠p tr√¨nh / tr∆∞·ªùng h·ªçc s·∫Ω lu√¥n b·∫Øt ƒë·∫ßu b·∫±ng vi·ªác d·∫°y "print" ra m√†n h√¨nh (v√† ƒëi k√®m l√† ƒë·ªçc nh·ªØng g√¨ ng∆∞·ªùi d√πng nh·∫≠p v√†o), nh∆∞ng tr√™n th·ª±c t·∫ø, c√≥ kho·∫£ng &lt; 5% ng∆∞·ªùi th·ª±c s·ª± d√πng print trong ch∆∞∆°ng tr√¨nh c·ªßa m√¨nh.</p>
<p>H√£y th·ª≠ nghƒ© v·ªõi ng∆∞·ªùi d√πng Windows, c√≥ bao gi·ªù b·∫°n b·∫≠t <code>cmd</code> l√™n v√† g√µ l·ªánh? C√°c ch∆∞∆°ng tr√¨nh ƒë·ªÅu giao ti·∫øp v·ªõi ng∆∞·ªùi d√πng qua giao di·ªán ƒë·ªì ho·∫° / web, ch·ª© kh√¥ng ph·∫£i c√°c d√≤ng l·ªánh. Nh·ªØng ng∆∞·ªùi l√†m vi·ªác v·ªõi d√≤ng l·ªánh ch·ªß y·∫øu l√† c√°c Linux Sysadmin / l·∫≠p tr√¨nh vi√™n / hacker.
N·∫øu b·∫°n l√† m·ªôt web developer, b·∫°n ƒë∆∞a n·ªôi dung ra trang web ch·ª© kh√¥ng print n√≥.</p>
<p>Elixir s·ª≠ d·ª•ng module <code>IO</code> cho c√°c thao t√°c n√†y:</p>
<pre><code>iex(49)&gt; IO.puts &quot;Hello&quot;
Hello
:ok
iex(50)&gt; IO.puts &quot;Hello FAMILUG&quot;
Hello FAMILUG
:ok
iex(51)&gt; answer = IO.gets(&quot;yes or no? &quot;)
yes or no? yes
&quot;yes\n&quot;
iex(52)&gt; IO.puts(answer)
yes

:ok
</code></pre>

<p>C√≥ th·ªÉ ghi ra stderr:</p>
<pre><code>iex(53)&gt; IO.puts(:stderr, &quot;Hello standard error&quot;)
Hello standard error
:ok
</code></pre>

<p>ƒê·ªÉ kh√¥ng th√™m k√Ω t·ª± newline (<code>\n</code>) sau m·ªói d√≤ng, s·ª≠ d·ª•ng <code>IO.write</code> thay
v√¨ <code>IO.puts</code>.</p>
<p><code>puts</code> ch·ªâ nh·∫≠n argument l√† string, mu·ªën "in ra" m·ªôt list, tuple hay object b·∫•t
k·ª≥, h√£y d√πng <code>IO.inspect</code>.</p>
<p>Khi d√πng <code>IO.inspect</code> in ra list c√≥ nhi·ªÅu ph·∫ßn t·ª≠ (&gt;50), Elixir s·∫Ω ch·ªâ in ra 50
ph·∫ßn t·ª≠ ƒë·∫ßu v√† ghi ... ƒë·ªÉ k√Ω hi·ªáu c√≤n ti·∫øp. Mu·ªën hi·ªán ƒë·∫ßy ƒë·ªß, c√≥ th·ªÉ g·ªçi th√™m
argument:</p>
<pre><code>iex(9)&gt; IO.inspect(1..100|&gt;Enum.map(fn x -&gt; x*2 end))

[2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, ...]

iex(10)&gt; IO.inspect(1..100|&gt;Enum.map(fn x -&gt; x*2 end), limit: :infinity)
[2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82,
 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116,
 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148,
 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180,
 182, 184, 186, 188, 190, 192, 194, 196, 198, 200]

</code></pre>

<h3 id="oc-ghi-file">ƒê·ªçc ghi file</h3>
<p>Module <code>File</code> ch·ª©a c√°c function ƒë·ªÉ t∆∞∆°ng t√°c v·ªõi file, t·ª´ ƒë·ªçc, ghi, xo√°, copy...</p>
<pre><code>iex(53)&gt; IO.puts(:stderr, &quot;Hello standard error&quot;)
Hello standard error
:ok
iex(54)&gt; {:ok, file} = File.open(&quot;hellofile.txt&quot;, [:write])
{:ok, #PID&lt;0.260.0&gt;}
iex(55)&gt; IO.binwrite(file, &quot;Hello world!&quot;)
:ok
iex(56)&gt; File.close(file)
:ok
iex(57)&gt; File.read(&quot;hellofile.txt&quot;)
{:ok, &quot;Hello world!&quot;}
</code></pre>

<p>C√°c function x·ª≠ l√Ω file:</p>
<p><code>File.rm/1</code>, <code>File.mkdir/1</code>, <code>File.cp_r/2</code>, ...</p>
<h2 id="xu-ly-loi">X·ª≠ l√Ω l·ªói</h2>
<h3 id="errror-hay-exception">Errror (hay exception)</h3>
<pre><code>iex(58)&gt; &quot;abc&quot; + 1
** (ArithmeticError) bad argument in arithmetic expression
    :erlang.+(&quot;abc&quot;, 1)
iex(58)&gt; raise &quot;oizoioi&quot;
** (RuntimeError) oizoioi

iex(58)&gt; raise ArgumentError, message: &quot;invalid argument&quot;
** (ArgumentError) invalid argument

</code></pre>

<h3 id="tryrescuecatchafter">try/rescue/catch/after</h3>
<p>T∆∞∆°ng t·ª± nh∆∞ try/except trong Python hay try/catch trong Java, Elixir c√≥ try/recuse v√† try/catch, nh∆∞ng trong Elixir, s·ª≠ d·ª•ng ch√∫ng l√† ƒëi·ªÅu kh√¥ng n√™n / hi·∫øm khi d√πng.</p>
<pre><code>iex(61)&gt; try do
...(61)&gt;   r = 1/0
...(61)&gt; rescue
...(61)&gt;   ArithmeticError -&gt; &quot;Error&quot;
...(61)&gt; end
&quot;Error&quot;
</code></pre>

<p>V·∫≠y Elixir l√†m g√¨ khi g·∫∑p l·ªói? c√≥ "exception" th√¨ x·ª≠ l√Ω th·∫ø n√†o?
Trong tri·∫øt l√Ω c·ªßa Erlang/Elixir, "l·ªói" l√† m·ªôt ph·∫ßn c·ªßa ch∆∞∆°ng tr√¨nh, v√† h·ªá th·ªëng n·∫±m d∆∞·ªõi ng√¥n ng·ªØ (BEAM/OTP) s·∫Ω x·ª≠ l√Ω ch√∫ng m·ªôt c√°ch ngon l√†nh. T·∫°m th·ªùi b·ªè qua ·ªü ƒë√¢y.</p>
<h2 id="bat-au-code-mot-project">B·∫Øt ƒë·∫ßu code m·ªôt project</h2>
<p>ƒê·∫øn ƒë√¢y ƒë√£ ƒë·ªß c√°c c√¥ng c·ª• c∆° b·∫£n ƒë·ªÉ vi·∫øt nh·ªØng ch∆∞∆°ng tr√¨nh b√¨nh th∆∞·ªùng / luy·ªán t·∫≠p v·ªõi c√°c thu·∫≠t to√°n ... cho ƒë·∫øn khi quen v·ªõi ng√¥n ng·ªØ.
Elixir c√≤n nhi·ªÅu kh√°i ni·ªám kh√°c, ƒë·∫∑c bi·ªát ƒë∆∞·ª£c ƒë∆∞a ra ƒë·ªÉ x·ª≠ l√Ω trong m√¥i tr∆∞·ªùng "ph√¢n t√°n", nh∆∞ng t·∫≠p trung v√†o nh·ªØng t√≠nh nƒÉng ƒë√≥ ngay b√¢y gi·ªù ch·ªâ l√†m cho ng∆∞·ªùi h·ªçc b·ªã qu√° t·∫£i v·ªõi nh·ªØng kh√°i ni·ªám m·ªõi l·∫°, trong khi v·∫´n ch∆∞a n·∫Øm r√µ ph·∫ßn c∆° b·∫£n. V·∫≠y n√™n, c√°c kh√°i ni·ªám "kh√°c" ƒë√≥ s·∫Ω ƒë∆∞·ª£c d√†nh cho ph·∫ßn sau. C√≤n b√¢y gi·ªù, t·∫°o m·ªôt project Elixir v√† code:</p>
<p><code>Mix</code> l√† "build tool" c·ªßa Elixir, ƒë·ªÉ t·∫°o m·ªôt project m·ªõi, d√πng c√¢u l·ªánh:</p>
<pre><code> mix new hello_familug
* creating README.md
* creating .gitignore
* creating mix.exs
* creating config
* creating config/config.exs
* creating lib
* creating lib/hello_familug.ex
* creating test
* creating test/test_helper.exs
* creating test/hello_familug_test.exs

Your Mix project was created successfully.
You can use &quot;mix&quot; to compile it, test it, and more:

    cd hello_familug
    mix test

Run &quot;mix help&quot; for more commands.
</code></pre>

<p>S·ª≠a n·ªôi dung file <code>lib/hello_familug.ex</code> nh∆∞ sau:</p>
<pre><code>defmodule HelloFamilug do
  def main(args) do
    IO.puts &quot;Hello FAMILUG!&quot;
  end
end
</code></pre>

<p>Th√™m d√≤ng:</p>
<pre><code>      escript: escript,
</code></pre>

<p>v√†o sau d√≤ng</p>
<pre><code>      elixir: &quot;~&gt; VERSION&quot;,
</code></pre>

<p>trong mix.exs.</p>
<p>Th√™m function sau v√†o trong file <code>mix.exs</code></p>
<pre><code>  def escript do
    [main_module: HelloFamilug]  # t√™n module s·∫Ω ƒë∆∞·ª£c ch·∫°y
  end
</code></pre>

<p>Compile v√† ch·∫°y:</p>
<pre><code>$ mix escript.build
Compiling 1 file (.ex)
warning: variable args is unused
  lib/hello_familug.ex:2

Generated hello_familug app
Generated escript hello_familug with MIX_ENV=dev
$ ./hello_familug
Hello FAMILUG!
</code></pre>

<p>S·ª≠a l·∫°i code ƒë·ªÉ nh·∫≠n v√†o input t·ª´ ng∆∞·ªùi d√πng:</p>
<pre><code>defmodule HelloFamilug do
  def main(args) do
    {_, [name], _} = OptionParser.parse(args)
    IO.puts &quot;Hello &quot; &lt;&gt; name
  end
end
</code></pre>

<p>T·∫°m th·ªùi b·ªè qua chi ti·∫øt OptionParser.parse/1 l√†m g√¨,
build l·∫°i v√† g·ªçi v·ªõi m·ªôt c√°i t√™n:</p>
<pre><code>$ mix escript.build
Compiling 1 file (.ex)
Generated escript hello_familug with MIX_ENV=dev
$ ./hello_familug Python
Hello Python
</code></pre>

<p>Ch∆∞∆°ng tr√¨nh d√≤ng l·ªánh (CLI tool) kh√¥ng ph·∫£i l√† th·∫ø m·∫°nh c·ªßa Elixir, nh∆∞ng n√≥ ho√†n to√†n c√≥ th·ªÉ l√†m ƒë∆∞·ª£c v√† kh√¥ng h·ªÅ ph·ª©c t·∫°p. V·ªõi t·ª´ng ·∫•y ƒë·ªß ƒë·ªÉ ta b·∫Øt ƒë·∫ßu cu·ªôc h√†nh tr√¨nh v√†o nh·ªØng gi·∫•c m∆° s√¢u v√¥ t·∫≠n trong th·∫ø gi·ªõi c·ªßa nh√† gi·∫£ kim v√† Elixir (thu·ªëc ti√™n).</p>
<h2 id="faqs">FAQs</h2>
<h3 id="tai-sao-ten-lai-nham-nhi-vay-hoc-elixir-trong-mot-giac-mo">T·∫°i sao t√™n l·∫°i nh·∫£m nh√≠ v·∫≠y "h·ªçc Elixir trong m·ªôt gi·∫•c m∆°"?</h3>
<p>V√¨ vi·ªác ƒë·ªçc ti·∫øng Anh ·ªü Vi·ªát Nam r·∫•t "th·∫£m ho·∫°".
Ch·ªØ "Python" - r√µ r√†ng ƒë·ªçc l√† "pai-thon" th√¨ ph·∫ßn l·ªõn l·∫≠p tr√¨nh vi√™n l·∫°i ƒë·ªçc l√† "Pi-th√¥ng". V·∫≠y n√™n t√¥i ƒë·∫∑t t√™n c√≥ v·∫ßn ƒë·ªÉ ng∆∞·ªùi h·ªçc c√≥ th·ªÉ ƒë·ªçc ƒë√∫ng "H·ªçc <code>i l√≠k s∆°</code> trong m·ªôt gi·∫•c m∆°".</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>var base_url = '.';</script>
        <script data-main="./mkdocs/js/search.js" src="./mkdocs/js/require.js"></script>
        <script src="./js/base.js"></script><div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>

<!--
MkDocs version : 0.16.3
Build Date UTC : 2017-08-09 14:40:38
-->
