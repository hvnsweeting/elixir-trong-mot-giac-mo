{
    "docs": [
        {
            "location": "/",
            "text": "H\u1ecdc Elixir trong m\u1ed9t gi\u1ea5c m\u01a1\n\n\n[BETA]\n\n\nL\u00fd do b\u1ea1n th\u00edch h\u1ecdc Haskell, LISP, Erlang, Elixir, Ocaml, Scala... nh\u1eefng ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh h\u00e0m (functional programming language) c\u00f3 v\u1ebb hay ho, m\u00e0 kh\u00f4ng bao gi\u1edd th\u00e0nh c\u00f4ng l\u00e0 g\u00ec?\n\n\nSau \u0111\u00e2y l\u00e0 v\u00e0i l\u00fd do m\u00ecnh g\u1eb7p ph\u1ea3i:\n\n\n\n\nQu\u00e1 nhi\u1ec1u kh\u00e1i ni\u1ec7m m\u1edbi\n\n\nNh\u1ed3i nh\u00e9t h\u1ebft c\u00e1c kh\u00e1i ni\u1ec7m xong kh\u00f4ng c\u00f3 g\u00ec \u0111\u1ec3 l\u00e0m\n\n\nCh\u1ecdn ng\u00f4n ng\u1eef \"x\u1ecbn\" nh\u1ea5t: trong m\u1ea3nh \u0111\u1ea5t functional programming, r\u1ea5t nhi\u1ec1u c\u00e1i t\u00ean h\u1ea5p d\u1eabn kh\u00e1c nh\u01b0 Haskell, Ocaml, Racket, Scheme, CLisp, Scala,...\n\n\n\n\n\u0110\u1ec3 kh\u1eafc ph\u1ee5c \u0111i\u1ec1u n\u00e0y, ta s\u1ebd:\n\n\n\n\nCh\u1ec9 t\u1eadp trung v\u00e0o nh\u1eefng kh\u00e1i ni\u1ec7m \u0111\u00e3 quen thu\u1ed9c, h\u1ecdc th\u1eadt nhanh, tra c\u1ee9u khi c\u1ea7n\n\n\nC\u00f3 m\u1ed9t \u00fd t\u01b0\u1edfng \u0111\u1ec3 th\u1ef1c hi\u1ec7n\n\n\nT\u1eadp trung v\u00e0o Elixir v\u00ec m\u1ed7i ng\u00f4n ng\u1eef \u0111\u1ec1u c\u00f3 \u0111i\u1ec3m m\u1ea1nh/ y\u1ebfu ri\u00eang, nh\u01b0ng khi n\u1eafm \u0111\u01b0\u1ee3c m\u1ed9t ng\u00f4n ng\u1eef, h\u1ecdc c\u00e1c ng\u00f4n ng\u1eef kh\u00e1c s\u1ebd tr\u1edf n\u00ean d\u1ec5 d\u00e0ng h\u01a1n nhi\u1ec1u do \u0111\u00e3 quen thu\u1ed9c c\u00e1c kh\u00e1i  ni\u1ec7m v\u00e0 l\u1ed1i t\u01b0 duy c\u1ee7a functional programming.\n\n\n\n\nN\u1ebfu kh\u00f4ng c\u00f3 g\u00ec \u0111\u1ec3 l\u00e0m, nu\u1ed1t xong c\u00e1c kh\u00e1i ni\u1ec7m, 1 tu\u1ea7n sau b\u1ea1n s\u1ebd l\u1ea1i qu\u00ean.\n\n\nElixir/Erlang ho\u00e0n to\u00e0n \u0111\u1ee7 kh\u1ea3 n\u0103ng \u0111\u1ec3 cho b\u1ea1n l\u1eadp tr\u00ecnh loanh quanh m\u1ea5y thu\u1eadt to\u00e1n, gi\u1ea3i c\u00e1c b\u00e0i to\u00e1n / v\u1ea5n \u0111\u1ec1 tr\u00ean HackerRank. Nh\u01b0ng \u0111i\u1ec3m s\u00e1ng c\u1ee7a ng\u00f4n ng\u1eef n\u00e0y, th\u1ef1c ra ch\u1ec9 to\u1ea3 s\u00e1ng khi ta d\u00f9ng n\u00f3 \u0111\u1ec3 ph\u00e1t tri\u1ec3n c\u00e1c h\u1ec7 th\u1ed1ng l\u1edbn, c\u1ea7n ch\u1ea1y ph\u00e2n t\u00e1n, hay ch\u1ea1y song song... \u00cdt khi m\u1ed9t ng\u01b0\u1eddi s\u1ebd l\u00e0m h\u1eb3n m\u1ed9t project l\u1edbn nh\u01b0 v\u1eady. V\u00ec v\u1eady, ta th\u01b0\u1eddng kh\u00f4ng c\u00f3 \u0111\u1ea5t d\u00f9ng cho Elixir hay Erlang.\n\n\nM\u1ed9t c\u00e1ch \u1ee9ng d\u1ee5ng \u0111\u1ec3 ch\u01a1i v\u1edbi ng\u00f4n ng\u1eef m\u1edbi n\u1eefa \"nh\u1ecf h\u01a1n\", l\u00e0 vi\u1ebft c\u00e1c c\u00e2u l\u1ec7nh th\u1ef1c hi\u1ec7n m\u1ed9t vi\u1ec7c g\u00ec \u0111\u00f3 (CLI). V\u1eady nh\u01b0ng Elixir/Erlang kh\u00f4ng to\u1ea3 s\u00e1ng/ \u0111\u01a1n gi\u1ea3n trong c\u00f4ng vi\u1ec7c n\u00e0y, n\u00f3 C\u00d3 TH\u1ec2 l\u00e0m \u0111\u01b0\u1ee3c, nh\u01b0ng tr\u00ean th\u1ef1c t\u1ebf kh\u00f4ng m\u1ea5y ai l\u00e0m.\n\n\nV\u00ed d\u1ee5 standard khi h\u1ecdc Erlang l\u00e0 l\u00e0m m\u1ed9t h\u1ec7 th\u1ed1ng chat. Tr\u00ean th\u1ef1c t\u1ebf, h\u1ec7 th\u1ed1ng chat c\u1ee7a \"Whatsapp\" \u0111\u01b0\u1ee3c vi\u1ebft b\u1eb1ng Erlang \nh\u1ec7 th\u1ed1ng n\u00e0y \u0111\u00e3 \u0111\u01b0\u1ee3c b\u00e1n l\u1ea1i cho FaceBook v\u1edbi gi\u00e1 19 T\u1ef6 \u0111\u00f4 la M\u1ef9\n (PS: FaceBook tr\u01b0\u1edbc \u0111\u00f3 c\u0169ng \u0111\u00e3 mua l\u1ea1i Instagram - m\u1ed9t h\u1ec7 th\u1ed1ng vi\u1ebft b\u1eb1ng Django/Python v\u1edbi gi\u00e1 1 T\u1ef6 \u0111\u00f4 la M\u1ef9)\n\n\nTa c\u00f3 th\u1ec3 l\u00e0m 1 website sau khi h\u1ecdc Elixir, \u0111\u00e2y l\u00e0 l\u0129nh v\u1ef1c hi\u1ec7n t\u1ea1i m\u00e0 Elixir m\u1ea1nh nh\u1ea5t.\n\n\n\u0110\u00e3 xong ph\u1ea7n \u00fd t\u01b0\u1edfng, b\u00e2y gi\u1edd h\u00e3y h\u1ecdc Elixir.\n\n\nTh\u1ef1c hi\u1ec7n tr\u00ean:\n\n\n$ elixir --version\nErlang/OTP 19 [erts-8.0.2] [source] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]\n\nElixir 1.3.2\n\n\n\n\nPS: trong b\u00e0i c\u00f3 m\u1ed9t s\u1ed1 \u0111o\u1ea1n so s\u00e1nh v\u1edbi t\u00ednh n\u0103ng t\u01b0\u01a1ng t\u1ef1 tr\u00ean Python - b\u1edfi t\u00e1c gi\u1ea3 l\u00e0 ng\u01b0\u1eddi c\u00f3 kinh nghi\u1ec7m v\u1edbi Python - gi\u00fap c\u00e1c l\u1eadp tr\u00ecnh vi\u00ean Python d\u1ec5 k\u1ebft n\u1ed1i c\u00e1c kh\u00e1i ni\u1ec7m. Ph\u1ea7n so s\u00e1nh n\u00e0y ho\u00e0n to\u00e0n kh\u00f4ng c\u1ea7n thi\u1ebft v\u1edbi ng\u01b0\u1eddi kh\u00f4ng bi\u1ebft Python v\u00e0 c\u00f3 th\u1ec3 b\u1ecf qua.\n\n\nC\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n\n\n\nInteger\n\n\niex(33)> 42\n42\niex(34)> i 42\nTerm\n  42\nData type\n  Integer\nReference modules\n  Integer\n\nD\u00f9ng ``i OBJECT`` \u0111\u1ec3 hi\u1ec3n th\u1ecb th\u00f4ng tin v\u1ec1 gi\u00e1 tr\u1ecb/ ki\u1ec3u c\u1ee7a object. Nh\u01b0 \"type(object)\" trong Python hay \"typeof object\" trong JavaScript.\n\n\n\n\nFloat\n\n\niex(35)> i 3.14\nTerm\n  3.14\nData type\n  Float\nReference modules\n  Float\n\niex(36)> 0.1 + 0.1 + 0.1\n0.30000000000000004\n\n\n\n\nAtom\n\n\niex(39)> i true\nTerm\n  true\nData type\n  Atom\nReference modules\n  Atom\niex(40)> i false\nTerm\n  false\nData type\n  Atom\nReference modules\n  Atom\n\n\n\n\nString\n\n\niex(42)> i \"Elixir\"\nTerm\n  \"Elixir\"\nData type\n  BitString\nByte size\n  6\nDescription\n  This is a string: a UTF-8 encoded binary. It's printed surrounded by\n  \"double quotes\" because all UTF-8 encoded codepoints in it are printable.\nRaw representation\n  <<69, 108, 105, 120, 105, 114>>\nReference modules\n  String, :binary\n\n\n\n\nC\u00e1c ki\u1ec3u d\u1eef li\u1ec7u ch\u1ee9a \u0111\u01b0\u1ee3c ki\u1ec3u kh\u00e1c: list, tuple, dict\n\n\nList\n\n\niex(44)> i 'abc'\nTerm\n  'abc'\nData type\n  List\nDescription\n  This is a list of integers that is printed as a sequence of characters\n  delimited by single quotes because all the integers in it represent valid\n  ASCII characters. Conventionally, such lists of integers are referred to as\n  \"charlists\" (more precisely, a charlist is a list of Unicode codepoints,\n  and ASCII is a subset of Unicode).\nRaw representation\n  [97, 98, 99]\nReference modules\n  List\n\n\niex(45)> i [1,2,3,3.14]\nTerm\n  [1, 2, 3, 3.14]\nData type\n  List\nReference modules\n  List\n\niex(46)> i []\nTerm\n  []\nData type\n  List\nReference modules\n  List\n\n\n\n\nM\u1ed9t list c\u00f3 th\u1ec3 ch\u1ee9a b\u1ea5t k\u1ef3 ki\u1ec3u d\u1eef li\u1ec7u n\u00e0o:\n\n\niex(6)> i [\"abc\", 1]\nTerm\n  [\"abc\", 1]\nData type\n  List\nReference modules\n  List\n\n\n\n\nV\u1edbi list ch\u1ee9a c\u00e1c ph\u1ea7n t\u1eed tuple-2 {atom: value}, Elixir h\u1ed7 tr\u1ee3 th\u00eam c\u00fa ph\u00e1p ng\u1eafn g\u1ecdn \u0111\u1ec3 t\u1ea1o ra list n\u00e0y v\u00e0 g\u1ecdi l\u00e0 \"keyword list\" (b\u1ea3n ch\u1ea5t v\u1eabn l\u00e0 1 list b\u00ecnh th\u01b0\u1eddng):\n\n\niex(38)> [{:name, \"PyMi\"}, {:est, 2015}]\n[name: \"PyMi\", est: 2015]\niex(39)> [name: \"PyMi\", est: 2015]\n[name: \"PyMi\", est: 2015]\n\niex(38)> [{:name, \"PyMi\"}, {:est, 2015}]\n[name: \"PyMi\", est: 2015]\niex(39)> [name: \"PyMi\", est: 2015]\n[name: \"PyMi\", est: 2015]\n\n\n\n\nTuple\n\n\niex(48)> i {100, 'abc'}\nTerm\n  {100, 'abc'}\nData type\n  Tuple\nReference modules\n  Tuple\niex(49)> i {}\nTerm\n  {}\nData type\n  Tuple\nReference modules\n  Tuple\n\n\n\n\n\nKh\u00f4ng gi\u1ed1ng Python, trong Elixir, T\u1ea4T C\u1ea2 c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u \u0111\u1ec1u l\u00e0 immutable, t\u1ee9c m\u1ed9t khi \u0111\u00e3 t\u1ea1o ra, kh\u00f4ng th\u1ec3 thay \u0111\u1ed5i. Mu\u1ed1n \"thay \u0111\u1ed5i\", ta ph\u1ea3i t\u1ea1o m\u1edbi.\n\n\nTr\u00ean Python, nh\u1eefng \u0111i\u1ec1u sau \u0111\u1ec1u c\u00f3 th\u1ec3 l\u00e0m tr\u00ean list hay tuple:\n- duy\u1ec7t qua t\u1eebng ph\u1ea7n t\u1eed (loop)\n- truy c\u1eadp index\n- slice \u0111\u1ec3 thu \u0111\u01b0\u1ee3c m\u1ed9t t\u1eadp con\n\n\nS\u1ef1 gi\u1ed1ng nhau v\u1ec1 t\u00ednh n\u0103ng khi\u1ebfn ng\u01b0\u1eddi d\u00f9ng th\u01b0\u1eddng h\u1ecfi khi n\u00e0o d\u00f9ng list, khi n\u00e0o d\u00f9ng tuple.\nV\u1edbi Python, ta c\u00f3 th\u1ec3 thay \u0111\u1ed5i 1 list, nh\u01b0ng kh\u00f4ng th\u1ec3 thay \u0111\u1ed5i m\u1ed9t tuple sau khi \u0111\u00e3 t\u1ea1o ra n\u00f3.\nV\u1edbi Elixir, c\u1ea3 list v\u00e0 tuple \u0111\u1ec1u kh\u00f4ng th\u1ec3 thay \u0111\u1ed5i \u0111\u01b0\u1ee3c (immutable).\n\u0110\u1eb7c \u0111i\u1ec3m n\u00e0y s\u1ebd gi\u00fap th\u1ea5y r\u00f5 h\u01a1n khi n\u00e0o d\u00f9ng tuple v\u00e0 khi n\u00e0o n\u00ean d\u00f9ng list:\n- list TH\u01af\u1edcNG d\u00f9ng \u0111\u1ec3 ch\u1ee9a c\u00e1c d\u1eef li\u1ec7u t\u01b0\u01a1ng t\u1ef1 nhau (heterogenious)\n- tuple th\u01b0\u1eddng \u0111\u1ec3 ch\u1ee9a c\u00e1c th\u00f4ng tin li\u00ean quan \u0111\u1ebfn nhau, nh\u01b0 c\u00e1c c\u1ed9t trong 1 d\u00f2ng c\u1ee7a database, c\u00e1c to\u1ea1 \u0111\u1ed9 c\u1ee7a m\u1ed9t \u0111i\u1ec3m, c\u00e1c \u0111\u1eb7c t\u00ednh c\u1ee7a m\u1ed9t con m\u00e8o...\n\n\nKhi \u0111\u00f3, ta s\u1ebd th\u01b0\u1eddng loop qua 1 list, v\u00e0 th\u01b0\u1eddng truy c\u1eadp \u0111\u1ebfn c\u00e1c ph\u1ea7n t\u1eed c\u1ee7a tuple th\u00f4ng qua indexing/unpacking.\n\n\niex(52)> person = {\"HVN\", 27, \"Python\"}\n{\"HVN\", 27, \"Python\"}\niex(53)> {name, age, language} = person\n{\"HVN\", 27, \"Python\"}\niex(54)> name\n\"HVN\"\n\n\n\n\nhttp://elixir-lang.org/getting-started/basic-types.html#lists-or-tuples\nhttp://stackoverflow.com/questions/31192923/lists-vs-tuples-what-to-use-and-when\n\n\nMap (dictionary)\n\n\niex(51)> i %{\"name\": \"FAMILUG\"}\nTerm\n  %{name: \"FAMILUG\"}\nData type\n  Map\nReference modules\n  Map\n\n\n\n\nC\u00e1c thao t\u00e1c c\u01a1 b\u1ea3n v\u1edbi c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u\n\n\nThao t\u00e1c v\u1edbi String\n\n\n\n\nKi\u1ec3m tra string con:\n\n\n\n\niex(9)> String.contains?(\"Python\", \"on\")\ntrue\niex(10)> String.contains?(\"Python\", \"ON\")\nfalse\n\n\n\n\nCh\u00fa \u00fd t\u00ean function c\u00f3 d\u1ea5u ?\n\n\n\n\nKi\u1ec3m tra b\u1eaft \u0111\u1ea7u v\u00e0 k\u1ebft th\u00fac:\n\n\n\n\niex(11)> String.starts_with?(\"Python\", \"Py\")\ntrue\niex(12)> String\nString      StringIO\niex(12)> String.ends_with?(\"Python.mp3\", \".mp3\")\ntrue\n\n\n\n\nD\u1ec5 th\u1ea5y, nh\u1eefng function tr\u1ea3 v\u1ec1 true/false \u0111\u1ec1u \u0111\u01b0\u1ee3c \u0111\u1eb7t t\u00ean k\u1ebft th\u00fac b\u1eb1ng d\u1ea5u ?\n\n\n\n\n\n\nL\u1ea5y index #TODO\n\n\n\n\n\n\nN\u1ed1i c\u00e1c ph\u1ea7n t\u1eed c\u1ee7a list (KH\u00d4NG TH\u1ec2 N\u1ed0I TUPLE):\n\n\n\n\n\n\niex(55)> Enum.join([\"Python\", \"PyMi.vn\"], \" \")\n\"Python PyMi.vn\"\niex(57)> [\"Elixir\", \"PyMi.vn\"] |> Enum.join(\"+\")\n\"Elixir+PyMi.vn\"\niex(61)> \"H\u1ecdc Python\" <> \" \" <> \"t\u1ea1i PyMi.vn\"\n\"H\u1ecdc Python t\u1ea1i PyMi.vn\"\n\niex(7)> Enum.join {1, 2}\n** (Protocol.UndefinedError) protocol Enumerable not implemented for {1, 2}\n    (elixir) lib/enum.ex:1: Enumerable.impl_for!/1\n    (elixir) lib/enum.ex:116: Enumerable.reduce/3\n    (elixir) lib/enum.ex:1636: Enum.reduce/3\n    (elixir) lib/enum.ex:1154: Enum.join/2\niex(7)> Enum.join [1, 2]\n\"12\"\n\n\n\n\n\n\nC\u1eaft string, bi\u1ebfn th\u00e0nh list:\n\n\n\n\niex(63)> String.split(\"M\u00ecnh th\u00edch th\u00ec m\u00ecnh h\u1ecdc \\tth\u00f4i\", \" \")\n[\"M\u00ecnh\", \"th\u00edch\", \"th\u00ec\", \"m\u00ecnh\", \"h\u1ecdc\", \"\\tth\u00f4i\"]\niex(64)> String.split(\"M\u00ecnh th\u00edch th\u00ec m\u00ecnh     h\u1ecdc \\tth\u00f4i\")\n[\"M\u00ecnh\", \"th\u00edch\", \"th\u00ec\", \"m\u00ecnh\", \"h\u1ecdc\", \"th\u00f4i\"]\n\n\n\n\nGi\u1ed1ng nh\u01b0 Python.\n\n\nNh\u01b0ng Elixir c\u00f2n c\u00f3 th\u1ec3 Split t\u1ea1i nhi\u1ec1u \"separator\":\n\n\niex(7)> String.split(\"a-b+c\", [\"-\", \"+\"])\n[\"a\", \"b\", \"c\"]\n\n\n\n\n\n\ntrim/trim_leading/trim_trailing\n\n\n\n\niex(14)> String.trim(\"   a\\t abc\\n\")\n\"a\\t abc\"\niex(15)> String.trim_leading(\"   a\\t abc\\n\")\n\"a\\t abc\\n\"\niex(16)> String.trim_trailing(\"   a\\t abc\\n\")\n\"   a\\t abc\"\n\n\n\n\n\n\nreplace\n\n\n\n\niex(17)> String.replace(\"Python\", \"Py\", \"Jy\")\n\"Jython\"\n\n\n\n\n\n\nCh\u1eef hoa, ch\u1eef th\u01b0\u1eddng:\n\n\n\n\niex(18)> String.upcase(\"Python\")\n\"PYTHON\"\niex(19)> String.downcase(\"PYThon\")\n\"python\"\niex(20)> String.capitalize(\"python is an animal\")\n\"Python is an animal\"\n\n\n\n\n\n\nBi\u1ebfn th\u00e0nh ki\u1ec3u integer\n\n\n\n\niex(22)> String.to_integer(\"   42  \")\n** (ArgumentError) argument error\n    :erlang.binary_to_integer(\"   42  \")\niex(22)> String.to_integer(\"42\")\n42\n\n\n\n\n\nFunction n\u00e0y trong Elixir kh\u00f4ng c\u00f3 kh\u1ea3 n\u0103ng b\u1ecf \u0111i whitespace nh\u01b0 Python:\n\n\nIn [1]: int(\"   42 \\n\\t   \")\nOut[1]: 42\n\n\n\n\n\n\nL\u1ea5y \u0111\u1ed9 d\u00e0i\n\n\n\n\niex(59)>  String.length(\"L\u1ea1c tr\u00f4i\")\n8\niex(60)>  String.length(\"L\u1ea1c tr\u00f4i\ud83d\ude1d\")\n9\n\n\n\n\n\n\nSlice: slice(string, start, len)\n\n\n\n\niex(1)> String.slice(\"Python\", 0, 2)\n\"Py\"\niex(2)> String.slice(\"Python\", 2, 10)\n\"thon\"\n\n\n\n\n\n\n\u0110\u1ea3o ng\u01b0\u1ee3c:\n\n\n\n\niex(4)> String.reverse(\"DOICAN\")\n\"NACIOD\"\n\n\n\n\nhttps://hexdocs.pm/elixir/1.4.2/String.html#content\n\n\nList\n\n\nS\u1eed d\u1ee5ng module \nList\n. C\u00e1c function c\u00f3 s\u1eb5n c\u1ee7a module List kh\u00f4ng gi\u1ed1ng nh\u01b0 trong Python, b\u1edfi List trong Python c\u00f3 th\u1ec3 thay \u0111\u1ed5i \u0111\u01b0\u1ee3c (th\u00eam b\u1edbt, s\u1eeda ph\u1ea7n t\u1eed) c\u00f2n List trong Elixir th\u00ec kh\u00f4ng.\n\n\n\n\nT\u1ea1o list\n\n\n\n\niex(8)> li = [1, \"PyMi\", \"Python\", \"Elixir\"]\n[1, \"PyMi\", \"Python\", \"Elixir\"]\niex(10)> i li\nTerm\n  [1, \"PyMi\", \"Python\", \"Elixir\"]\nData type\n  List\nReference modules\n  List\n\n\n\n\n\n\nL\u1ea5y \u0111\u1ea7u (head)\n\n\n\n\niex(11)> hd li\n1\n\n\n\n\n\n\nL\u1ea5y \u0111u\u00f4i (tail)\n\n\n\n\niex(12)> tl li\n[\"PyMi\", \"Python\", \"Elixir\"]\n\n\n\n\n\n\nL\u1ea5y \u0111\u1ea7u v\u00e0 \u0111u\u00f4i:\n\n\n\n\niex(24)> [head | tail] = [\"Python\", \"PyMi\", \"Golang\", \"FAMILUG.org\"]\n[\"Python\", \"PyMi\", \"Golang\", \"FAMILUG.org\"]\niex(25)> head\n\"Python\"\niex(26)> tail\n[\"PyMi\", \"Golang\", \"FAMILUG.org\"]\n\n\n\n\n\n\nKi\u1ec3m tra s\u1ed1 ph\u1ea7n t\u1eed\n\n\n\n\niex(14)> length li\n4\n\n\n\n\n\n\nKi\u1ec3m tra m\u1ed9t ph\u1ea7n t\u1eed c\u00f3 trong list kh\u00f4ng\n\n\n\n\niex(5)> Enum.member?([1,2,4], 3)\nfalse\n\n\n\n\nHay d\u00f9ng c\u00fa ph\u00e1p \nleft in right\n:\n\n\niex(21)> 1 in [1, 2, 3]\ntrue\n\n\n\n\nCh\u00fa \u00fd c\u00fa ph\u00e1p \nin\n n\u00e0y kh\u00f4ng ho\u1ea1t \u0111\u1ed9ng v\u1edbi tuple, map (nh\u01b0 trong Python).\n\n\niex(21)> 1 in {1, 2, 3}\n** (Protocol.UndefinedError) protocol Enumerable not implemented for {1, 2, 3}\n    (elixir) lib/enum.ex:1: Enumerable.impl_for!/1\n    (elixir) lib/enum.ex:131: Enumerable.member?/2\n    (elixir) lib/enum.ex:1352: Enum.member?/2\niex(22)> :a in %{:a => value}\n** (CompileError) iex:22: undefined function value/0\n    (elixir) expanding macro: Kernel.in/2\n             iex:22: (file)\n\n\n\n\n\n\nN\u1ed1i 2 list \nconcatenate\n\n\n\n\niex(18)> li ++ [2, \"Erlang\"]\n[1, \"PyMi\", \"Python\", \"Elixir\", 2, \"Erlang\"]\n\n\n\n\n\n\nTr\u1eeb 2 list \nsubtract\n\n\n\n\niex(22)> [1, 2, 3, 2, 1] -- [2]\n[1, 3, 2, 1]\niex(23)> [1, 2, 3, 2, 1] -- [2, 3]\n[1, 2, 1]\n\n\n\n\n\n\n\"Th\u00eam\" ph\u1ea7n t\u1eed v\u00e0o list: th\u1ef1c ra l\u00e0 t\u1ea1o m\u1ed9t list m\u1edbi\nTh\u00eam \"Zero\" v\u00e0o index 0\n\n\n\n\niex(21)> List.insert_at(li, 0, \"Zero\")\n[\"Zero\", 1, \"PyMi\", \"Python\", \"Elixir\"]\n\n\n\n\n\n\n\"Th\u00eam\" m\u1ed9t ph\u1ea7n t\u1eed v\u00e0o \u0111\u1ea7u list (si\u00eau t\u1ed1c - constant time O(1)):\n\n\n\n\niex(27)> l3 = [\"Python\", \"PyMi\", \"Golang\", \"FAMILUG.org\"]\n[\"Python\", \"PyMi\", \"Golang\", \"FAMILUG.org\"]\niex(28)> [\"h\" | l3]\n[\"h\", \"Python\", \"PyMi\", \"Golang\", \"FAMILUG.org\"]\n\n\n\n\n\n\n\"Th\u00eam\" m\u1ed9t ph\u1ea7n t\u1eed xu\u1ed1ng cu\u1ed1i list (ch\u1eadm, linear time O(n))\n\n\n\n\niex(30)> l3 ++ [\"t\"]\n[\"Python\", \"PyMi\", \"Golang\", \"FAMILUG.org\", \"t\"]\n\n\n\n\n\n\nThay m\u1ed9t ph\u1ea7n t\u1eed c\u1ee7a list t\u1ea1i 1 index:\n\n\n\n\niex(33)> List.replace_at([\"Python\", \"PyMi\", \"Golang\", \"FAMILUG.org\", \"t\"], 2, \"Elixir\")\n[\"Python\", \"PyMi\", \"Elixir\", \"FAMILUG.org\", \"t\"]\n\n\n\n\n\n\n\"Xo\u00e1\" ph\u1ea7n t\u1eed kh\u1ecfi list (d\u00f9ng value c\u1ee7a ph\u1ea7n t\u1eed v\u00e0 d\u00f9ng index):\n\n\n\n\niex(31)> List.delete([\"Python\", \"PyMi\", \"Golang\", \"FAMILUG.org\", \"t\"], \"Golang\")\n[\"Python\", \"PyMi\", \"FAMILUG.org\", \"t\"]\niex(32)> List.delete_at([\"Python\", \"PyMi\", \"Golang\", \"FAMILUG.org\", \"t\"], 2)\n[\"Python\", \"PyMi\", \"FAMILUG.org\", \"t\"]\n\n\n\n\n\n\nL\u1ea5y m\u1ed9t list con t\u1eeb list (slice):\nslice(enumerable, start, amount)\n\n\n\n\niex(36)>  Enum.slice([\"Python\", \"PyMi\", \"Elixir\", \"FAMILUG.org\"], 1, 10)\n[\"PyMi\", \"Elixir\", \"FAMILUG.org\"]\n\n\n\n\n\n\nS\u1eafp x\u1ebfp 1 list\n\n\n\n\nTheo b\u1ea3ng ch\u1eef c\u00e1i\n\n\niex(37)> Enum.sort([\"Python\", \"PyMi\", \"Elixir\", \"FAMILUG.org\", \"t\"])\n[\"Elixir\", \"FAMILUG.org\", \"PyMi\", \"Python\", \"t\"]\n\n\n\n\nTheo ti\u00eau ch\u00ed nh\u1ea5t \u0111\u1ecbnh (function)\n\n\niex(35)> Enum.sort_by([\"Python\", \"PyMi\", \"Elixir\", \"FAMILUG.org\", \"t\"], &String.length/1)\n[\"t\", \"PyMi\", \"Python\", \"Elixir\", \"FAMILUG.org\"]\n\n\n\n\nhttps://hexdocs.pm/elixir/Enum.html#content\n\n\nMap\n\n\nl\u00e0 m\u1ed9t c\u1ea5u tr\u00fac d\u1eef li\u1ec7u c\u00f3 th\u1ec3 g\u1ecdi l\u00e0 \"key-value\" store.\nT\u00ean kh\u00e1c (trong ng\u00f4n ng\u1eef kh\u00e1c): dictionary, associative array\n\n\nmap = %{:a => 1, :b => 2}\n\n\n\n\n\n\nT\u1ea1o map:\n%{key => value1, key => value2}\n\n\n\n\niex(47)>  %{:a => 1, :b =>2}\n%{a: 1, b: 2}\niex(48)> %{\"name\" => \"PYMI\", \"country\" => \"VN\"}\n%{\"country\" => \"VN\", \"name\" => \"PYMI\"}\n\n\n\n\n\n\n\u0110\u1ebfm s\u1ed1 ph\u1ea7n t\u1eed\n\n\nTruy c\u1eadp value:\n\n\n\n\niex(68)> %{:name => who} = %{:name => \"HVN\"}\n%{name: \"HVN\"}\niex(69)> who\n\"HVN\"\n\niex(44)> map = %{:a => 1, :b =>2}\n%{a: 1, b: 2}\niex(46)> map[:b]\n2\niex(47)> map[:c]\nnil\n\n\n\n\nHay\n\n\niex(60)> Map.get(map, :b)\n2\n\n\n\n\nTruy c\u1eadp 1 key kh\u00f4ng t\u1ed3n t\u1ea1i s\u1ebd tr\u1ea3 v\u1ec1 nil.\n\n\n\n\nKi\u1ec3m tra key c\u00f3 trong map kh\u00f4ng\n\n\n\n\niex(3)> Map.has_key?(%{:name => \"HVN\"}, :age)\nfalse\n\n\n\n\n\n\n\"Th\u00eam\" key-value m\u1edbi:\n\n\n\n\niex(62)> Map.put(%{:a => 1}, :h, 4)\n%{a: 1, h: 4}\n\n\n\n\n\n\nXo\u00e1 key-value:\n\n\n\n\niex(1)> Map.delete(%{:name => \"HVN\", :age => 27}, :age)\n%{name: \"HVN\"}\n\n\n\n\nXo\u00e1 key kh\u00f4ng t\u1ed3n t\u1ea1i kh\u00f4ng \u1ea3nh h\u01b0\u1edfng g\u00ec:\n\n\niex(2)> Map.delete(%{:name => \"HVN\", :age => 27}, :language)\n%{age: 27, name: \"HVN\"}\n\n\n\n\n\n\n\n\nDuy\u1ec7t qua t\u1eebng key # TODO\n\n\n\n\n\n\nBi\u1ebfn th\u00e0nh list c\u00e1c tuple key-value:\n\n\n\n\n\n\niex(63)> Map.to_list(%{:name => \"HVN\", :age => 27})\n[age: 27, name: \"HVN\"]\n\n\n\n\n\n\nUpdate value c\u1ee7a 1 key \u0111\u00e3 trong map (kh\u00f4ng th\u00eam):\n\n\n\n\niex(65)> %{ map | :b => 5}\n%{a: 1, b: 5}\niex(66)> %{ map | :c => 5}\n** (KeyError) key :c not found in: %{a: 1, b: 2}\n\n\n\n\n\n\nTruy c\u1eadp c\u00e1c atom key b\u1eb1ng \n.\n:\n\n\n\n\niex(66)> student = %{:name => \"HVN\"}\n%{name: \"HVN\"}\niex(67)> student.name\n\"HVN\"\n\n\n\n\n\n\nUpdate value nested dict v\u1edbi \nput_in/2\n:\n\n\n\n\niex(70)> users = [hvn: %{name: \"HVN\", age: 27, language: [\"Erlang\", \"Elixir\", \"Python\"]},\nhails: %{name: \"HaiLS\", age: 26, language: [\"Golang\", \"JS\"]}]\n[hvn: %{age: 27, language: [\"Erlang\", \"Elixir\", \"Python\"], name: \"HVN\"},\n hails: %{age: 26, language: [\"Golang\", \"JS\"], name: \"HaiLS\"}]\n\niex(72)> put_in users[:hvn].age, 29\n[hvn: %{age: 29, language: [\"Erlang\", \"Elixir\", \"Python\"], name: \"HVN\"},\n hails: %{age: 26, language: [\"Golang\", \"JS\"], name: \"HaiLS\"}]\n\n\n\n\nM\u1ed7i ki\u1ec3u d\u1eef li\u1ec7u \u0111\u1ec1u c\u00f3 m\u1ed9t module t\u01b0\u01a1ng \u1ee9ng cung c\u1ea5p c\u00e1c function c\u1ea7n thi\u1ebft: List, Map, String. Module \nEnum\n d\u00f9ng chung cho c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u cho ph\u00e9p duy\u1ec7t qua t\u1eebng ph\u1ea7n t\u1eed: nh\u01b0 \nList\n, \nString\n.\n\n\nPattern matching\n\n\n=\n : the match operator\n- Khi g\u00e1n bi\u1ebfn, bi\u1ebfn ph\u1ea3i n\u1eb1m b\u00ean tr\u00e1i d\u1ea5u \n=\n\n\niex(7)> x = 5\n5\niex(8)> 6 = y\n** (CompileError) iex:8: undefined function y/0\n\n\n\n\n\n\nV\u1ebf tr\u00e1i c\u00f3 th\u1ec3 l\u00e0 ki\u1ec3u d\u1eef li\u1ec7u ph\u1ee9c t\u1ea1p h\u01a1n, d\u00f9ng \u0111\u1ec3 \"destructuring\" hay \"unpacking\" d\u1eef li\u1ec7u ph\u00eda tay ph\u1ea3i.\nS\u1ed1 ph\u1ea7n t\u1eed 2 b\u00ean ph\u1ea3i b\u1eb1ng nhau, c\u00f9ng ki\u1ec3u:\n\n\n\n\niex(18)> {name, age} = {\"PyMI.vn\", 2}\n{\"PyMI.vn\", 2}\niex(19)> name\n\"PyMI.vn\"\niex(20)> age\n2\n\niex(1)> [x, y, z] = [1, 2, 4]  # list\n[1, 2, 4]\niex(2)> x\n1\niex(3)> z\n4\n\n\n\n\nKhi b\u00ean ph\u1ea3i ch\u1ee9a gi\u00e1 tr\u1ecb thay v\u00ec bi\u1ebfn, 2 b\u00ean ch\u1ec9 match nhau n\u1ebfu gi\u00e1 tr\u1ecb b\u00ean tay tr\u00e1i match gi\u00e1 tr\u1ecb b\u00ean tay ph\u1ea3i:\n\n\niex(4)> {:ok, 1, salary} = {:ok, 1, 15}\n{:ok, 1, 15}\niex(5)> {:ok, 1, income} = {:ok, 3, 20}\n** (MatchError) no match of right hand side value: {:ok, 3, 20}\n\niex(10)> {x, x} = {1, 1}\n{1, 1}\niex(11)> {x, x} = {1, 2}\n** (MatchError) no match of right hand side value: {1, 2}\n\n\n\n\n\n\nKhi 2 b\u00ean kh\u00f4ng \"match\", MatchError s\u1ebd x\u1ea3y ra.\n\n\n\n\nMatching v\u1edbi c\u00fa ph\u00e1p [head | tail]:\n\n\n\n\niex(5)> [h | t] = [1, 2, 3, 4]\n[1, 2, 3, 4]\niex(6)> h\n1\niex(7)> t\n[2, 3, 4]\n\n\n\n\nGi\u1ed1ng nh\u01b0 g\u1ecdi function \nhd\n v\u00e0 \ntl\n:\n\n\niex(8)> hd [1, 2, 3, 4]\n1\niex(9)> tl [1, 2, 3, 4]\n[2, 3, 4]\n\n\n\n\nC\u00fa ph\u00e1p n\u00e0y r\u00f5 r\u00e0ng kh\u00f4ng match list r\u1ed7ng:\n\n\niex(10)> [h | t] = []\n** (MatchError) no match of right hand side value: []\n\n\n\n\n\n\n\nTruy c\u1eadp gi\u00e1 tr\u1ecb c\u1ee7a m\u1ed9t bi\u1ebfn thay v\u00ec g\u00e1n l\u1ea1i n\u00f3 b\u1eb1ng \n^\n - pin operator:\n\n\n\n\niex(11)> x = 5\n5\niex(12)> x = 7\n7\niex(13)> x\n7\niex(14)> ^x = 8\n** (MatchError) no match of right hand side value: 8\nV\u00ec gi\u1ed1ng nh\u01b0 vi\u1ebft: 7 = 8\niex(14)> 7 = 8\n** (MatchError) no match of right hand side value: 8\n\n\n\n\nControl flow: case, cond, if, unless, do/end\n\n\nif\n\n\nif/2 l\u00e0 m\u1ed9t function, t\u1ee9c n\u00f3 s\u1ebd tr\u1ea3 v\u1ec1 m\u1ed9t gi\u00e1 tr\u1ecb sau khi ch\u1ea1y. Kh\u00e1c v\u1edbi Python hay nhi\u1ec1u ng\u00f4n ng\u1eef kh\u00e1c, if trong Python l\u00e0 m\u1ed9t \"statement\" (c\u00e2u l\u1ec7nh), v\u00e0 n\u00f3 ch\u1ec9 th\u1ef1c hi\u1ec7n \u0111i\u1ec1u khi\u1ec3n lu\u1ed3ng ch\u1ee9 kh\u00f4ng tr\u1ea3 v\u1ec1 gi\u00e1 tr\u1ecb n\u00e0o.\n(PS: th\u1ef1c s\u1ef1 if/2 m\u00e0 1 macro - kh\u00e1i ni\u1ec7m macro s\u1ebd \u0111\u01b0\u1ee3c n\u00f3i sau)\n\n\niex(15)> k = if 5 > 4 do\n...(15)> \"yeah\"\n...(15)> end\n\"yeah\"\niex(16)> k\n\"yeah\"\n\n\n\n\nif/2 tr\u1ea3 v\u1ec1 nil n\u1ebfu \u0111i\u1ec1u ki\u1ec7n n\u00f3 nh\u1eadn \u0111\u01b0\u1ee3c tr\u1ea3 v\u1ec1 false hay nil.\n\n\niex(17)> h = if 5 < 4 do\n...(17)> \"hey\"\n...(17)> end\nnil\niex(18)> h\nnil\n\n\n\n\nM\u1eabu c\u00fa ph\u00e1p:\n\n\nif condition do\nSOMETHING\nend\n\n\n\n\nif\n c\u00f3 th\u1ec3 \u0111i k\u00e8m v\u1edbi \nelse\n:\n\n\niex(19)> m = if 5 < 4 do\n...(19)> \"smaller\"\n...(19)> else\n...(19)> \"bigger\"\n...(19)> end\n\"bigger\"\niex(20)> m\n\"bigger\"\n\n\n\n\nTrong Elixir ch\u1ec9 c\u00f3 \nif/else/end\n kh\u00f4ng c\u00f3 elif nh\u01b0 trong Python, khi c\u1ea7n x\u1eed l\u00fd nhi\u1ec1u tr\u01b0\u1eddng h\u1ee3p, ta c\u00f3 th\u1ec3 d\u00f9ng cond.\n\n\n\u0110\u1ecdc th\u00eam: https://hexdocs.pm/elixir/Kernel.html#if/2\n\n\ncond\n\n\ncond do ... end\n cho ph\u00e9p x\u1eed l\u00fd nhi\u1ec1u \u0111i\u1ec1u ki\u1ec7n, gi\u1ed1ng nh\u01b0 elif hay else if trong c\u00e1c ng\u00f4n ng\u1eef kh\u00e1c:\n\n\niex(24)> x = 18\n18\niex(25)> cond do\n...(25)>   x < 18 ->\n...(25)>     \"Not permitted\"\n...(25)>   x == 18 ->\n...(25)>     \"Okay\"\n...(25)>   x > 18 ->\n...(25)>     \"Too old\"\n...(25)> end\n\"Okay\"\n\n\n\n\nunless\n\n\nNh\u01b0 if, nh\u01b0ng ng\u01b0\u1ee3c l\u1ea1i.\n\n\niex(26)> x = 18\n18\niex(27)> unless x < 18 do\n...(27)>   \"got this\"\n...(27)> end\n\"got this\"\niex(28)> if x < 18 do\n...(28)>   \"no\"\n...(28)> end\nnil\n\n\n\n\ncase\n\n\ncase\n s\u1eed d\u1ee5ng pattern matching, v\u00e0 ch\u1ec9 d\u1eebng l\u1ea1i khi ta t\u00ecm th\u1ea5y gi\u00e1 tr\u1ecb n\u00e0o match. Ta th\u1ea5y \ncase\n ch\u1ec9 d\u00f9ng \u0111\u1ec3 ki\u1ec3m tra xem 1 gi\u00e1 tr\u1ecb c\u00f3 b\u1eb1ng m\u1ed9t gi\u00e1 tr\u1ecb kh\u00e1c, ch\u1ee9 kh\u00f4ng d\u00f9ng so s\u00e1nh >, < ... nh\u01b0 \nif\n.\n\n\niex(22)> case 5 do\n...(22)>   4 ->\n...(22)>\n...(22)> \"Won't match\"\n...(22)> _ ->\n...(22)> \"will match\"\n...(22)> end\n\"will match\"\n\n\n\n\niex(23)> case {1, 2, 3} do\n...(23)>   {1, x, 3} when x > 0 ->\n...(23)>     \"will match\"\n...(23)>   _ ->\n...(23)>     \"Would match, if guard cond were not sastified\"\n...(23)> end\n\"will match\"\n\n\n\n\nwhen x > 0\n g\u1ecdi l\u00e0 guard condition. Ta th\u1ea5y \ncase\n c\u0169ng l\u00e0 m\u1ed9t macro ch\u1ee9 kh\u00f4ng ph\u1ea3i \"statement\" nh\u01b0 trong c\u00e1c ng\u00f4n ng\u1eef kh\u00e1c.\n\n\nC\u00fa ph\u00e1p:\n\n\ncase SOMETHING do\n  CLAUSE1 [GUARD] ->\n      \"OTHERTHING\"\n  CLAUSE2 [GUARD] ->\n     ...\n  _ ->\n     \"LAST PATTERN MATCH REMAIN\"\nend\n\n\n\n\nN\u1ebfu kh\u00f4ng clause n\u00e0o match, error s\u1ebd \u0111\u01b0\u1ee3c raise:\n\n\niex(24)> case :ok do\n...(24)>   :error ->\n...(24)>     \"Not match\"\n...(24)> end\n** (CaseClauseError) no case clause matching: :ok\n\n\n\n\n\nGuard\n\n\nTrong guard kh\u00f4ng \u0111\u01b0\u1ee3c d\u00f9ng && || !\nError trong guard s\u1ebd khi\u1ebfn guard fail.\n\n\ndo/end\n\n\nTrong \nif\n \nunless\n \ncond\n \ncase\n \u0111\u1ec1u c\u00f3 d\u00f9ng \ndo\n v\u00e0\nk\u1ebft th\u00fac b\u1eb1ng \nend\n.\n\n\nif true do\n...\nend\n\n\n\n\nT\u01b0\u01a1ng \u0111\u01b0\u01a1ng v\u1edbi:\n\n\nif true, do: (\n...\n)\n\n\n\n\ndo/end\n l\u00e0 syntactix sugar (c\u00fa ph\u00e1p \u0111\u1ec3 vi\u1ebft cho d\u1ec5).\n\n\nFunction\n\n\nG\u1ecdi function (calling):\n\n\nC\u00fa ph\u00e1p th\u00f4ng th\u01b0\u1eddng:\n\n\niex(1)> String.to_integer(String.trim(\"  42 \\n \"))\n42\niex(7)> String.split(\"42-15\\n17\", [\"-\", \"\\n\"])\n[\"42\", \"15\", \"17\"]\n\n\n\n\nC\u00fa ph\u00e1p b\u1ecf d\u1ea5u \n()\n:\n\n\niex(8)> String.split \"42-15\\n17\", [\"-\", \"\\n\"]\n[\"42\", \"15\", \"17\"]\n\niex(10)> Enum.map(String.split(\"42-15\\n17\", [\"-\", \"\\n\"]), fn(x) -> String.to_integer(x) end)\n[42, 15, 17]\n\n\n\n\nTo\u00e1n t\u1eed pipe (pipe operator)\n\n\nC\u00fa ph\u00e1p s\u1eed d\u1ee5ng \"pipe\", d\u1eef li\u1ec7u s\u1ebd ch\u1ea1y t\u1eeb output c\u1ee7a 1 function, qua pipe v\u00e0 tr\u1edf th\u00e0nh argument \u0111\u1ea7u ti\u00ean c\u1ee7a function ti\u1ebfp theo (gi\u1ed1ng Pipeline tr\u00ean UNIX shell).\n\n\niex(11)> String.split(\"42-15\\n17\", [\"-\", \"\\n\"]) |> Enum.map(fn(x) -> String.to_integer(x) end)\n[42, 15, 17]\n\niex(23)> 1..1000 |> Enum.filter(fn(x) -> (rem(x, 3) == 0 || rem(x, 5) == 0) end) |> Enum.sum\n234168\n\n\n\n\n\u0110\u1ecbnh ngh\u0129a function\n\n\nFunction c\u00f3 t\u00ean ph\u1ea3i \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong module.\nFunction s\u1ebd tr\u1ea3 v\u1ec1 gi\u00e1 tr\u1ecb cu\u1ed1i c\u00f9ng n\u00f3 t\u00ednh \u0111\u01b0\u1ee3c - kh\u00f4ng c\u00f3 c\u00e2u l\u1ec7nh \"return\".\n\u0110o\u1ea1n code sau \u0111\u1ecbnh ngh\u0129a module \nMath\n v\u00e0 function \nsum\n tr\u1ea3 v\u1ec1 t\u1ed5ng c\u1ee7a 2 argument a, b:\n\n\ndefmodule Math do\n  def sum(a, b) do\n    a + b\n  end\nend\n\n\n\n\nho\u1eb7c\n\n\ndefmodule Hacker, do: def hack(x), do: x*2\n\n\n\n\nkhi ch\u1ec9 c\u00f3 1 function v\u00e0 function ch\u1ec9 c\u00f3 1 d\u00f2ng.\n\n\ndefmodule\n v\u00e0 \ndef\n \u0111\u1ec1u l\u00e0 c\u00e1c macro.\n\n\nPrivate function\n\n\n\u0110\u1ecbnh ngh\u0129a b\u1eb1ng macro \ndefp/2\n, t\u1eeb module kh\u00e1c kh\u00f4ng th\u1ec3 ch\u1ea1y c\u00e1c function n\u00e0y.\n\n\nK\u00fd hi\u1ec7u (notation)\n\n\nKhi nh\u1eafc t\u1edbi function, trong Elixir d\u00f9ng k\u00fd hi\u1ec7u:\n\nname/arity\n v\u1edbi name l\u00e0 t\u00ean , v\u00e0 arity l\u00e0 s\u1ed1 argument function \u0111\u00f3 nh\u1eadn.\n\n\nMath.sum \u1edf tr\u00ean k\u00fd hi\u1ec7u l\u00e0 \nMath.sum/2\n\n\nMultiple clause function\n\n\nM\u1ed9t function c\u00f3 th\u1ec3 c\u00f3 nhi\u1ec1u \nclause\n:\n\n\nM\u1ed7i \"clause\" th\u01b0\u1eddng \u0111i k\u00e8m m\u1ed9t \"guard\", n\u1ebfu argument pass v\u00e0o match v\u1edbi argument c\u1ee7a clause v\u00e0 guard \u0111i k\u00e8m tr\u1ea3 v\u1ec1 \ntrue\n, clause \u0111\u00f3 s\u1ebd \u0111\u01b0\u1ee3c g\u1ecdi.\n\n\ndefmodule Foo do\n  def rprint(msg, n) when n <= 1 do\n    IO.puts msg\n  end\n\n  def rprint(msg, n) do\n    IO.puts msg\n    rprint(msg, n - 1)\n  end\nend\n\nFoo.rprint(\"Hello\", 5)\n\n\n\n\nFunction capturing\n\n\nTODO\n\n\nDefault argument\n\n\ndef join(a, b, sep \\\\ \",\") do\n  a <> sep <> b\nend\n\n\n\n\n\",\" l\u00e0 default argument, khi g\u1ecdi funtion m\u00e0 kh\u00f4ng pass gi\u00e1 tr\u1ecb cho argument \nsep\n, \nsep\n s\u1ebd s\u1eed d\u1ee5ng gi\u00e1 tr\u1ecb m\u1eb7c \u0111\u1ecbnh \",\".\n\n\nC\u00e1c ph\u1ea7n c\u1ee7a m\u1ed9t function\n\n\ndef sum(a, b) do\n  a + b\nend\n\n\n\n\n\n\nFunction head: \ndef sum(a, b)\n\n\nFunction body: t\u1eeb \ndo\n \u0111\u1ebfn \nend\n\n\n\n\nKhi function v\u1edbi default value c\u00f3 nhi\u1ec1u m\u1ec7nh \u0111\u1ec1, ph\u1ea3i khai b\u00e1o m\u1ed9t function head \u0111\u1ec3 khai b\u00e1o gi\u00e1 tr\u1ecb default.\n\n\nTODO more detail\n\n\nModule\n\n\nCompile\n\n\nC\u00f3 th\u1ec3 vi\u1ebft module v\u00e0o file \nNAME.ex\n: \nmath.ex\n.\n\n\nCompile module:\n\n\n$ elixirc math.ex  # t\u1ea1o ra file Elixir.Math.beam\n\n\n\n\nB\u1eadt \niex\n c\u00f9ng th\u01b0 m\u1ee5c s\u1ebd t\u1ef1 \u0111\u1ed9ng load module, ch\u1ec9 vi\u1ec7c g\u1ecdi.\n\n\nScript\n\n\nL\u01b0u file v\u1edbi \u0111u\u00f4i .exs, Elixir s\u1ebd hi\u1ec3u \u0111\u00f3 l\u00e0 1 \"script\" v\u00e0 s\u1ebd kh\u00f4ng t\u1ea1o file c\u00f3 \u0111u\u00f4i .beam n\u1eefa, ch\u1ea1y n\u00f3 nh\u01b0 ch\u1ea1y c\u00e1c script kh\u00e1c (Python, bash...):\n\n\n$ elixir math.exs\n\n\n\n\nLoop b\u1eb1ng recursion, reduce v\u00e0 map\n\n\nTrong Elixir, m\u1ecdi th\u1ee9 \u0111\u1ec1u l\u00e0 \"immutable\" (kh\u00f4ng thay \u0111\u1ed5i \u0111\u01b0\u1ee3c), v\u00ec v\u1eady nh\u1eefng kh\u00e1i ni\u1ec7m \u0111\u1ec3 l\u1eb7p nh\u01b0 trong c\u00e1c ng\u00f4n ng\u1eef C, Python, Java, PHP, Golang ... s\u1ebd kh\u00f4ng \u0111\u01b0\u1ee3c \u1ee9ng d\u1ee5ng:\n\n\nfor i in 'Elixir':\n    print(i)\n\n\n\n\n\u1ede v\u00f2ng l\u1eb7p for n\u00e0y, gi\u00e1 tr\u1ecb c\u1ee7a i l\u1ea7n l\u01b0\u1ee3t thay \u0111\u1ed5i th\u00e0nh c\u00e1c k\u00fd t\u1ef1 trong \"Elixir\" -> kh\u00f4ng \u0111\u1ea3m b\u1ea3o \u0111\u01b0\u1ee3c t\u00ednh immutable c\u1ee7a Elixir.\n\n\ni = 0\nwhile True:\n    print(i)\n    i = i + 1\n\n\n\n\nT\u01b0\u01a1ng t\u1ef1, trong v\u00f2ng l\u1eb7p while n\u00e0y i c\u0169ng thay \u0111\u1ed5i sau m\u1ed7i v\u00f2ng l\u1eb7p, kh\u00f4ng \u0111\u1ea3m b\u1ea3o t\u00ednh immutable.\n\n\nElixir hay c\u00e1c ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh h\u00e0m (functional programming language) kh\u00e1c s\u1eed d\u1ee5ng recursive function \u0111\u1ec3 t\u1ea1o hi\u1ec7u \u1ee9ng/ k\u1ebft qu\u1ea3 nh\u01b0 loop.\n\n\nRecursive function\n\n\nL\u00e0 function m\u00e0 b\u00ean trong ph\u1ea7n body, n\u00f3 t\u1ef1 g\u1ecdi \u0111\u1ebfn ch\u00ednh n\u00f3 cho \u0111\u1ebfn khi g\u1eb7p m\u1ed9t \u0111i\u1ec1u ki\u1ec7n \u0111\u1ec3 d\u1eebng l\u1ea1i. S\u1ebd kh\u00f4ng c\u00f3 g\u00ec b\u1ecb thay \u0111\u1ed5i khi d\u00f9ng recursive function, b\u1edfi ta s\u1ebd sinh ra gi\u00e1 tr\u1ecb m\u1edbi, ch\u1ee9 kh\u00f4ng thay \u0111\u1ed5i gi\u00e1 tr\u1ecb c\u0169. M\u1ecdi kh\u00e1i ni\u1ec7m s\u1ebd r\u00f5 r\u00e0ng khi th\u1eed v\u1edbi function t\u00ednh giai th\u1eeba c\u1ee7a 1 s\u1ed1:\n\n\nGiai th\u1eeba c\u1ee7a m\u1ed9t s\u1ed1 nguy\u00ean kh\u00f4ng \u00e2m \u0111\u01b0\u1ee3c t\u00ednh b\u1eb1ng t\u00edch c\u1ee7a s\u1ed1 \u0111\u00f3 nh\u00e2n v\u1edbi giai th\u1eeda c\u1ee7a s\u1ed1 nh\u1ecf h\u01a1n n\u00f3 1 \u0111\u01a1n v\u1ecb. Hay vi\u1ebft \u1edf d\u1ea1ng c\u00f4ng th\u1ee9c to\u00e1n:\nfactorial(n) = n * factorial(n - 1)\nkhi n = 0 th\u00ec factorial(0) = 1. # \u0111i\u1ec1u ki\u1ec7n d\u1eebng\n\n\nTh\u1eed t\u00ednh factorial c\u1ee7a 3:\n\n\nfactorial(3) = 3 * factorial(2)\nfactorial(2) = 2 * factorial(1)\nfactorial(1) = 1 * factorial(0)\nfactorial(0) = 1\n\n\nSau khi \u0111\u00e3 ch\u1ea1m \u0111\u1ebfn \u0111i\u1ec1u ki\u1ec7n d\u1ef1ng, ta l\u1ea5y k\u1ebft qu\u1ea3 thu \u0111\u01b0\u1ee3c thay ng\u01b0\u1ee3c l\u00ean tr\u00ean.\nfactorial(1) = 1 * factorial(0) = 1 * 1 = 1\nfactorial(2) = 2 * factorial(1) = 2 * 1 = 2\nfactorial(3) = 3 * factorial(2) = 3 * 2 = 6\n\n\nK\u1ebft qu\u1ea3 l\u00e0 factorial(3) b\u1eb1ng 6.\n\n\ndefmodule Rescusion do\n  def fact(n) when n <= 0 do\n    1\n  end\n\n  def fact(n) do\n    n * fact(n - 1)\n  end\nend\n\n\n\n\nTrong b\u00e0i n\u00e0y, code c\u1ee7a Elixir ch\u1ec9 \u0111\u01a1n gi\u1ea3n l\u00e0 chuy\u1ec3n c\u00f4ng th\u1ee9c to\u00e1n h\u1ecdc th\u00e0nh code.\n\n\nMap\n\n\nM\u1ed9t vi\u1ec7c l\u00e0m th\u01b0\u1eddng xuy\u00ean khi s\u1eed d\u1ee5ng loop l\u00e0 \u0111\u1ec3 bi\u1ebfn 1 t\u1eadp gi\u00e1 tr\u1ecb, th\u00e0nh 1 t\u1eadp gi\u00e1 tr\u1ecb kh\u00e1c.\n\n\nV\u00ed d\u1ee5, cho m\u1ed9t list \nL = [1, 2, 3 ,4]\n, c\u1ea7n thu \u0111\u01b0\u1ee3c k\u1ebft qu\u1ea3 l\u00e0 m\u1ed9t list m\u00e0 ph\u1ea7n t\u1eed c\u1ee7a n\u00f3 l\u00e0 m\u1ed7i ph\u1ea7n t\u1eed c\u1ee7a \nL\n nh\u00e2n v\u1edbi 2.\n\n\nVi\u1ec7c bi\u1ebfn m\u1ed9t t\u1eadp th\u00e0nh m\u1ed9t t\u1eadp kh\u00e1c b\u1eb1ng c\u00e1ch g\u1ecdi function v\u1edbi m\u1ed7i ph\u1ea7n t\u1eed c\u1ee7a t\u1eadp g\u1ecdi l\u00e0 \"mapping\" (\u00e1nh x\u1ea1 trong to\u00e1n h\u1ecdc).\nTa \"map\" m\u1ed9t ph\u1ea7n t\u1eed t\u1eeb t\u1eadp ban \u0111\u1ea7u th\u00e0nh ph\u1ea7n t\u1eed trong t\u1eadp m\u1edbi.\n\n\nVi\u1ebft function \u0111\u1ec3 map list n\u00f3i tr\u00ean:\n\n\niex(41)> defmodule Double do\n...(41)>   def double_each([head | tail]) do\n...(41)>     [head * 2 | double_each(tail)]\n...(41)>   end\n...(41)>\n...(41)>   def double_each([]) do\n...(41)>     []\n...(41)>   end\n...(41)> end\n{:module, Double,\n...\niex(42)> Double.double_each([1,2,3,4])\n[2, 4, 6, 8]\n\n\n\n\nC\u00f3 th\u1ec3 d\u00f9ng function c\u00f3 s\u1eb5n \nEnum.map/2\n \u0111\u1ec3 th\u1ef1c hi\u1ec7n mapping:\n\n\niex(45)> Enum.map([1,2,3,4], fn(x) -> x * 2 end)\n[2, 4, 6, 8]\n\n\n\n\nReduce\n\n\nM\u1ed9t \u1ee9ng d\u1ee5ng kh\u00e1c th\u01b0\u1eddng d\u00f9ng khi l\u1eb7p l\u00e0 \u0111\u1ec3 t\u00ednh m\u1ed9t gi\u00e1 tr\u1ecb n\u00e0o \u0111\u00f3 s\u1ebd thu \u0111\u01b0\u1ee3c sau khi duy\u1ec7t qua t\u1ea5t c\u1ea3 gi\u00e1 tr\u1ecb trong t\u1eadp, nh\u01b0 t\u00ednh t\u1ed5ng, t\u00edch c\u1ee7a t\u1eadp.\n\n\n\u1ede \u0111\u00e2y ta bi\u1ebfn t\u1eeb 1 t\u1eadp nhi\u1ec1u ph\u1ea7n t\u1eed th\u00e0nh 1 gi\u00e1 tr\u1ecb cu\u1ed1i c\u00f9ng. Vi\u1ec7c \"thu g\u1ecdn\" n\u00e0y c\u00f3 t\u00ean l\u00e0 \"reducing\".\n\n\nMap v\u00e0 reduce l\u00e0 2 thu\u1eadt to\u00e1n c\u1ed1t l\u00f5i c\u1ee7a \"big data\".\n\n\niex(46)> defmodule Reduce do\n...(46)>   def sum_list([head | tail], accumulator) do\n...(46)>     sum_list(tail, head + accumulator)\n...(46)>   end\n...(46)>\n...(46)>   def sum_list([], accumulator) do\n...(46)>     accumulator\n...(46)>   end\n...(46)> end\n\niex(47)> Reduce.sum_list([1,2,3], 0)\n6\n\n\n\n\nHay d\u00f9ng module c\u00f3 s\u1eb5n \nEnum.reduce/2\n:\n\n\niex(48)> Enum.reduce([1,2,3], 0, fn(x, acc) -> x + acc end)\n6\n\n\n\n\nIO - x\u1eed l\u00fd d\u1eef li\u1ec7u v\u00e0o ra.\n\n\nIn ra m\u00e0n h\u00ecnh\n\n\nM\u1eb7c d\u00f9 h\u1ea7u h\u1ebft c\u00e1c s\u00e1ch d\u1ea1y l\u1eadp tr\u00ecnh / tr\u01b0\u1eddng h\u1ecdc s\u1ebd lu\u00f4n b\u1eaft \u0111\u1ea7u b\u1eb1ng vi\u1ec7c d\u1ea1y \"print\" ra m\u00e0n h\u00ecnh (v\u00e0 \u0111i k\u00e8m l\u00e0 \u0111\u1ecdc nh\u1eefng g\u00ec ng\u01b0\u1eddi d\u00f9ng nh\u1eadp v\u00e0o), nh\u01b0ng tr\u00ean th\u1ef1c t\u1ebf, c\u00f3 kho\u1ea3ng < 5% ng\u01b0\u1eddi th\u1ef1c s\u1ef1 d\u00f9ng print trong ch\u01b0\u01a1ng tr\u00ecnh c\u1ee7a m\u00ecnh.\n\n\nH\u00e3y th\u1eed ngh\u0129 v\u1edbi ng\u01b0\u1eddi d\u00f9ng Windows, c\u00f3 bao gi\u1edd b\u1ea1n b\u1eadt \ncmd\n l\u00ean v\u00e0 g\u00f5 l\u1ec7nh? C\u00e1c ch\u01b0\u01a1ng tr\u00ecnh \u0111\u1ec1u giao ti\u1ebfp v\u1edbi ng\u01b0\u1eddi d\u00f9ng qua giao di\u1ec7n \u0111\u1ed3 ho\u1ea1 / web, ch\u1ee9 kh\u00f4ng ph\u1ea3i c\u00e1c d\u00f2ng l\u1ec7nh. Nh\u1eefng ng\u01b0\u1eddi l\u00e0m vi\u1ec7c v\u1edbi d\u00f2ng l\u1ec7nh ch\u1ee7 y\u1ebfu l\u00e0 c\u00e1c Linux Sysadmin / l\u1eadp tr\u00ecnh vi\u00ean / hacker.\nN\u1ebfu b\u1ea1n l\u00e0 m\u1ed9t web developer, b\u1ea1n \u0111\u01b0a n\u1ed9i dung ra trang web ch\u1ee9 kh\u00f4ng print n\u00f3.\n\n\nElixir s\u1eed d\u1ee5ng module \nIO\n cho c\u00e1c thao t\u00e1c n\u00e0y:\n\n\niex(49)> IO.puts \"Hello\"\nHello\n:ok\niex(50)> IO.puts \"Hello FAMILUG\"\nHello FAMILUG\n:ok\niex(51)> answer = IO.gets(\"yes or no? \")\nyes or no? yes\n\"yes\\n\"\niex(52)> IO.puts(answer)\nyes\n\n:ok\n\n\n\n\nC\u00f3 th\u1ec3 ghi ra stderr:\n\n\niex(53)> IO.puts(:stderr, \"Hello standard error\")\nHello standard error\n:ok\n\n\n\n\n\u0110\u1ec3 kh\u00f4ng th\u00eam k\u00fd t\u1ef1 newline (\n\\n\n) sau m\u1ed7i d\u00f2ng, s\u1eed d\u1ee5ng \nIO.write\n thay\nv\u00ec \nIO.puts\n.\n\n\n\u0110\u1ecdc ghi file\n\n\nModule \nFile\n ch\u1ee9a c\u00e1c function \u0111\u1ec3 t\u01b0\u01a1ng t\u00e1c v\u1edbi file, t\u1eeb \u0111\u1ecdc, ghi, xo\u00e1, copy...\n\n\niex(53)> IO.puts(:stderr, \"Hello standard error\")\nHello standard error\n:ok\niex(54)> {:ok, file} = File.open(\"hellofile.txt\", [:write])\n{:ok, #PID<0.260.0>}\niex(55)> IO.binwrite(file, \"Hello world!\")\n:ok\niex(56)> File.close(file)\n:ok\niex(57)> File.read(\"hellofile.txt\")\n{:ok, \"Hello world!\"}\n\n\n\n\nC\u00e1c function x\u1eed l\u00fd file:\n\n\nFile.rm/1\n, \nFile.mkdir/1\n, \nFile.cp_r/2\n, ...\n\n\nX\u1eed l\u00fd l\u1ed7i\n\n\nErrror (hay exception)\n\n\niex(58)> \"abc\" + 1\n** (ArithmeticError) bad argument in arithmetic expression\n    :erlang.+(\"abc\", 1)\niex(58)> raise \"oizoioi\"\n** (RuntimeError) oizoioi\n\niex(58)> raise ArgumentError, message: \"invalid argument\"\n** (ArgumentError) invalid argument\n\n\n\n\n\ntry/rescue/catch/after\n\n\nT\u01b0\u01a1ng t\u1ef1 nh\u01b0 try/except trong Python hay try/catch trong Java, Elixir c\u00f3 try/recuse v\u00e0 try/catch, nh\u01b0ng trong Elixir, s\u1eed d\u1ee5ng ch\u00fang l\u00e0 \u0111i\u1ec1u kh\u00f4ng n\u00ean / hi\u1ebfm khi d\u00f9ng.\n\n\niex(61)> try do\n...(61)>   r = 1/0\n...(61)> rescue\n...(61)>   ArithmeticError -> \"Error\"\n...(61)> end\n\"Error\"\n\n\n\n\nV\u1eady Elixir l\u00e0m g\u00ec khi g\u1eb7p l\u1ed7i? c\u00f3 \"exception\" th\u00ec x\u1eed l\u00fd th\u1ebf n\u00e0o?\nTrong tri\u1ebft l\u00fd c\u1ee7a Erlang/Elixir, \"l\u1ed7i\" l\u00e0 m\u1ed9t ph\u1ea7n c\u1ee7a ch\u01b0\u01a1ng tr\u00ecnh, v\u00e0 h\u1ec7 th\u1ed1ng n\u1eb1m d\u01b0\u1edbi ng\u00f4n ng\u1eef (BEAM/OTP) s\u1ebd x\u1eed l\u00fd ch\u00fang m\u1ed9t c\u00e1ch ngon l\u00e0nh. T\u1ea1m th\u1eddi b\u1ecf qua \u1edf \u0111\u00e2y.\n\n\nB\u1eaft \u0111\u1ea7u code m\u1ed9t project\n\n\n\u0110\u1ebfn \u0111\u00e2y \u0111\u00e3 \u0111\u1ee7 c\u00e1c c\u00f4ng c\u1ee5 c\u01a1 b\u1ea3n \u0111\u1ec3 vi\u1ebft nh\u1eefng ch\u01b0\u01a1ng tr\u00ecnh b\u00ecnh th\u01b0\u1eddng / luy\u1ec7n t\u1eadp v\u1edbi c\u00e1c thu\u1eadt to\u00e1n ... cho \u0111\u1ebfn khi quen v\u1edbi ng\u00f4n ng\u1eef.\nElixir c\u00f2n nhi\u1ec1u kh\u00e1i ni\u1ec7m kh\u00e1c, \u0111\u1eb7c bi\u1ec7t \u0111\u01b0\u1ee3c \u0111\u01b0a ra \u0111\u1ec3 x\u1eed l\u00fd trong m\u00f4i tr\u01b0\u1eddng \"ph\u00e2n t\u00e1n\", nh\u01b0ng t\u1eadp trung v\u00e0o nh\u1eefng t\u00ednh n\u0103ng \u0111\u00f3 ngay b\u00e2y gi\u1edd ch\u1ec9 l\u00e0m cho ng\u01b0\u1eddi h\u1ecdc b\u1ecb qu\u00e1 t\u1ea3i v\u1edbi nh\u1eefng kh\u00e1i ni\u1ec7m m\u1edbi l\u1ea1, trong khi v\u1eabn ch\u01b0a n\u1eafm r\u00f5 ph\u1ea7n c\u01a1 b\u1ea3n. V\u1eady n\u00ean, c\u00e1c kh\u00e1i ni\u1ec7m \"kh\u00e1c\" \u0111\u00f3 s\u1ebd \u0111\u01b0\u1ee3c d\u00e0nh cho ph\u1ea7n sau. C\u00f2n b\u00e2y gi\u1edd, t\u1ea1o m\u1ed9t project Elixir v\u00e0 code:\n\n\nMix\n l\u00e0 \"build tool\" c\u1ee7a Elixir, \u0111\u1ec3 t\u1ea1o m\u1ed9t project m\u1edbi, d\u00f9ng c\u00e2u l\u1ec7nh:\n\n\n mix new hello_familug\n* creating README.md\n* creating .gitignore\n* creating mix.exs\n* creating config\n* creating config/config.exs\n* creating lib\n* creating lib/hello_familug.ex\n* creating test\n* creating test/test_helper.exs\n* creating test/hello_familug_test.exs\n\nYour Mix project was created successfully.\nYou can use \"mix\" to compile it, test it, and more:\n\n    cd hello_familug\n    mix test\n\nRun \"mix help\" for more commands.\n\n\n\n\nS\u1eeda n\u1ed9i dung file \nlib/hello_familug.ex\n nh\u01b0 sau:\n\n\ndefmodule HelloFamilug do\n  def main(args) do\n    IO.puts \"Hello FAMILUG!\"\n  end\nend\n\n\n\n\nTh\u00eam d\u00f2ng:\n\n\n      escript: escript,\n\n\n\n\nv\u00e0o sau d\u00f2ng\n\n\n      elixir: \"~> VERSION\",\n\n\n\n\ntrong mix.exs.\n\n\nTh\u00eam function sau v\u00e0o trong file \nmix.exs\n\n\n  def escript do\n    [main_module: HelloFamilug]  # t\u00ean module s\u1ebd \u0111\u01b0\u1ee3c ch\u1ea1y\n  end\n\n\n\n\nCompile v\u00e0 ch\u1ea1y:\n\n\n$ mix escript.build\nCompiling 1 file (.ex)\nwarning: variable args is unused\n  lib/hello_familug.ex:2\n\nGenerated hello_familug app\nGenerated escript hello_familug with MIX_ENV=dev\n$ ./hello_familug\nHello FAMILUG!\n\n\n\n\nS\u1eeda l\u1ea1i code \u0111\u1ec3 nh\u1eadn v\u00e0o input t\u1eeb ng\u01b0\u1eddi d\u00f9ng:\n\n\ndefmodule HelloFamilug do\n  def main(args) do\n    {_, [name], _} = OptionParser.parse(args)\n    IO.puts \"Hello \" <> name\n  end\nend\n\n\n\n\nT\u1ea1m th\u1eddi b\u1ecf qua chi ti\u1ebft OptionParser.parse/1 l\u00e0m g\u00ec,\nbuild l\u1ea1i v\u00e0 g\u1ecdi v\u1edbi m\u1ed9t c\u00e1i t\u00ean:\n\n\n$ mix escript.build\nCompiling 1 file (.ex)\nGenerated escript hello_familug with MIX_ENV=dev\n$ ./hello_familug Python\nHello Python\n\n\n\n\nCh\u01b0\u01a1ng tr\u00ecnh d\u00f2ng l\u1ec7nh (CLI tool) kh\u00f4ng ph\u1ea3i l\u00e0 th\u1ebf m\u1ea1nh c\u1ee7a Elixir, nh\u01b0ng n\u00f3 ho\u00e0n to\u00e0n c\u00f3 th\u1ec3 l\u00e0m \u0111\u01b0\u1ee3c v\u00e0 kh\u00f4ng h\u1ec1 ph\u1ee9c t\u1ea1p. V\u1edbi t\u1eebng \u1ea5y \u0111\u1ee7 \u0111\u1ec3 ta b\u1eaft \u0111\u1ea7u cu\u1ed9c h\u00e0nh tr\u00ecnh v\u00e0o nh\u1eefng gi\u1ea5c m\u01a1 s\u00e2u v\u00f4 t\u1eadn trong th\u1ebf gi\u1edbi c\u1ee7a nh\u00e0 gi\u1ea3 kim v\u00e0 Elixir (thu\u1ed1c ti\u00ean).\n\n\nFAQs\n\n\nT\u1ea1i sao t\u00ean l\u1ea1i nh\u1ea3m nh\u00ed v\u1eady \"h\u1ecdc Elixir trong m\u1ed9t gi\u1ea5c m\u01a1\"?\n\n\nV\u00ec vi\u1ec7c \u0111\u1ecdc ti\u1ebfng Anh \u1edf Vi\u1ec7t Nam r\u1ea5t \"th\u1ea3m ho\u1ea1\".\nCh\u1eef \"Python\" - r\u00f5 r\u00e0ng \u0111\u1ecdc l\u00e0 \"pai-thon\" th\u00ec ph\u1ea7n l\u1edbn l\u1eadp tr\u00ecnh vi\u00ean l\u1ea1i \u0111\u1ecdc l\u00e0 \"Pi-th\u00f4ng\". V\u1eady n\u00ean t\u00f4i \u0111\u1eb7t t\u00ean c\u00f3 v\u1ea7n \u0111\u1ec3 ng\u01b0\u1eddi h\u1ecdc c\u00f3 th\u1ec3 \u0111\u1ecdc \u0111\u00fang \"H\u1ecdc \ni l\u00edk s\u01a1\n trong m\u1ed9t gi\u1ea5c m\u01a1\".",
            "title": "Home"
        },
        {
            "location": "/#hoc-elixir-trong-mot-giac-mo",
            "text": "[BETA]  L\u00fd do b\u1ea1n th\u00edch h\u1ecdc Haskell, LISP, Erlang, Elixir, Ocaml, Scala... nh\u1eefng ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh h\u00e0m (functional programming language) c\u00f3 v\u1ebb hay ho, m\u00e0 kh\u00f4ng bao gi\u1edd th\u00e0nh c\u00f4ng l\u00e0 g\u00ec?  Sau \u0111\u00e2y l\u00e0 v\u00e0i l\u00fd do m\u00ecnh g\u1eb7p ph\u1ea3i:   Qu\u00e1 nhi\u1ec1u kh\u00e1i ni\u1ec7m m\u1edbi  Nh\u1ed3i nh\u00e9t h\u1ebft c\u00e1c kh\u00e1i ni\u1ec7m xong kh\u00f4ng c\u00f3 g\u00ec \u0111\u1ec3 l\u00e0m  Ch\u1ecdn ng\u00f4n ng\u1eef \"x\u1ecbn\" nh\u1ea5t: trong m\u1ea3nh \u0111\u1ea5t functional programming, r\u1ea5t nhi\u1ec1u c\u00e1i t\u00ean h\u1ea5p d\u1eabn kh\u00e1c nh\u01b0 Haskell, Ocaml, Racket, Scheme, CLisp, Scala,...   \u0110\u1ec3 kh\u1eafc ph\u1ee5c \u0111i\u1ec1u n\u00e0y, ta s\u1ebd:   Ch\u1ec9 t\u1eadp trung v\u00e0o nh\u1eefng kh\u00e1i ni\u1ec7m \u0111\u00e3 quen thu\u1ed9c, h\u1ecdc th\u1eadt nhanh, tra c\u1ee9u khi c\u1ea7n  C\u00f3 m\u1ed9t \u00fd t\u01b0\u1edfng \u0111\u1ec3 th\u1ef1c hi\u1ec7n  T\u1eadp trung v\u00e0o Elixir v\u00ec m\u1ed7i ng\u00f4n ng\u1eef \u0111\u1ec1u c\u00f3 \u0111i\u1ec3m m\u1ea1nh/ y\u1ebfu ri\u00eang, nh\u01b0ng khi n\u1eafm \u0111\u01b0\u1ee3c m\u1ed9t ng\u00f4n ng\u1eef, h\u1ecdc c\u00e1c ng\u00f4n ng\u1eef kh\u00e1c s\u1ebd tr\u1edf n\u00ean d\u1ec5 d\u00e0ng h\u01a1n nhi\u1ec1u do \u0111\u00e3 quen thu\u1ed9c c\u00e1c kh\u00e1i  ni\u1ec7m v\u00e0 l\u1ed1i t\u01b0 duy c\u1ee7a functional programming.   N\u1ebfu kh\u00f4ng c\u00f3 g\u00ec \u0111\u1ec3 l\u00e0m, nu\u1ed1t xong c\u00e1c kh\u00e1i ni\u1ec7m, 1 tu\u1ea7n sau b\u1ea1n s\u1ebd l\u1ea1i qu\u00ean.  Elixir/Erlang ho\u00e0n to\u00e0n \u0111\u1ee7 kh\u1ea3 n\u0103ng \u0111\u1ec3 cho b\u1ea1n l\u1eadp tr\u00ecnh loanh quanh m\u1ea5y thu\u1eadt to\u00e1n, gi\u1ea3i c\u00e1c b\u00e0i to\u00e1n / v\u1ea5n \u0111\u1ec1 tr\u00ean HackerRank. Nh\u01b0ng \u0111i\u1ec3m s\u00e1ng c\u1ee7a ng\u00f4n ng\u1eef n\u00e0y, th\u1ef1c ra ch\u1ec9 to\u1ea3 s\u00e1ng khi ta d\u00f9ng n\u00f3 \u0111\u1ec3 ph\u00e1t tri\u1ec3n c\u00e1c h\u1ec7 th\u1ed1ng l\u1edbn, c\u1ea7n ch\u1ea1y ph\u00e2n t\u00e1n, hay ch\u1ea1y song song... \u00cdt khi m\u1ed9t ng\u01b0\u1eddi s\u1ebd l\u00e0m h\u1eb3n m\u1ed9t project l\u1edbn nh\u01b0 v\u1eady. V\u00ec v\u1eady, ta th\u01b0\u1eddng kh\u00f4ng c\u00f3 \u0111\u1ea5t d\u00f9ng cho Elixir hay Erlang.  M\u1ed9t c\u00e1ch \u1ee9ng d\u1ee5ng \u0111\u1ec3 ch\u01a1i v\u1edbi ng\u00f4n ng\u1eef m\u1edbi n\u1eefa \"nh\u1ecf h\u01a1n\", l\u00e0 vi\u1ebft c\u00e1c c\u00e2u l\u1ec7nh th\u1ef1c hi\u1ec7n m\u1ed9t vi\u1ec7c g\u00ec \u0111\u00f3 (CLI). V\u1eady nh\u01b0ng Elixir/Erlang kh\u00f4ng to\u1ea3 s\u00e1ng/ \u0111\u01a1n gi\u1ea3n trong c\u00f4ng vi\u1ec7c n\u00e0y, n\u00f3 C\u00d3 TH\u1ec2 l\u00e0m \u0111\u01b0\u1ee3c, nh\u01b0ng tr\u00ean th\u1ef1c t\u1ebf kh\u00f4ng m\u1ea5y ai l\u00e0m.  V\u00ed d\u1ee5 standard khi h\u1ecdc Erlang l\u00e0 l\u00e0m m\u1ed9t h\u1ec7 th\u1ed1ng chat. Tr\u00ean th\u1ef1c t\u1ebf, h\u1ec7 th\u1ed1ng chat c\u1ee7a \"Whatsapp\" \u0111\u01b0\u1ee3c vi\u1ebft b\u1eb1ng Erlang  h\u1ec7 th\u1ed1ng n\u00e0y \u0111\u00e3 \u0111\u01b0\u1ee3c b\u00e1n l\u1ea1i cho FaceBook v\u1edbi gi\u00e1 19 T\u1ef6 \u0111\u00f4 la M\u1ef9  (PS: FaceBook tr\u01b0\u1edbc \u0111\u00f3 c\u0169ng \u0111\u00e3 mua l\u1ea1i Instagram - m\u1ed9t h\u1ec7 th\u1ed1ng vi\u1ebft b\u1eb1ng Django/Python v\u1edbi gi\u00e1 1 T\u1ef6 \u0111\u00f4 la M\u1ef9)  Ta c\u00f3 th\u1ec3 l\u00e0m 1 website sau khi h\u1ecdc Elixir, \u0111\u00e2y l\u00e0 l\u0129nh v\u1ef1c hi\u1ec7n t\u1ea1i m\u00e0 Elixir m\u1ea1nh nh\u1ea5t.  \u0110\u00e3 xong ph\u1ea7n \u00fd t\u01b0\u1edfng, b\u00e2y gi\u1edd h\u00e3y h\u1ecdc Elixir.  Th\u1ef1c hi\u1ec7n tr\u00ean:  $ elixir --version\nErlang/OTP 19 [erts-8.0.2] [source] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]\n\nElixir 1.3.2  PS: trong b\u00e0i c\u00f3 m\u1ed9t s\u1ed1 \u0111o\u1ea1n so s\u00e1nh v\u1edbi t\u00ednh n\u0103ng t\u01b0\u01a1ng t\u1ef1 tr\u00ean Python - b\u1edfi t\u00e1c gi\u1ea3 l\u00e0 ng\u01b0\u1eddi c\u00f3 kinh nghi\u1ec7m v\u1edbi Python - gi\u00fap c\u00e1c l\u1eadp tr\u00ecnh vi\u00ean Python d\u1ec5 k\u1ebft n\u1ed1i c\u00e1c kh\u00e1i ni\u1ec7m. Ph\u1ea7n so s\u00e1nh n\u00e0y ho\u00e0n to\u00e0n kh\u00f4ng c\u1ea7n thi\u1ebft v\u1edbi ng\u01b0\u1eddi kh\u00f4ng bi\u1ebft Python v\u00e0 c\u00f3 th\u1ec3 b\u1ecf qua.",
            "title": "H\u1ecdc Elixir trong m\u1ed9t gi\u1ea5c m\u01a1"
        },
        {
            "location": "/#cac-kieu-du-lieu-co-ban",
            "text": "",
            "title": "C\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n"
        },
        {
            "location": "/#integer",
            "text": "iex(33)> 42\n42\niex(34)> i 42\nTerm\n  42\nData type\n  Integer\nReference modules\n  Integer\n\nD\u00f9ng ``i OBJECT`` \u0111\u1ec3 hi\u1ec3n th\u1ecb th\u00f4ng tin v\u1ec1 gi\u00e1 tr\u1ecb/ ki\u1ec3u c\u1ee7a object. Nh\u01b0 \"type(object)\" trong Python hay \"typeof object\" trong JavaScript.",
            "title": "Integer"
        },
        {
            "location": "/#float",
            "text": "iex(35)> i 3.14\nTerm\n  3.14\nData type\n  Float\nReference modules\n  Float\n\niex(36)> 0.1 + 0.1 + 0.1\n0.30000000000000004",
            "title": "Float"
        },
        {
            "location": "/#atom",
            "text": "iex(39)> i true\nTerm\n  true\nData type\n  Atom\nReference modules\n  Atom\niex(40)> i false\nTerm\n  false\nData type\n  Atom\nReference modules\n  Atom",
            "title": "Atom"
        },
        {
            "location": "/#string",
            "text": "iex(42)> i \"Elixir\"\nTerm\n  \"Elixir\"\nData type\n  BitString\nByte size\n  6\nDescription\n  This is a string: a UTF-8 encoded binary. It's printed surrounded by\n  \"double quotes\" because all UTF-8 encoded codepoints in it are printable.\nRaw representation\n  <<69, 108, 105, 120, 105, 114>>\nReference modules\n  String, :binary  C\u00e1c ki\u1ec3u d\u1eef li\u1ec7u ch\u1ee9a \u0111\u01b0\u1ee3c ki\u1ec3u kh\u00e1c: list, tuple, dict",
            "title": "String"
        },
        {
            "location": "/#list",
            "text": "iex(44)> i 'abc'\nTerm\n  'abc'\nData type\n  List\nDescription\n  This is a list of integers that is printed as a sequence of characters\n  delimited by single quotes because all the integers in it represent valid\n  ASCII characters. Conventionally, such lists of integers are referred to as\n  \"charlists\" (more precisely, a charlist is a list of Unicode codepoints,\n  and ASCII is a subset of Unicode).\nRaw representation\n  [97, 98, 99]\nReference modules\n  List\n\n\niex(45)> i [1,2,3,3.14]\nTerm\n  [1, 2, 3, 3.14]\nData type\n  List\nReference modules\n  List\n\niex(46)> i []\nTerm\n  []\nData type\n  List\nReference modules\n  List  M\u1ed9t list c\u00f3 th\u1ec3 ch\u1ee9a b\u1ea5t k\u1ef3 ki\u1ec3u d\u1eef li\u1ec7u n\u00e0o:  iex(6)> i [\"abc\", 1]\nTerm\n  [\"abc\", 1]\nData type\n  List\nReference modules\n  List  V\u1edbi list ch\u1ee9a c\u00e1c ph\u1ea7n t\u1eed tuple-2 {atom: value}, Elixir h\u1ed7 tr\u1ee3 th\u00eam c\u00fa ph\u00e1p ng\u1eafn g\u1ecdn \u0111\u1ec3 t\u1ea1o ra list n\u00e0y v\u00e0 g\u1ecdi l\u00e0 \"keyword list\" (b\u1ea3n ch\u1ea5t v\u1eabn l\u00e0 1 list b\u00ecnh th\u01b0\u1eddng):  iex(38)> [{:name, \"PyMi\"}, {:est, 2015}]\n[name: \"PyMi\", est: 2015]\niex(39)> [name: \"PyMi\", est: 2015]\n[name: \"PyMi\", est: 2015]\n\niex(38)> [{:name, \"PyMi\"}, {:est, 2015}]\n[name: \"PyMi\", est: 2015]\niex(39)> [name: \"PyMi\", est: 2015]\n[name: \"PyMi\", est: 2015]",
            "title": "List"
        },
        {
            "location": "/#tuple",
            "text": "iex(48)> i {100, 'abc'}\nTerm\n  {100, 'abc'}\nData type\n  Tuple\nReference modules\n  Tuple\niex(49)> i {}\nTerm\n  {}\nData type\n  Tuple\nReference modules\n  Tuple  Kh\u00f4ng gi\u1ed1ng Python, trong Elixir, T\u1ea4T C\u1ea2 c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u \u0111\u1ec1u l\u00e0 immutable, t\u1ee9c m\u1ed9t khi \u0111\u00e3 t\u1ea1o ra, kh\u00f4ng th\u1ec3 thay \u0111\u1ed5i. Mu\u1ed1n \"thay \u0111\u1ed5i\", ta ph\u1ea3i t\u1ea1o m\u1edbi.  Tr\u00ean Python, nh\u1eefng \u0111i\u1ec1u sau \u0111\u1ec1u c\u00f3 th\u1ec3 l\u00e0m tr\u00ean list hay tuple:\n- duy\u1ec7t qua t\u1eebng ph\u1ea7n t\u1eed (loop)\n- truy c\u1eadp index\n- slice \u0111\u1ec3 thu \u0111\u01b0\u1ee3c m\u1ed9t t\u1eadp con  S\u1ef1 gi\u1ed1ng nhau v\u1ec1 t\u00ednh n\u0103ng khi\u1ebfn ng\u01b0\u1eddi d\u00f9ng th\u01b0\u1eddng h\u1ecfi khi n\u00e0o d\u00f9ng list, khi n\u00e0o d\u00f9ng tuple.\nV\u1edbi Python, ta c\u00f3 th\u1ec3 thay \u0111\u1ed5i 1 list, nh\u01b0ng kh\u00f4ng th\u1ec3 thay \u0111\u1ed5i m\u1ed9t tuple sau khi \u0111\u00e3 t\u1ea1o ra n\u00f3.\nV\u1edbi Elixir, c\u1ea3 list v\u00e0 tuple \u0111\u1ec1u kh\u00f4ng th\u1ec3 thay \u0111\u1ed5i \u0111\u01b0\u1ee3c (immutable).\n\u0110\u1eb7c \u0111i\u1ec3m n\u00e0y s\u1ebd gi\u00fap th\u1ea5y r\u00f5 h\u01a1n khi n\u00e0o d\u00f9ng tuple v\u00e0 khi n\u00e0o n\u00ean d\u00f9ng list:\n- list TH\u01af\u1edcNG d\u00f9ng \u0111\u1ec3 ch\u1ee9a c\u00e1c d\u1eef li\u1ec7u t\u01b0\u01a1ng t\u1ef1 nhau (heterogenious)\n- tuple th\u01b0\u1eddng \u0111\u1ec3 ch\u1ee9a c\u00e1c th\u00f4ng tin li\u00ean quan \u0111\u1ebfn nhau, nh\u01b0 c\u00e1c c\u1ed9t trong 1 d\u00f2ng c\u1ee7a database, c\u00e1c to\u1ea1 \u0111\u1ed9 c\u1ee7a m\u1ed9t \u0111i\u1ec3m, c\u00e1c \u0111\u1eb7c t\u00ednh c\u1ee7a m\u1ed9t con m\u00e8o...  Khi \u0111\u00f3, ta s\u1ebd th\u01b0\u1eddng loop qua 1 list, v\u00e0 th\u01b0\u1eddng truy c\u1eadp \u0111\u1ebfn c\u00e1c ph\u1ea7n t\u1eed c\u1ee7a tuple th\u00f4ng qua indexing/unpacking.  iex(52)> person = {\"HVN\", 27, \"Python\"}\n{\"HVN\", 27, \"Python\"}\niex(53)> {name, age, language} = person\n{\"HVN\", 27, \"Python\"}\niex(54)> name\n\"HVN\"  http://elixir-lang.org/getting-started/basic-types.html#lists-or-tuples\nhttp://stackoverflow.com/questions/31192923/lists-vs-tuples-what-to-use-and-when",
            "title": "Tuple"
        },
        {
            "location": "/#map-dictionary",
            "text": "iex(51)> i %{\"name\": \"FAMILUG\"}\nTerm\n  %{name: \"FAMILUG\"}\nData type\n  Map\nReference modules\n  Map",
            "title": "Map (dictionary)"
        },
        {
            "location": "/#cac-thao-tac-co-ban-voi-cac-kieu-du-lieu",
            "text": "",
            "title": "C\u00e1c thao t\u00e1c c\u01a1 b\u1ea3n v\u1edbi c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u"
        },
        {
            "location": "/#thao-tac-voi-string",
            "text": "Ki\u1ec3m tra string con:   iex(9)> String.contains?(\"Python\", \"on\")\ntrue\niex(10)> String.contains?(\"Python\", \"ON\")\nfalse  Ch\u00fa \u00fd t\u00ean function c\u00f3 d\u1ea5u ?   Ki\u1ec3m tra b\u1eaft \u0111\u1ea7u v\u00e0 k\u1ebft th\u00fac:   iex(11)> String.starts_with?(\"Python\", \"Py\")\ntrue\niex(12)> String\nString      StringIO\niex(12)> String.ends_with?(\"Python.mp3\", \".mp3\")\ntrue  D\u1ec5 th\u1ea5y, nh\u1eefng function tr\u1ea3 v\u1ec1 true/false \u0111\u1ec1u \u0111\u01b0\u1ee3c \u0111\u1eb7t t\u00ean k\u1ebft th\u00fac b\u1eb1ng d\u1ea5u ?    L\u1ea5y index #TODO    N\u1ed1i c\u00e1c ph\u1ea7n t\u1eed c\u1ee7a list (KH\u00d4NG TH\u1ec2 N\u1ed0I TUPLE):    iex(55)> Enum.join([\"Python\", \"PyMi.vn\"], \" \")\n\"Python PyMi.vn\"\niex(57)> [\"Elixir\", \"PyMi.vn\"] |> Enum.join(\"+\")\n\"Elixir+PyMi.vn\"\niex(61)> \"H\u1ecdc Python\" <> \" \" <> \"t\u1ea1i PyMi.vn\"\n\"H\u1ecdc Python t\u1ea1i PyMi.vn\"\n\niex(7)> Enum.join {1, 2}\n** (Protocol.UndefinedError) protocol Enumerable not implemented for {1, 2}\n    (elixir) lib/enum.ex:1: Enumerable.impl_for!/1\n    (elixir) lib/enum.ex:116: Enumerable.reduce/3\n    (elixir) lib/enum.ex:1636: Enum.reduce/3\n    (elixir) lib/enum.ex:1154: Enum.join/2\niex(7)> Enum.join [1, 2]\n\"12\"   C\u1eaft string, bi\u1ebfn th\u00e0nh list:   iex(63)> String.split(\"M\u00ecnh th\u00edch th\u00ec m\u00ecnh h\u1ecdc \\tth\u00f4i\", \" \")\n[\"M\u00ecnh\", \"th\u00edch\", \"th\u00ec\", \"m\u00ecnh\", \"h\u1ecdc\", \"\\tth\u00f4i\"]\niex(64)> String.split(\"M\u00ecnh th\u00edch th\u00ec m\u00ecnh     h\u1ecdc \\tth\u00f4i\")\n[\"M\u00ecnh\", \"th\u00edch\", \"th\u00ec\", \"m\u00ecnh\", \"h\u1ecdc\", \"th\u00f4i\"]  Gi\u1ed1ng nh\u01b0 Python.  Nh\u01b0ng Elixir c\u00f2n c\u00f3 th\u1ec3 Split t\u1ea1i nhi\u1ec1u \"separator\":  iex(7)> String.split(\"a-b+c\", [\"-\", \"+\"])\n[\"a\", \"b\", \"c\"]   trim/trim_leading/trim_trailing   iex(14)> String.trim(\"   a\\t abc\\n\")\n\"a\\t abc\"\niex(15)> String.trim_leading(\"   a\\t abc\\n\")\n\"a\\t abc\\n\"\niex(16)> String.trim_trailing(\"   a\\t abc\\n\")\n\"   a\\t abc\"   replace   iex(17)> String.replace(\"Python\", \"Py\", \"Jy\")\n\"Jython\"   Ch\u1eef hoa, ch\u1eef th\u01b0\u1eddng:   iex(18)> String.upcase(\"Python\")\n\"PYTHON\"\niex(19)> String.downcase(\"PYThon\")\n\"python\"\niex(20)> String.capitalize(\"python is an animal\")\n\"Python is an animal\"   Bi\u1ebfn th\u00e0nh ki\u1ec3u integer   iex(22)> String.to_integer(\"   42  \")\n** (ArgumentError) argument error\n    :erlang.binary_to_integer(\"   42  \")\niex(22)> String.to_integer(\"42\")\n42  Function n\u00e0y trong Elixir kh\u00f4ng c\u00f3 kh\u1ea3 n\u0103ng b\u1ecf \u0111i whitespace nh\u01b0 Python:  In [1]: int(\"   42 \\n\\t   \")\nOut[1]: 42   L\u1ea5y \u0111\u1ed9 d\u00e0i   iex(59)>  String.length(\"L\u1ea1c tr\u00f4i\")\n8\niex(60)>  String.length(\"L\u1ea1c tr\u00f4i\ud83d\ude1d\")\n9   Slice: slice(string, start, len)   iex(1)> String.slice(\"Python\", 0, 2)\n\"Py\"\niex(2)> String.slice(\"Python\", 2, 10)\n\"thon\"   \u0110\u1ea3o ng\u01b0\u1ee3c:   iex(4)> String.reverse(\"DOICAN\")\n\"NACIOD\"  https://hexdocs.pm/elixir/1.4.2/String.html#content",
            "title": "Thao t\u00e1c v\u1edbi String"
        },
        {
            "location": "/#list_1",
            "text": "S\u1eed d\u1ee5ng module  List . C\u00e1c function c\u00f3 s\u1eb5n c\u1ee7a module List kh\u00f4ng gi\u1ed1ng nh\u01b0 trong Python, b\u1edfi List trong Python c\u00f3 th\u1ec3 thay \u0111\u1ed5i \u0111\u01b0\u1ee3c (th\u00eam b\u1edbt, s\u1eeda ph\u1ea7n t\u1eed) c\u00f2n List trong Elixir th\u00ec kh\u00f4ng.   T\u1ea1o list   iex(8)> li = [1, \"PyMi\", \"Python\", \"Elixir\"]\n[1, \"PyMi\", \"Python\", \"Elixir\"]\niex(10)> i li\nTerm\n  [1, \"PyMi\", \"Python\", \"Elixir\"]\nData type\n  List\nReference modules\n  List   L\u1ea5y \u0111\u1ea7u (head)   iex(11)> hd li\n1   L\u1ea5y \u0111u\u00f4i (tail)   iex(12)> tl li\n[\"PyMi\", \"Python\", \"Elixir\"]   L\u1ea5y \u0111\u1ea7u v\u00e0 \u0111u\u00f4i:   iex(24)> [head | tail] = [\"Python\", \"PyMi\", \"Golang\", \"FAMILUG.org\"]\n[\"Python\", \"PyMi\", \"Golang\", \"FAMILUG.org\"]\niex(25)> head\n\"Python\"\niex(26)> tail\n[\"PyMi\", \"Golang\", \"FAMILUG.org\"]   Ki\u1ec3m tra s\u1ed1 ph\u1ea7n t\u1eed   iex(14)> length li\n4   Ki\u1ec3m tra m\u1ed9t ph\u1ea7n t\u1eed c\u00f3 trong list kh\u00f4ng   iex(5)> Enum.member?([1,2,4], 3)\nfalse  Hay d\u00f9ng c\u00fa ph\u00e1p  left in right :  iex(21)> 1 in [1, 2, 3]\ntrue  Ch\u00fa \u00fd c\u00fa ph\u00e1p  in  n\u00e0y kh\u00f4ng ho\u1ea1t \u0111\u1ed9ng v\u1edbi tuple, map (nh\u01b0 trong Python).  iex(21)> 1 in {1, 2, 3}\n** (Protocol.UndefinedError) protocol Enumerable not implemented for {1, 2, 3}\n    (elixir) lib/enum.ex:1: Enumerable.impl_for!/1\n    (elixir) lib/enum.ex:131: Enumerable.member?/2\n    (elixir) lib/enum.ex:1352: Enum.member?/2\niex(22)> :a in %{:a => value}\n** (CompileError) iex:22: undefined function value/0\n    (elixir) expanding macro: Kernel.in/2\n             iex:22: (file)   N\u1ed1i 2 list  concatenate   iex(18)> li ++ [2, \"Erlang\"]\n[1, \"PyMi\", \"Python\", \"Elixir\", 2, \"Erlang\"]   Tr\u1eeb 2 list  subtract   iex(22)> [1, 2, 3, 2, 1] -- [2]\n[1, 3, 2, 1]\niex(23)> [1, 2, 3, 2, 1] -- [2, 3]\n[1, 2, 1]   \"Th\u00eam\" ph\u1ea7n t\u1eed v\u00e0o list: th\u1ef1c ra l\u00e0 t\u1ea1o m\u1ed9t list m\u1edbi\nTh\u00eam \"Zero\" v\u00e0o index 0   iex(21)> List.insert_at(li, 0, \"Zero\")\n[\"Zero\", 1, \"PyMi\", \"Python\", \"Elixir\"]   \"Th\u00eam\" m\u1ed9t ph\u1ea7n t\u1eed v\u00e0o \u0111\u1ea7u list (si\u00eau t\u1ed1c - constant time O(1)):   iex(27)> l3 = [\"Python\", \"PyMi\", \"Golang\", \"FAMILUG.org\"]\n[\"Python\", \"PyMi\", \"Golang\", \"FAMILUG.org\"]\niex(28)> [\"h\" | l3]\n[\"h\", \"Python\", \"PyMi\", \"Golang\", \"FAMILUG.org\"]   \"Th\u00eam\" m\u1ed9t ph\u1ea7n t\u1eed xu\u1ed1ng cu\u1ed1i list (ch\u1eadm, linear time O(n))   iex(30)> l3 ++ [\"t\"]\n[\"Python\", \"PyMi\", \"Golang\", \"FAMILUG.org\", \"t\"]   Thay m\u1ed9t ph\u1ea7n t\u1eed c\u1ee7a list t\u1ea1i 1 index:   iex(33)> List.replace_at([\"Python\", \"PyMi\", \"Golang\", \"FAMILUG.org\", \"t\"], 2, \"Elixir\")\n[\"Python\", \"PyMi\", \"Elixir\", \"FAMILUG.org\", \"t\"]   \"Xo\u00e1\" ph\u1ea7n t\u1eed kh\u1ecfi list (d\u00f9ng value c\u1ee7a ph\u1ea7n t\u1eed v\u00e0 d\u00f9ng index):   iex(31)> List.delete([\"Python\", \"PyMi\", \"Golang\", \"FAMILUG.org\", \"t\"], \"Golang\")\n[\"Python\", \"PyMi\", \"FAMILUG.org\", \"t\"]\niex(32)> List.delete_at([\"Python\", \"PyMi\", \"Golang\", \"FAMILUG.org\", \"t\"], 2)\n[\"Python\", \"PyMi\", \"FAMILUG.org\", \"t\"]   L\u1ea5y m\u1ed9t list con t\u1eeb list (slice):\nslice(enumerable, start, amount)   iex(36)>  Enum.slice([\"Python\", \"PyMi\", \"Elixir\", \"FAMILUG.org\"], 1, 10)\n[\"PyMi\", \"Elixir\", \"FAMILUG.org\"]   S\u1eafp x\u1ebfp 1 list   Theo b\u1ea3ng ch\u1eef c\u00e1i  iex(37)> Enum.sort([\"Python\", \"PyMi\", \"Elixir\", \"FAMILUG.org\", \"t\"])\n[\"Elixir\", \"FAMILUG.org\", \"PyMi\", \"Python\", \"t\"]  Theo ti\u00eau ch\u00ed nh\u1ea5t \u0111\u1ecbnh (function)  iex(35)> Enum.sort_by([\"Python\", \"PyMi\", \"Elixir\", \"FAMILUG.org\", \"t\"], &String.length/1)\n[\"t\", \"PyMi\", \"Python\", \"Elixir\", \"FAMILUG.org\"]  https://hexdocs.pm/elixir/Enum.html#content",
            "title": "List"
        },
        {
            "location": "/#map",
            "text": "l\u00e0 m\u1ed9t c\u1ea5u tr\u00fac d\u1eef li\u1ec7u c\u00f3 th\u1ec3 g\u1ecdi l\u00e0 \"key-value\" store.\nT\u00ean kh\u00e1c (trong ng\u00f4n ng\u1eef kh\u00e1c): dictionary, associative array  map = %{:a => 1, :b => 2}   T\u1ea1o map:\n%{key => value1, key => value2}   iex(47)>  %{:a => 1, :b =>2}\n%{a: 1, b: 2}\niex(48)> %{\"name\" => \"PYMI\", \"country\" => \"VN\"}\n%{\"country\" => \"VN\", \"name\" => \"PYMI\"}   \u0110\u1ebfm s\u1ed1 ph\u1ea7n t\u1eed  Truy c\u1eadp value:   iex(68)> %{:name => who} = %{:name => \"HVN\"}\n%{name: \"HVN\"}\niex(69)> who\n\"HVN\"\n\niex(44)> map = %{:a => 1, :b =>2}\n%{a: 1, b: 2}\niex(46)> map[:b]\n2\niex(47)> map[:c]\nnil  Hay  iex(60)> Map.get(map, :b)\n2  Truy c\u1eadp 1 key kh\u00f4ng t\u1ed3n t\u1ea1i s\u1ebd tr\u1ea3 v\u1ec1 nil.   Ki\u1ec3m tra key c\u00f3 trong map kh\u00f4ng   iex(3)> Map.has_key?(%{:name => \"HVN\"}, :age)\nfalse   \"Th\u00eam\" key-value m\u1edbi:   iex(62)> Map.put(%{:a => 1}, :h, 4)\n%{a: 1, h: 4}   Xo\u00e1 key-value:   iex(1)> Map.delete(%{:name => \"HVN\", :age => 27}, :age)\n%{name: \"HVN\"}  Xo\u00e1 key kh\u00f4ng t\u1ed3n t\u1ea1i kh\u00f4ng \u1ea3nh h\u01b0\u1edfng g\u00ec:  iex(2)> Map.delete(%{:name => \"HVN\", :age => 27}, :language)\n%{age: 27, name: \"HVN\"}    Duy\u1ec7t qua t\u1eebng key # TODO    Bi\u1ebfn th\u00e0nh list c\u00e1c tuple key-value:    iex(63)> Map.to_list(%{:name => \"HVN\", :age => 27})\n[age: 27, name: \"HVN\"]   Update value c\u1ee7a 1 key \u0111\u00e3 trong map (kh\u00f4ng th\u00eam):   iex(65)> %{ map | :b => 5}\n%{a: 1, b: 5}\niex(66)> %{ map | :c => 5}\n** (KeyError) key :c not found in: %{a: 1, b: 2}   Truy c\u1eadp c\u00e1c atom key b\u1eb1ng  . :   iex(66)> student = %{:name => \"HVN\"}\n%{name: \"HVN\"}\niex(67)> student.name\n\"HVN\"   Update value nested dict v\u1edbi  put_in/2 :   iex(70)> users = [hvn: %{name: \"HVN\", age: 27, language: [\"Erlang\", \"Elixir\", \"Python\"]},\nhails: %{name: \"HaiLS\", age: 26, language: [\"Golang\", \"JS\"]}]\n[hvn: %{age: 27, language: [\"Erlang\", \"Elixir\", \"Python\"], name: \"HVN\"},\n hails: %{age: 26, language: [\"Golang\", \"JS\"], name: \"HaiLS\"}]\n\niex(72)> put_in users[:hvn].age, 29\n[hvn: %{age: 29, language: [\"Erlang\", \"Elixir\", \"Python\"], name: \"HVN\"},\n hails: %{age: 26, language: [\"Golang\", \"JS\"], name: \"HaiLS\"}]  M\u1ed7i ki\u1ec3u d\u1eef li\u1ec7u \u0111\u1ec1u c\u00f3 m\u1ed9t module t\u01b0\u01a1ng \u1ee9ng cung c\u1ea5p c\u00e1c function c\u1ea7n thi\u1ebft: List, Map, String. Module  Enum  d\u00f9ng chung cho c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u cho ph\u00e9p duy\u1ec7t qua t\u1eebng ph\u1ea7n t\u1eed: nh\u01b0  List ,  String .",
            "title": "Map"
        },
        {
            "location": "/#pattern-matching",
            "text": "=  : the match operator\n- Khi g\u00e1n bi\u1ebfn, bi\u1ebfn ph\u1ea3i n\u1eb1m b\u00ean tr\u00e1i d\u1ea5u  =  iex(7)> x = 5\n5\niex(8)> 6 = y\n** (CompileError) iex:8: undefined function y/0   V\u1ebf tr\u00e1i c\u00f3 th\u1ec3 l\u00e0 ki\u1ec3u d\u1eef li\u1ec7u ph\u1ee9c t\u1ea1p h\u01a1n, d\u00f9ng \u0111\u1ec3 \"destructuring\" hay \"unpacking\" d\u1eef li\u1ec7u ph\u00eda tay ph\u1ea3i.\nS\u1ed1 ph\u1ea7n t\u1eed 2 b\u00ean ph\u1ea3i b\u1eb1ng nhau, c\u00f9ng ki\u1ec3u:   iex(18)> {name, age} = {\"PyMI.vn\", 2}\n{\"PyMI.vn\", 2}\niex(19)> name\n\"PyMI.vn\"\niex(20)> age\n2\n\niex(1)> [x, y, z] = [1, 2, 4]  # list\n[1, 2, 4]\niex(2)> x\n1\niex(3)> z\n4  Khi b\u00ean ph\u1ea3i ch\u1ee9a gi\u00e1 tr\u1ecb thay v\u00ec bi\u1ebfn, 2 b\u00ean ch\u1ec9 match nhau n\u1ebfu gi\u00e1 tr\u1ecb b\u00ean tay tr\u00e1i match gi\u00e1 tr\u1ecb b\u00ean tay ph\u1ea3i:  iex(4)> {:ok, 1, salary} = {:ok, 1, 15}\n{:ok, 1, 15}\niex(5)> {:ok, 1, income} = {:ok, 3, 20}\n** (MatchError) no match of right hand side value: {:ok, 3, 20}\n\niex(10)> {x, x} = {1, 1}\n{1, 1}\niex(11)> {x, x} = {1, 2}\n** (MatchError) no match of right hand side value: {1, 2}  Khi 2 b\u00ean kh\u00f4ng \"match\", MatchError s\u1ebd x\u1ea3y ra.   Matching v\u1edbi c\u00fa ph\u00e1p [head | tail]:   iex(5)> [h | t] = [1, 2, 3, 4]\n[1, 2, 3, 4]\niex(6)> h\n1\niex(7)> t\n[2, 3, 4]  Gi\u1ed1ng nh\u01b0 g\u1ecdi function  hd  v\u00e0  tl :  iex(8)> hd [1, 2, 3, 4]\n1\niex(9)> tl [1, 2, 3, 4]\n[2, 3, 4]  C\u00fa ph\u00e1p n\u00e0y r\u00f5 r\u00e0ng kh\u00f4ng match list r\u1ed7ng:  iex(10)> [h | t] = []\n** (MatchError) no match of right hand side value: []   Truy c\u1eadp gi\u00e1 tr\u1ecb c\u1ee7a m\u1ed9t bi\u1ebfn thay v\u00ec g\u00e1n l\u1ea1i n\u00f3 b\u1eb1ng  ^  - pin operator:   iex(11)> x = 5\n5\niex(12)> x = 7\n7\niex(13)> x\n7\niex(14)> ^x = 8\n** (MatchError) no match of right hand side value: 8\nV\u00ec gi\u1ed1ng nh\u01b0 vi\u1ebft: 7 = 8\niex(14)> 7 = 8\n** (MatchError) no match of right hand side value: 8",
            "title": "Pattern matching"
        },
        {
            "location": "/#control-flow-case-cond-if-unless-doend",
            "text": "",
            "title": "Control flow: case, cond, if, unless, do/end"
        },
        {
            "location": "/#if",
            "text": "if/2 l\u00e0 m\u1ed9t function, t\u1ee9c n\u00f3 s\u1ebd tr\u1ea3 v\u1ec1 m\u1ed9t gi\u00e1 tr\u1ecb sau khi ch\u1ea1y. Kh\u00e1c v\u1edbi Python hay nhi\u1ec1u ng\u00f4n ng\u1eef kh\u00e1c, if trong Python l\u00e0 m\u1ed9t \"statement\" (c\u00e2u l\u1ec7nh), v\u00e0 n\u00f3 ch\u1ec9 th\u1ef1c hi\u1ec7n \u0111i\u1ec1u khi\u1ec3n lu\u1ed3ng ch\u1ee9 kh\u00f4ng tr\u1ea3 v\u1ec1 gi\u00e1 tr\u1ecb n\u00e0o.\n(PS: th\u1ef1c s\u1ef1 if/2 m\u00e0 1 macro - kh\u00e1i ni\u1ec7m macro s\u1ebd \u0111\u01b0\u1ee3c n\u00f3i sau)  iex(15)> k = if 5 > 4 do\n...(15)> \"yeah\"\n...(15)> end\n\"yeah\"\niex(16)> k\n\"yeah\"  if/2 tr\u1ea3 v\u1ec1 nil n\u1ebfu \u0111i\u1ec1u ki\u1ec7n n\u00f3 nh\u1eadn \u0111\u01b0\u1ee3c tr\u1ea3 v\u1ec1 false hay nil.  iex(17)> h = if 5 < 4 do\n...(17)> \"hey\"\n...(17)> end\nnil\niex(18)> h\nnil  M\u1eabu c\u00fa ph\u00e1p:  if condition do\nSOMETHING\nend  if  c\u00f3 th\u1ec3 \u0111i k\u00e8m v\u1edbi  else :  iex(19)> m = if 5 < 4 do\n...(19)> \"smaller\"\n...(19)> else\n...(19)> \"bigger\"\n...(19)> end\n\"bigger\"\niex(20)> m\n\"bigger\"  Trong Elixir ch\u1ec9 c\u00f3  if/else/end  kh\u00f4ng c\u00f3 elif nh\u01b0 trong Python, khi c\u1ea7n x\u1eed l\u00fd nhi\u1ec1u tr\u01b0\u1eddng h\u1ee3p, ta c\u00f3 th\u1ec3 d\u00f9ng cond.  \u0110\u1ecdc th\u00eam: https://hexdocs.pm/elixir/Kernel.html#if/2",
            "title": "if"
        },
        {
            "location": "/#cond",
            "text": "cond do ... end  cho ph\u00e9p x\u1eed l\u00fd nhi\u1ec1u \u0111i\u1ec1u ki\u1ec7n, gi\u1ed1ng nh\u01b0 elif hay else if trong c\u00e1c ng\u00f4n ng\u1eef kh\u00e1c:  iex(24)> x = 18\n18\niex(25)> cond do\n...(25)>   x < 18 ->\n...(25)>     \"Not permitted\"\n...(25)>   x == 18 ->\n...(25)>     \"Okay\"\n...(25)>   x > 18 ->\n...(25)>     \"Too old\"\n...(25)> end\n\"Okay\"",
            "title": "cond"
        },
        {
            "location": "/#unless",
            "text": "Nh\u01b0 if, nh\u01b0ng ng\u01b0\u1ee3c l\u1ea1i.  iex(26)> x = 18\n18\niex(27)> unless x < 18 do\n...(27)>   \"got this\"\n...(27)> end\n\"got this\"\niex(28)> if x < 18 do\n...(28)>   \"no\"\n...(28)> end\nnil",
            "title": "unless"
        },
        {
            "location": "/#case",
            "text": "case  s\u1eed d\u1ee5ng pattern matching, v\u00e0 ch\u1ec9 d\u1eebng l\u1ea1i khi ta t\u00ecm th\u1ea5y gi\u00e1 tr\u1ecb n\u00e0o match. Ta th\u1ea5y  case  ch\u1ec9 d\u00f9ng \u0111\u1ec3 ki\u1ec3m tra xem 1 gi\u00e1 tr\u1ecb c\u00f3 b\u1eb1ng m\u1ed9t gi\u00e1 tr\u1ecb kh\u00e1c, ch\u1ee9 kh\u00f4ng d\u00f9ng so s\u00e1nh >, < ... nh\u01b0  if .  iex(22)> case 5 do\n...(22)>   4 ->\n...(22)>\n...(22)> \"Won't match\"\n...(22)> _ ->\n...(22)> \"will match\"\n...(22)> end\n\"will match\"  iex(23)> case {1, 2, 3} do\n...(23)>   {1, x, 3} when x > 0 ->\n...(23)>     \"will match\"\n...(23)>   _ ->\n...(23)>     \"Would match, if guard cond were not sastified\"\n...(23)> end\n\"will match\"  when x > 0  g\u1ecdi l\u00e0 guard condition. Ta th\u1ea5y  case  c\u0169ng l\u00e0 m\u1ed9t macro ch\u1ee9 kh\u00f4ng ph\u1ea3i \"statement\" nh\u01b0 trong c\u00e1c ng\u00f4n ng\u1eef kh\u00e1c.  C\u00fa ph\u00e1p:  case SOMETHING do\n  CLAUSE1 [GUARD] ->\n      \"OTHERTHING\"\n  CLAUSE2 [GUARD] ->\n     ...\n  _ ->\n     \"LAST PATTERN MATCH REMAIN\"\nend  N\u1ebfu kh\u00f4ng clause n\u00e0o match, error s\u1ebd \u0111\u01b0\u1ee3c raise:  iex(24)> case :ok do\n...(24)>   :error ->\n...(24)>     \"Not match\"\n...(24)> end\n** (CaseClauseError) no case clause matching: :ok",
            "title": "case"
        },
        {
            "location": "/#guard",
            "text": "Trong guard kh\u00f4ng \u0111\u01b0\u1ee3c d\u00f9ng && || !\nError trong guard s\u1ebd khi\u1ebfn guard fail.",
            "title": "Guard"
        },
        {
            "location": "/#doend",
            "text": "Trong  if   unless   cond   case  \u0111\u1ec1u c\u00f3 d\u00f9ng  do  v\u00e0\nk\u1ebft th\u00fac b\u1eb1ng  end .  if true do\n...\nend  T\u01b0\u01a1ng \u0111\u01b0\u01a1ng v\u1edbi:  if true, do: (\n...\n)  do/end  l\u00e0 syntactix sugar (c\u00fa ph\u00e1p \u0111\u1ec3 vi\u1ebft cho d\u1ec5).",
            "title": "do/end"
        },
        {
            "location": "/#function",
            "text": "",
            "title": "Function"
        },
        {
            "location": "/#goi-function-calling",
            "text": "C\u00fa ph\u00e1p th\u00f4ng th\u01b0\u1eddng:  iex(1)> String.to_integer(String.trim(\"  42 \\n \"))\n42\niex(7)> String.split(\"42-15\\n17\", [\"-\", \"\\n\"])\n[\"42\", \"15\", \"17\"]  C\u00fa ph\u00e1p b\u1ecf d\u1ea5u  () :  iex(8)> String.split \"42-15\\n17\", [\"-\", \"\\n\"]\n[\"42\", \"15\", \"17\"]\n\niex(10)> Enum.map(String.split(\"42-15\\n17\", [\"-\", \"\\n\"]), fn(x) -> String.to_integer(x) end)\n[42, 15, 17]",
            "title": "G\u1ecdi function (calling):"
        },
        {
            "location": "/#toan-tu-pipe-pipe-operator",
            "text": "C\u00fa ph\u00e1p s\u1eed d\u1ee5ng \"pipe\", d\u1eef li\u1ec7u s\u1ebd ch\u1ea1y t\u1eeb output c\u1ee7a 1 function, qua pipe v\u00e0 tr\u1edf th\u00e0nh argument \u0111\u1ea7u ti\u00ean c\u1ee7a function ti\u1ebfp theo (gi\u1ed1ng Pipeline tr\u00ean UNIX shell).  iex(11)> String.split(\"42-15\\n17\", [\"-\", \"\\n\"]) |> Enum.map(fn(x) -> String.to_integer(x) end)\n[42, 15, 17]\n\niex(23)> 1..1000 |> Enum.filter(fn(x) -> (rem(x, 3) == 0 || rem(x, 5) == 0) end) |> Enum.sum\n234168",
            "title": "To\u00e1n t\u1eed pipe (pipe operator)"
        },
        {
            "location": "/#inh-nghia-function",
            "text": "Function c\u00f3 t\u00ean ph\u1ea3i \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong module.\nFunction s\u1ebd tr\u1ea3 v\u1ec1 gi\u00e1 tr\u1ecb cu\u1ed1i c\u00f9ng n\u00f3 t\u00ednh \u0111\u01b0\u1ee3c - kh\u00f4ng c\u00f3 c\u00e2u l\u1ec7nh \"return\".\n\u0110o\u1ea1n code sau \u0111\u1ecbnh ngh\u0129a module  Math  v\u00e0 function  sum  tr\u1ea3 v\u1ec1 t\u1ed5ng c\u1ee7a 2 argument a, b:  defmodule Math do\n  def sum(a, b) do\n    a + b\n  end\nend  ho\u1eb7c  defmodule Hacker, do: def hack(x), do: x*2  khi ch\u1ec9 c\u00f3 1 function v\u00e0 function ch\u1ec9 c\u00f3 1 d\u00f2ng.  defmodule  v\u00e0  def  \u0111\u1ec1u l\u00e0 c\u00e1c macro.",
            "title": "\u0110\u1ecbnh ngh\u0129a function"
        },
        {
            "location": "/#private-function",
            "text": "\u0110\u1ecbnh ngh\u0129a b\u1eb1ng macro  defp/2 , t\u1eeb module kh\u00e1c kh\u00f4ng th\u1ec3 ch\u1ea1y c\u00e1c function n\u00e0y.",
            "title": "Private function"
        },
        {
            "location": "/#ky-hieu-notation",
            "text": "Khi nh\u1eafc t\u1edbi function, trong Elixir d\u00f9ng k\u00fd hi\u1ec7u: name/arity  v\u1edbi name l\u00e0 t\u00ean , v\u00e0 arity l\u00e0 s\u1ed1 argument function \u0111\u00f3 nh\u1eadn.  Math.sum \u1edf tr\u00ean k\u00fd hi\u1ec7u l\u00e0  Math.sum/2",
            "title": "K\u00fd hi\u1ec7u (notation)"
        },
        {
            "location": "/#multiple-clause-function",
            "text": "M\u1ed9t function c\u00f3 th\u1ec3 c\u00f3 nhi\u1ec1u  clause :  M\u1ed7i \"clause\" th\u01b0\u1eddng \u0111i k\u00e8m m\u1ed9t \"guard\", n\u1ebfu argument pass v\u00e0o match v\u1edbi argument c\u1ee7a clause v\u00e0 guard \u0111i k\u00e8m tr\u1ea3 v\u1ec1  true , clause \u0111\u00f3 s\u1ebd \u0111\u01b0\u1ee3c g\u1ecdi.  defmodule Foo do\n  def rprint(msg, n) when n <= 1 do\n    IO.puts msg\n  end\n\n  def rprint(msg, n) do\n    IO.puts msg\n    rprint(msg, n - 1)\n  end\nend\n\nFoo.rprint(\"Hello\", 5)",
            "title": "Multiple clause function"
        },
        {
            "location": "/#function-capturing",
            "text": "",
            "title": "Function capturing"
        },
        {
            "location": "/#todo",
            "text": "",
            "title": "TODO"
        },
        {
            "location": "/#default-argument",
            "text": "def join(a, b, sep \\\\ \",\") do\n  a <> sep <> b\nend  \",\" l\u00e0 default argument, khi g\u1ecdi funtion m\u00e0 kh\u00f4ng pass gi\u00e1 tr\u1ecb cho argument  sep ,  sep  s\u1ebd s\u1eed d\u1ee5ng gi\u00e1 tr\u1ecb m\u1eb7c \u0111\u1ecbnh \",\".",
            "title": "Default argument"
        },
        {
            "location": "/#cac-phan-cua-mot-function",
            "text": "def sum(a, b) do\n  a + b\nend   Function head:  def sum(a, b)  Function body: t\u1eeb  do  \u0111\u1ebfn  end   Khi function v\u1edbi default value c\u00f3 nhi\u1ec1u m\u1ec7nh \u0111\u1ec1, ph\u1ea3i khai b\u00e1o m\u1ed9t function head \u0111\u1ec3 khai b\u00e1o gi\u00e1 tr\u1ecb default.",
            "title": "C\u00e1c ph\u1ea7n c\u1ee7a m\u1ed9t function"
        },
        {
            "location": "/#todo-more-detail",
            "text": "",
            "title": "TODO more detail"
        },
        {
            "location": "/#module",
            "text": "",
            "title": "Module"
        },
        {
            "location": "/#compile",
            "text": "C\u00f3 th\u1ec3 vi\u1ebft module v\u00e0o file  NAME.ex :  math.ex .  Compile module:  $ elixirc math.ex  # t\u1ea1o ra file Elixir.Math.beam  B\u1eadt  iex  c\u00f9ng th\u01b0 m\u1ee5c s\u1ebd t\u1ef1 \u0111\u1ed9ng load module, ch\u1ec9 vi\u1ec7c g\u1ecdi.",
            "title": "Compile"
        },
        {
            "location": "/#script",
            "text": "L\u01b0u file v\u1edbi \u0111u\u00f4i .exs, Elixir s\u1ebd hi\u1ec3u \u0111\u00f3 l\u00e0 1 \"script\" v\u00e0 s\u1ebd kh\u00f4ng t\u1ea1o file c\u00f3 \u0111u\u00f4i .beam n\u1eefa, ch\u1ea1y n\u00f3 nh\u01b0 ch\u1ea1y c\u00e1c script kh\u00e1c (Python, bash...):  $ elixir math.exs",
            "title": "Script"
        },
        {
            "location": "/#loop-bang-recursion-reduce-va-map",
            "text": "Trong Elixir, m\u1ecdi th\u1ee9 \u0111\u1ec1u l\u00e0 \"immutable\" (kh\u00f4ng thay \u0111\u1ed5i \u0111\u01b0\u1ee3c), v\u00ec v\u1eady nh\u1eefng kh\u00e1i ni\u1ec7m \u0111\u1ec3 l\u1eb7p nh\u01b0 trong c\u00e1c ng\u00f4n ng\u1eef C, Python, Java, PHP, Golang ... s\u1ebd kh\u00f4ng \u0111\u01b0\u1ee3c \u1ee9ng d\u1ee5ng:  for i in 'Elixir':\n    print(i)  \u1ede v\u00f2ng l\u1eb7p for n\u00e0y, gi\u00e1 tr\u1ecb c\u1ee7a i l\u1ea7n l\u01b0\u1ee3t thay \u0111\u1ed5i th\u00e0nh c\u00e1c k\u00fd t\u1ef1 trong \"Elixir\" -> kh\u00f4ng \u0111\u1ea3m b\u1ea3o \u0111\u01b0\u1ee3c t\u00ednh immutable c\u1ee7a Elixir.  i = 0\nwhile True:\n    print(i)\n    i = i + 1  T\u01b0\u01a1ng t\u1ef1, trong v\u00f2ng l\u1eb7p while n\u00e0y i c\u0169ng thay \u0111\u1ed5i sau m\u1ed7i v\u00f2ng l\u1eb7p, kh\u00f4ng \u0111\u1ea3m b\u1ea3o t\u00ednh immutable.  Elixir hay c\u00e1c ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh h\u00e0m (functional programming language) kh\u00e1c s\u1eed d\u1ee5ng recursive function \u0111\u1ec3 t\u1ea1o hi\u1ec7u \u1ee9ng/ k\u1ebft qu\u1ea3 nh\u01b0 loop.",
            "title": "Loop b\u1eb1ng recursion, reduce v\u00e0 map"
        },
        {
            "location": "/#recursive-function",
            "text": "L\u00e0 function m\u00e0 b\u00ean trong ph\u1ea7n body, n\u00f3 t\u1ef1 g\u1ecdi \u0111\u1ebfn ch\u00ednh n\u00f3 cho \u0111\u1ebfn khi g\u1eb7p m\u1ed9t \u0111i\u1ec1u ki\u1ec7n \u0111\u1ec3 d\u1eebng l\u1ea1i. S\u1ebd kh\u00f4ng c\u00f3 g\u00ec b\u1ecb thay \u0111\u1ed5i khi d\u00f9ng recursive function, b\u1edfi ta s\u1ebd sinh ra gi\u00e1 tr\u1ecb m\u1edbi, ch\u1ee9 kh\u00f4ng thay \u0111\u1ed5i gi\u00e1 tr\u1ecb c\u0169. M\u1ecdi kh\u00e1i ni\u1ec7m s\u1ebd r\u00f5 r\u00e0ng khi th\u1eed v\u1edbi function t\u00ednh giai th\u1eeba c\u1ee7a 1 s\u1ed1:  Giai th\u1eeba c\u1ee7a m\u1ed9t s\u1ed1 nguy\u00ean kh\u00f4ng \u00e2m \u0111\u01b0\u1ee3c t\u00ednh b\u1eb1ng t\u00edch c\u1ee7a s\u1ed1 \u0111\u00f3 nh\u00e2n v\u1edbi giai th\u1eeda c\u1ee7a s\u1ed1 nh\u1ecf h\u01a1n n\u00f3 1 \u0111\u01a1n v\u1ecb. Hay vi\u1ebft \u1edf d\u1ea1ng c\u00f4ng th\u1ee9c to\u00e1n:\nfactorial(n) = n * factorial(n - 1)\nkhi n = 0 th\u00ec factorial(0) = 1. # \u0111i\u1ec1u ki\u1ec7n d\u1eebng  Th\u1eed t\u00ednh factorial c\u1ee7a 3:  factorial(3) = 3 * factorial(2)\nfactorial(2) = 2 * factorial(1)\nfactorial(1) = 1 * factorial(0)\nfactorial(0) = 1  Sau khi \u0111\u00e3 ch\u1ea1m \u0111\u1ebfn \u0111i\u1ec1u ki\u1ec7n d\u1ef1ng, ta l\u1ea5y k\u1ebft qu\u1ea3 thu \u0111\u01b0\u1ee3c thay ng\u01b0\u1ee3c l\u00ean tr\u00ean.\nfactorial(1) = 1 * factorial(0) = 1 * 1 = 1\nfactorial(2) = 2 * factorial(1) = 2 * 1 = 2\nfactorial(3) = 3 * factorial(2) = 3 * 2 = 6  K\u1ebft qu\u1ea3 l\u00e0 factorial(3) b\u1eb1ng 6.  defmodule Rescusion do\n  def fact(n) when n <= 0 do\n    1\n  end\n\n  def fact(n) do\n    n * fact(n - 1)\n  end\nend  Trong b\u00e0i n\u00e0y, code c\u1ee7a Elixir ch\u1ec9 \u0111\u01a1n gi\u1ea3n l\u00e0 chuy\u1ec3n c\u00f4ng th\u1ee9c to\u00e1n h\u1ecdc th\u00e0nh code.",
            "title": "Recursive function"
        },
        {
            "location": "/#map_1",
            "text": "M\u1ed9t vi\u1ec7c l\u00e0m th\u01b0\u1eddng xuy\u00ean khi s\u1eed d\u1ee5ng loop l\u00e0 \u0111\u1ec3 bi\u1ebfn 1 t\u1eadp gi\u00e1 tr\u1ecb, th\u00e0nh 1 t\u1eadp gi\u00e1 tr\u1ecb kh\u00e1c.  V\u00ed d\u1ee5, cho m\u1ed9t list  L = [1, 2, 3 ,4] , c\u1ea7n thu \u0111\u01b0\u1ee3c k\u1ebft qu\u1ea3 l\u00e0 m\u1ed9t list m\u00e0 ph\u1ea7n t\u1eed c\u1ee7a n\u00f3 l\u00e0 m\u1ed7i ph\u1ea7n t\u1eed c\u1ee7a  L  nh\u00e2n v\u1edbi 2.  Vi\u1ec7c bi\u1ebfn m\u1ed9t t\u1eadp th\u00e0nh m\u1ed9t t\u1eadp kh\u00e1c b\u1eb1ng c\u00e1ch g\u1ecdi function v\u1edbi m\u1ed7i ph\u1ea7n t\u1eed c\u1ee7a t\u1eadp g\u1ecdi l\u00e0 \"mapping\" (\u00e1nh x\u1ea1 trong to\u00e1n h\u1ecdc).\nTa \"map\" m\u1ed9t ph\u1ea7n t\u1eed t\u1eeb t\u1eadp ban \u0111\u1ea7u th\u00e0nh ph\u1ea7n t\u1eed trong t\u1eadp m\u1edbi.  Vi\u1ebft function \u0111\u1ec3 map list n\u00f3i tr\u00ean:  iex(41)> defmodule Double do\n...(41)>   def double_each([head | tail]) do\n...(41)>     [head * 2 | double_each(tail)]\n...(41)>   end\n...(41)>\n...(41)>   def double_each([]) do\n...(41)>     []\n...(41)>   end\n...(41)> end\n{:module, Double,\n...\niex(42)> Double.double_each([1,2,3,4])\n[2, 4, 6, 8]  C\u00f3 th\u1ec3 d\u00f9ng function c\u00f3 s\u1eb5n  Enum.map/2  \u0111\u1ec3 th\u1ef1c hi\u1ec7n mapping:  iex(45)> Enum.map([1,2,3,4], fn(x) -> x * 2 end)\n[2, 4, 6, 8]",
            "title": "Map"
        },
        {
            "location": "/#reduce",
            "text": "M\u1ed9t \u1ee9ng d\u1ee5ng kh\u00e1c th\u01b0\u1eddng d\u00f9ng khi l\u1eb7p l\u00e0 \u0111\u1ec3 t\u00ednh m\u1ed9t gi\u00e1 tr\u1ecb n\u00e0o \u0111\u00f3 s\u1ebd thu \u0111\u01b0\u1ee3c sau khi duy\u1ec7t qua t\u1ea5t c\u1ea3 gi\u00e1 tr\u1ecb trong t\u1eadp, nh\u01b0 t\u00ednh t\u1ed5ng, t\u00edch c\u1ee7a t\u1eadp.  \u1ede \u0111\u00e2y ta bi\u1ebfn t\u1eeb 1 t\u1eadp nhi\u1ec1u ph\u1ea7n t\u1eed th\u00e0nh 1 gi\u00e1 tr\u1ecb cu\u1ed1i c\u00f9ng. Vi\u1ec7c \"thu g\u1ecdn\" n\u00e0y c\u00f3 t\u00ean l\u00e0 \"reducing\".  Map v\u00e0 reduce l\u00e0 2 thu\u1eadt to\u00e1n c\u1ed1t l\u00f5i c\u1ee7a \"big data\".  iex(46)> defmodule Reduce do\n...(46)>   def sum_list([head | tail], accumulator) do\n...(46)>     sum_list(tail, head + accumulator)\n...(46)>   end\n...(46)>\n...(46)>   def sum_list([], accumulator) do\n...(46)>     accumulator\n...(46)>   end\n...(46)> end\n\niex(47)> Reduce.sum_list([1,2,3], 0)\n6  Hay d\u00f9ng module c\u00f3 s\u1eb5n  Enum.reduce/2 :  iex(48)> Enum.reduce([1,2,3], 0, fn(x, acc) -> x + acc end)\n6",
            "title": "Reduce"
        },
        {
            "location": "/#io-xu-ly-du-lieu-vao-ra",
            "text": "",
            "title": "IO - x\u1eed l\u00fd d\u1eef li\u1ec7u v\u00e0o ra."
        },
        {
            "location": "/#in-ra-man-hinh",
            "text": "M\u1eb7c d\u00f9 h\u1ea7u h\u1ebft c\u00e1c s\u00e1ch d\u1ea1y l\u1eadp tr\u00ecnh / tr\u01b0\u1eddng h\u1ecdc s\u1ebd lu\u00f4n b\u1eaft \u0111\u1ea7u b\u1eb1ng vi\u1ec7c d\u1ea1y \"print\" ra m\u00e0n h\u00ecnh (v\u00e0 \u0111i k\u00e8m l\u00e0 \u0111\u1ecdc nh\u1eefng g\u00ec ng\u01b0\u1eddi d\u00f9ng nh\u1eadp v\u00e0o), nh\u01b0ng tr\u00ean th\u1ef1c t\u1ebf, c\u00f3 kho\u1ea3ng < 5% ng\u01b0\u1eddi th\u1ef1c s\u1ef1 d\u00f9ng print trong ch\u01b0\u01a1ng tr\u00ecnh c\u1ee7a m\u00ecnh.  H\u00e3y th\u1eed ngh\u0129 v\u1edbi ng\u01b0\u1eddi d\u00f9ng Windows, c\u00f3 bao gi\u1edd b\u1ea1n b\u1eadt  cmd  l\u00ean v\u00e0 g\u00f5 l\u1ec7nh? C\u00e1c ch\u01b0\u01a1ng tr\u00ecnh \u0111\u1ec1u giao ti\u1ebfp v\u1edbi ng\u01b0\u1eddi d\u00f9ng qua giao di\u1ec7n \u0111\u1ed3 ho\u1ea1 / web, ch\u1ee9 kh\u00f4ng ph\u1ea3i c\u00e1c d\u00f2ng l\u1ec7nh. Nh\u1eefng ng\u01b0\u1eddi l\u00e0m vi\u1ec7c v\u1edbi d\u00f2ng l\u1ec7nh ch\u1ee7 y\u1ebfu l\u00e0 c\u00e1c Linux Sysadmin / l\u1eadp tr\u00ecnh vi\u00ean / hacker.\nN\u1ebfu b\u1ea1n l\u00e0 m\u1ed9t web developer, b\u1ea1n \u0111\u01b0a n\u1ed9i dung ra trang web ch\u1ee9 kh\u00f4ng print n\u00f3.  Elixir s\u1eed d\u1ee5ng module  IO  cho c\u00e1c thao t\u00e1c n\u00e0y:  iex(49)> IO.puts \"Hello\"\nHello\n:ok\niex(50)> IO.puts \"Hello FAMILUG\"\nHello FAMILUG\n:ok\niex(51)> answer = IO.gets(\"yes or no? \")\nyes or no? yes\n\"yes\\n\"\niex(52)> IO.puts(answer)\nyes\n\n:ok  C\u00f3 th\u1ec3 ghi ra stderr:  iex(53)> IO.puts(:stderr, \"Hello standard error\")\nHello standard error\n:ok  \u0110\u1ec3 kh\u00f4ng th\u00eam k\u00fd t\u1ef1 newline ( \\n ) sau m\u1ed7i d\u00f2ng, s\u1eed d\u1ee5ng  IO.write  thay\nv\u00ec  IO.puts .",
            "title": "In ra m\u00e0n h\u00ecnh"
        },
        {
            "location": "/#oc-ghi-file",
            "text": "Module  File  ch\u1ee9a c\u00e1c function \u0111\u1ec3 t\u01b0\u01a1ng t\u00e1c v\u1edbi file, t\u1eeb \u0111\u1ecdc, ghi, xo\u00e1, copy...  iex(53)> IO.puts(:stderr, \"Hello standard error\")\nHello standard error\n:ok\niex(54)> {:ok, file} = File.open(\"hellofile.txt\", [:write])\n{:ok, #PID<0.260.0>}\niex(55)> IO.binwrite(file, \"Hello world!\")\n:ok\niex(56)> File.close(file)\n:ok\niex(57)> File.read(\"hellofile.txt\")\n{:ok, \"Hello world!\"}  C\u00e1c function x\u1eed l\u00fd file:  File.rm/1 ,  File.mkdir/1 ,  File.cp_r/2 , ...",
            "title": "\u0110\u1ecdc ghi file"
        },
        {
            "location": "/#xu-ly-loi",
            "text": "",
            "title": "X\u1eed l\u00fd l\u1ed7i"
        },
        {
            "location": "/#errror-hay-exception",
            "text": "iex(58)> \"abc\" + 1\n** (ArithmeticError) bad argument in arithmetic expression\n    :erlang.+(\"abc\", 1)\niex(58)> raise \"oizoioi\"\n** (RuntimeError) oizoioi\n\niex(58)> raise ArgumentError, message: \"invalid argument\"\n** (ArgumentError) invalid argument",
            "title": "Errror (hay exception)"
        },
        {
            "location": "/#tryrescuecatchafter",
            "text": "T\u01b0\u01a1ng t\u1ef1 nh\u01b0 try/except trong Python hay try/catch trong Java, Elixir c\u00f3 try/recuse v\u00e0 try/catch, nh\u01b0ng trong Elixir, s\u1eed d\u1ee5ng ch\u00fang l\u00e0 \u0111i\u1ec1u kh\u00f4ng n\u00ean / hi\u1ebfm khi d\u00f9ng.  iex(61)> try do\n...(61)>   r = 1/0\n...(61)> rescue\n...(61)>   ArithmeticError -> \"Error\"\n...(61)> end\n\"Error\"  V\u1eady Elixir l\u00e0m g\u00ec khi g\u1eb7p l\u1ed7i? c\u00f3 \"exception\" th\u00ec x\u1eed l\u00fd th\u1ebf n\u00e0o?\nTrong tri\u1ebft l\u00fd c\u1ee7a Erlang/Elixir, \"l\u1ed7i\" l\u00e0 m\u1ed9t ph\u1ea7n c\u1ee7a ch\u01b0\u01a1ng tr\u00ecnh, v\u00e0 h\u1ec7 th\u1ed1ng n\u1eb1m d\u01b0\u1edbi ng\u00f4n ng\u1eef (BEAM/OTP) s\u1ebd x\u1eed l\u00fd ch\u00fang m\u1ed9t c\u00e1ch ngon l\u00e0nh. T\u1ea1m th\u1eddi b\u1ecf qua \u1edf \u0111\u00e2y.",
            "title": "try/rescue/catch/after"
        },
        {
            "location": "/#bat-au-code-mot-project",
            "text": "\u0110\u1ebfn \u0111\u00e2y \u0111\u00e3 \u0111\u1ee7 c\u00e1c c\u00f4ng c\u1ee5 c\u01a1 b\u1ea3n \u0111\u1ec3 vi\u1ebft nh\u1eefng ch\u01b0\u01a1ng tr\u00ecnh b\u00ecnh th\u01b0\u1eddng / luy\u1ec7n t\u1eadp v\u1edbi c\u00e1c thu\u1eadt to\u00e1n ... cho \u0111\u1ebfn khi quen v\u1edbi ng\u00f4n ng\u1eef.\nElixir c\u00f2n nhi\u1ec1u kh\u00e1i ni\u1ec7m kh\u00e1c, \u0111\u1eb7c bi\u1ec7t \u0111\u01b0\u1ee3c \u0111\u01b0a ra \u0111\u1ec3 x\u1eed l\u00fd trong m\u00f4i tr\u01b0\u1eddng \"ph\u00e2n t\u00e1n\", nh\u01b0ng t\u1eadp trung v\u00e0o nh\u1eefng t\u00ednh n\u0103ng \u0111\u00f3 ngay b\u00e2y gi\u1edd ch\u1ec9 l\u00e0m cho ng\u01b0\u1eddi h\u1ecdc b\u1ecb qu\u00e1 t\u1ea3i v\u1edbi nh\u1eefng kh\u00e1i ni\u1ec7m m\u1edbi l\u1ea1, trong khi v\u1eabn ch\u01b0a n\u1eafm r\u00f5 ph\u1ea7n c\u01a1 b\u1ea3n. V\u1eady n\u00ean, c\u00e1c kh\u00e1i ni\u1ec7m \"kh\u00e1c\" \u0111\u00f3 s\u1ebd \u0111\u01b0\u1ee3c d\u00e0nh cho ph\u1ea7n sau. C\u00f2n b\u00e2y gi\u1edd, t\u1ea1o m\u1ed9t project Elixir v\u00e0 code:  Mix  l\u00e0 \"build tool\" c\u1ee7a Elixir, \u0111\u1ec3 t\u1ea1o m\u1ed9t project m\u1edbi, d\u00f9ng c\u00e2u l\u1ec7nh:   mix new hello_familug\n* creating README.md\n* creating .gitignore\n* creating mix.exs\n* creating config\n* creating config/config.exs\n* creating lib\n* creating lib/hello_familug.ex\n* creating test\n* creating test/test_helper.exs\n* creating test/hello_familug_test.exs\n\nYour Mix project was created successfully.\nYou can use \"mix\" to compile it, test it, and more:\n\n    cd hello_familug\n    mix test\n\nRun \"mix help\" for more commands.  S\u1eeda n\u1ed9i dung file  lib/hello_familug.ex  nh\u01b0 sau:  defmodule HelloFamilug do\n  def main(args) do\n    IO.puts \"Hello FAMILUG!\"\n  end\nend  Th\u00eam d\u00f2ng:        escript: escript,  v\u00e0o sau d\u00f2ng        elixir: \"~> VERSION\",  trong mix.exs.  Th\u00eam function sau v\u00e0o trong file  mix.exs    def escript do\n    [main_module: HelloFamilug]  # t\u00ean module s\u1ebd \u0111\u01b0\u1ee3c ch\u1ea1y\n  end  Compile v\u00e0 ch\u1ea1y:  $ mix escript.build\nCompiling 1 file (.ex)\nwarning: variable args is unused\n  lib/hello_familug.ex:2\n\nGenerated hello_familug app\nGenerated escript hello_familug with MIX_ENV=dev\n$ ./hello_familug\nHello FAMILUG!  S\u1eeda l\u1ea1i code \u0111\u1ec3 nh\u1eadn v\u00e0o input t\u1eeb ng\u01b0\u1eddi d\u00f9ng:  defmodule HelloFamilug do\n  def main(args) do\n    {_, [name], _} = OptionParser.parse(args)\n    IO.puts \"Hello \" <> name\n  end\nend  T\u1ea1m th\u1eddi b\u1ecf qua chi ti\u1ebft OptionParser.parse/1 l\u00e0m g\u00ec,\nbuild l\u1ea1i v\u00e0 g\u1ecdi v\u1edbi m\u1ed9t c\u00e1i t\u00ean:  $ mix escript.build\nCompiling 1 file (.ex)\nGenerated escript hello_familug with MIX_ENV=dev\n$ ./hello_familug Python\nHello Python  Ch\u01b0\u01a1ng tr\u00ecnh d\u00f2ng l\u1ec7nh (CLI tool) kh\u00f4ng ph\u1ea3i l\u00e0 th\u1ebf m\u1ea1nh c\u1ee7a Elixir, nh\u01b0ng n\u00f3 ho\u00e0n to\u00e0n c\u00f3 th\u1ec3 l\u00e0m \u0111\u01b0\u1ee3c v\u00e0 kh\u00f4ng h\u1ec1 ph\u1ee9c t\u1ea1p. V\u1edbi t\u1eebng \u1ea5y \u0111\u1ee7 \u0111\u1ec3 ta b\u1eaft \u0111\u1ea7u cu\u1ed9c h\u00e0nh tr\u00ecnh v\u00e0o nh\u1eefng gi\u1ea5c m\u01a1 s\u00e2u v\u00f4 t\u1eadn trong th\u1ebf gi\u1edbi c\u1ee7a nh\u00e0 gi\u1ea3 kim v\u00e0 Elixir (thu\u1ed1c ti\u00ean).",
            "title": "B\u1eaft \u0111\u1ea7u code m\u1ed9t project"
        },
        {
            "location": "/#faqs",
            "text": "",
            "title": "FAQs"
        },
        {
            "location": "/#tai-sao-ten-lai-nham-nhi-vay-hoc-elixir-trong-mot-giac-mo",
            "text": "V\u00ec vi\u1ec7c \u0111\u1ecdc ti\u1ebfng Anh \u1edf Vi\u1ec7t Nam r\u1ea5t \"th\u1ea3m ho\u1ea1\".\nCh\u1eef \"Python\" - r\u00f5 r\u00e0ng \u0111\u1ecdc l\u00e0 \"pai-thon\" th\u00ec ph\u1ea7n l\u1edbn l\u1eadp tr\u00ecnh vi\u00ean l\u1ea1i \u0111\u1ecdc l\u00e0 \"Pi-th\u00f4ng\". V\u1eady n\u00ean t\u00f4i \u0111\u1eb7t t\u00ean c\u00f3 v\u1ea7n \u0111\u1ec3 ng\u01b0\u1eddi h\u1ecdc c\u00f3 th\u1ec3 \u0111\u1ecdc \u0111\u00fang \"H\u1ecdc  i l\u00edk s\u01a1  trong m\u1ed9t gi\u1ea5c m\u01a1\".",
            "title": "T\u1ea1i sao t\u00ean l\u1ea1i nh\u1ea3m nh\u00ed v\u1eady \"h\u1ecdc Elixir trong m\u1ed9t gi\u1ea5c m\u01a1\"?"
        },
        {
            "location": "/after-basic/",
            "text": "Sau b\u1eaft \u0111\u1ea7u\n\n\nSau khi \u0111\u00e3 n\u1eafm \u0111\u01b0\u1ee3c c\u00fa ph\u00e1p c\u01a1 b\u1ea3n c\u1ee7a Elixir, ta c\u1ea7n g\u00ec \u0111\u00f3 \u0111\u1ec3 code. M\u1eb7c d\u00f9 l\u00e0m website l\u00e0 m\u1ed9t th\u1ebf m\u1ea1nh c\u1ee7a Elixir, nh\u01b0ng n\u1ebfu trong \u0111\u1ea7u b\u1ea1n kh\u00f4ng ngh\u0129 ra ngay m\u1ed9t webapp n\u00e0o b\u1ea1n c\u1ea7n l\u00e0m, th\u00ec \u0111i theo con \u0111\u01b0\u1eddng \u1ea5y l\u00e0 kh\u00f4ng t\u1ed1i \u01b0u. B\u1edfi n\u1ebfu ch\u1ec9 l\u00e0m xong tutorial v\u00e0 l\u00e0m ra m\u1ed9t trang web v\u00ed d\u1ee5 n\u00e0o \u0111\u00f3, m\u1ecdi ki\u1ebfn th\u1ee9c l\u1ea1i tr\u00f4i v\u00e0o qu\u00ean l\u00e3ng.\n\n\nV\u1eady n\u00ean trong th\u1eddi gian ch\u1edd c\u00e1c \u00fd t\u01b0\u1edfng hi\u1ec7n l\u00ean, ta ti\u1ebfp t\u1ee5c \u0111\u00e0o s\u00e2u v\u00e0o Elixir, nh\u01b0ng b\u1eb1ng c\u00e1ch gi\u1ea3i c\u00e1c b\u00e0i to\u00e1n tr\u00ean website: hackerrank.com. M\u1ee5c \"Functional programming\":\nhttps://www.hackerrank.com/domains/fp/intro\n\n\nC\u00e1c v\u1ea5n \u0111\u1ec1 s\u1ebd \u0111i t\u1eeb d\u1ec5 \u0111\u1ebfn kh\u00f3. H\u00e3y b\u1eaft \u0111\u1ea7u v\u1edbi d\u1ec5:\n\n\nhttps://www.hackerrank.com/challenges/fp-list-replication\n\n\nB\u00e0i n\u00e0y y\u00eau c\u1ea7u cho \u0111\u1ea7u v\u00e0o l\u00e0 1 s\u1ed1 N, v\u00e0 m\u1ed9t d\u00e3y s\u1ed1 theo sau, m\u1ee5c ti\u00eau l\u00e0 t\u1ea1o ra m\u1ed9t d\u00e3y s\u1ed1 m\u00e0 m\u1ed7i s\u1ed1 l\u1eafp l\u1ea1i N l\u1ea7n.\nV\u00ed d\u1ee5 cho N=3, d\u00e3y s\u1ed1 2 3 4, c\u1ea7n in ra m\u00e0n h\u00ecnh:\n\n\n2\n2\n2\n3\n3\n3\n4\n4\n4\n\n\n\n\nHai \u0111i\u1ec3m c\u1ea7n ch\u00fa \u00fd:\n- Ta c\u1ea7n bi\u1ebft \u0111\u1ecdc d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o tr\u00ean Elixir\n\n\nKhi vi\u1ebft code trong b\u00e0i n\u00e0y, m\u00ecnh s\u1eed d\u1ee5ng m\u1ed9t t\u00ean bi\u1ebfn l\u00e0 \"S\", v\u00e0 m\u1ecdi l\u1ed7i k\u1ef3 l\u1ea1 b\u1eaft \u0111\u1ea7u x\u1ea3y ra, m\u1ecdi th\u1ee9 tr\u1edf l\u1ea1i b\u00ecnh th\u01b0\u1eddng n\u1ebfu s\u1eed d\u1ee5ng t\u00ean bi\u1ebfn l\u00e0 ch\u1eef s vi\u1ebft th\u01b0\u1eddng. TODO t\u00ecm hi\u1ec3u t\u1ea1i sao.\n\n\nV\u1ea5n \u0111\u1ec1 th\u1ee9 2 l\u00e0 khi vi\u1ebft function tr\u1ea3 v\u1ec1 1 list, n\u1ebfu b\u1eadt iex l\u00ean v\u00e0 in k\u1ebft qu\u1ea3 function tr\u1ea3 v\u1ec1 s\u1ebd th\u1ea5y list \u0111\u00f3, nh\u01b0ng n\u1ebfu vi\u1ebft code IO.puts myfunc() th\u00ec ch\u1ec9 th\u1ea5y k\u1ebft qu\u1ea3 in ra d\u00f2ng tr\u1eafng.\n\n\nTODO t\u1ea1i sao?\n\n\nhttps://www.hackerrank.com/challenges/fp-filter-array\n\n\nTODO\n\n\nwhy it still can compare string with number\n\n\nwhy [head|tail] and there is a case head == \"\" ?\nbecause of how I split string\n\n\ndata = IO.read(:stdio, :all) |> String.trim |> String.split([\" \", \"\\n\"])\n\n\nAdd String.trim to clean thing up\n\n\nFilter odd element:\n\n\niex(1)> Enum.with_index [\"a\", \"b\", \"c\"]\n[{\"a\", 0}, {\"b\", 1}, {\"c\", 2}]\n\n\nProcess\n\n\nextremely lightweight not like thread in other lang\n\n\nspawn/1 : spawning new process\nspawn/1 takes a function\nreturn a PID\n\n\nProcess.alive?(pid)\n\n\nRetrieve the PID of the current process by calling self/0\n\n\nsend message:\nsend/2: TO, MESSAGE\n\n\nwhen msg is sent to a process, the msg is stored in the process mailbox.\n\n\nreceive/1 searching for 1 msg that match a given pattern in mailbox.\n\n\nsend/2 does not block\n\n\nreceive block or can be timeout.\n\n\nflush/0 flushes and print all msgs in the mailbox\n\n\nspawn_link/1: like spawn, but link to parrent\n\n\n\"failing fast\" is a common philosophy in Elixir world\n\n\nTask.start/1 and Task.start_link/1\n\n\nreturn {:ok, pid}\n\n\nStoring \"state\": http://elixir-lang.org/getting-started/processes.html\n\n\nProcess.register(pid, NAME)\nsend NAME, VALUE\n\n\nAgent is an abstract for that.\n\n\nTODO OTP\n\n\nhttp://elixir-lang.org/getting-started/processes.html\n\n\n====\nModule\n\n\nalias Foo.Bar, as Bar\nlike import FooBar as Bar  # Python\n\n\nrequire Foo # ensuring the module is compiled and available (usually for macro)\n\n\nimport Foo # import functions from Foo module, so can call without \nFoo.\n - auto require it\n\n\nuse Foo # ch\u1ea1y custom code trong Foo\n\n\nalias/require/import : directive v\u00ec c\u00f3 lexical scope\nV\u00ec l\u00e0 lexical scope n\u00ean c\u00f3 th\u1ec3 set alias trong function\nv\u00e0 ch\u1ec9 c\u00f3 th\u1ec3 d\u00f9ng trong function \u0111\u00f3.\n\n\nMacro:\ncode that generates code.\nExecuted and expanded at compilation time.\n\n\niex(14)> require Integer\nInteger\niex(15)> In\nInspect    Integer\niex(15)> Integer.is_\nis_even/1    is_odd/1\niex(15)> Integer.is_odd(3)\ntrue\n\n\niex(16)> import List, only: [duplicate: 2]\nList\n\n\nonly: :macros\n only: :functions\n except: somethign\n\n\nAn alias in Elixir is a capitalized identifier which is converted to an atom during compilation.\n\n\nModule attributes\n\n\nannotate the module\nconstant\ntemporary module storage\n\n\n@moduledoc # doc for module\n@doc # doc for func\n@behaviour\n@before_compile\n\n\ndefmodule Math do\n  @moduledoc \"\"\"  <--- heredocs: Markdown\n  doc go\n  \"\"\"\n\n\n@doc \"\"\"\n  calculate ...\n  \"\"\"\n  def sum(a,b), do: a + b\nend\n\n\nConstant\n\n\nExist only during compilation time\n\n\n@initial_state %{host: \"127.0.0.1\", port:3456}\n\n\nTODO later\n\n\nStruct\n\n\nBuilt on top of maps\nprovide: compile-time checks and default value\n\n\ndefmodule User do\n  defstruct name: \"HVN\", age: 27\n  end\n\n\nStructs take the name of the module they\u2019re defined in.\n\n\nSame syntax with map\n\n\nstructs are bare maps (just storage,access, no protocol\n\n\ndefault is nil\n@enforce_keys [:make]\n\n\nProtocol\n\n\nhttp://elixir-lang.org/getting-started/protocols.html\n\n\nEnglish: dispatching on a protocol\ndispatch : send off to a dest\n\n\nProtocol definition:\n\n\ndefprotocol Size do\n  @doc \"Calculate the size of a data structure\"\n  def size(data)\nend\n\n\n\n\ndefimpl Size, for: Map do\n  def size(map), do: map_size(map)\nend\n\n\n\n\nThen we can use it for multiple data type => polymophism\n\n\nProtocol and struct\n\n\ndefimpl Size, for: MapSet do\n  def size(set), do: MapSet.size(set)\n  end\n\n\n\n\nDerive a protocol impolementation for all t ype:\n\n\nuse \nAny\n\n\ndefimpl Size, for: Any do\n  def size(_), do: 0\n\n\n\n\ndefmodule OtherUser do\n  @derive [Size]\n  defstruct [:name, :age]\nend\n\n\n\n\nFallback\n\n\n@fallback_to_any true\n\n\nBuiltin protocol\nEnumerable (map/reduce ...)\nString.Chars (to_string)\nInspect protocol\n\n\nProtocol consolidation\n\n\nEnglish: consolidation : strengthen, make stronger.\n\n\nSigils\n\n\nSigil: start with the tilde (\n~\n), followed by a letter (which identify the sigil)\n\n\nRegular expression\n~r/foo|bar/\n\n\n\"foo\" =~ regex # match regex\n\n\nPRARE.\n\n\n\"HELLO\" =~ ~r/hello/i # i is modifier\n\n\nSigils support 8 different delimiters.\n\n\n/ | \" ' ( [ { <\n\n\nSigils\n- Regex: ~r\n- String: ~s\n- Char list: ~c\n- Word list: ~w(foo bar bat)\n- ~S no escappe/interpolation\n\n\n\n\nhttps://www.hackerrank.com/challenges/fp-array-of-n-elements\ninspect(list, limit: -1)\nd\u00f9ng limit -1 \u0111\u1ec3 in ra kh\u00f4ng gi\u1edbi h\u1ea1n k\u00fd t\u1ef1, vd list c\u00f3 100 ph\u1ea7n t\u1eed, m\u1eb7c \u0111\u1ecbnh elixir ch\u1ec9 in ra ph\u1ea7n \u0111\u1ea7u r\u1ed3i ...\n\n\n\u0111\u1ec3 kh\u00f4ng in ra ch\u1eef (charlist),\nd\u00f9ng\n inspect(charlists: :as_lists)\n\n\niex(20)> inspect (List.duplicate 1, 100), char_lists: :as_lists, limit: -1\n\"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\"\n\n\nTypespec\n\n\nFunction spec\n\n\n:: means that the function on the left side returns a value whose type is what\u2019s on the right side. Function specs are written with the @spec directive, placed right before the function definition. The round/1 function could be written as:\n\n\n@spec round(number) :: integer\ndef round(number), do: # implementation..\n\n\nBehaviours\n\n\nis a specification for composable module\n\n\ndefmodule Parser do\n  @callback parse(String.t) :: any\n  @callback extensions() :: [String.t]\nend\n\n\nAdopting behaviours:\n\n\ndefmodule JSONParser do\n  @behaviour Parser\n\n  def parse(str), do: ...\n\n\nend\n\n\n\n## Erlang Library\n\n:io.format(\"Pi ~10.3f~n\", [:math.pi])\n\n# :crypto\n- not standard,\n\n:crypto.hash(:sha256, \"Elixir\")\n\n# :digraph\nDealing with directed graphs\n\n# ETS - Erlang term storage\nDets: disk ETS\nallow to create a table containing tuples.\n\nFunction in ets module wil modify the state of the table as\na side-effect.\n\n\n\niex(8)> :ets.insert(table, {\"HVN\", 27})\ntrue\niex(9)> :ets.i(table)\n<1   > {<<\"HVN\">>,27}\nEOT  (q)uit (p)Digits (k)ill /Regexp -->1\nEOT  (q)uit (p)Digits (k)ill /Regexp -->2\nEOT  (q)uit (p)Digits (k)ill /Regexp -->q\n:ok\n\n\n## :math\n\n:math.sin\n:math.exp\n:math.log\n\n\n\n## :queue\nFIFO\n\n\nq = :queue.new\nq = :queue.in(\"A\", q)\n\n{value, q} = :queue.out(q)\n\n\n## :rand\n\n:rand.uniform\n:rand.seed\n\n\n## :zip\n\n:zip.foldl(...)\n\n:zlib\n\n\n## Mix and OTP\n\n### Agent\nis simple wrapper around state.\n\n\n\natoms are not garbage collected.\n\n### GenServer\n\ncall: sync\ncast: async\n\n\n\n\nhttp://erlang.org/pipermail/erlang-questions/2014-November/081570.html#\nhttps://blog.codeship.com/concurrency-in-elixir/\n\n\n\n\n\n### Enum functions\n\nEnum.concat/1 : n\u1ed1i c\u00e1c enumerable trong 1 enumerable (e.g flatten a list)\n\nEnum.chunk/2 \n\ndef chunk(enumerable, count)\nShortcut to chunk(enumerable, count, count).\n\nC\u1eaft enum th\u00e0nh `count` enum nh\u1ecf h\u01a1n:\n\niex(3)> Enum.chunk([1,2,3,4,5,6], 3)\n[[1, 2, 3], [4, 5, 6]]\niex(4)> Enum.chunk([1,2,3,4,5,6], 2)\n[[1, 2], [3, 4], [5, 6]]\n\n\niex(6)> Enum.dedup([1,2,2,1,2,2,2,1,1,])\n[1, 2, 1, 2, 1]\niex(7)> Enum.uniq([1,2,2,1,2,2,2,1,1,])\n[1, 2]\n\niex(8)> Enum.empty?([])\ntrue\n\niex(9)> Enum.zip([1,2,3], [\"meo\", \"cho\", \"ga\", \"trau\"])\n[{1, \"meo\"}, {2, \"cho\"}, {3, \"ga\"}]\n\nTrong Elixir, function kh\u00f4ng ph\u1ea3i first-class citizen.\nTa kh\u00f4ng th\u1ec3 pass 1 function c\u00f3 t\u00ean th\u00e0nh argument cho function kh\u00e1c.\n\n\n\n\n\niex(10)> is_function(rem)\n** (CompileError) iex:10: undefined function rem/0\n\n\niex(10)> is_function(rem/2)\n** (CompileError) iex:10: undefined function rem/0\n    (stdlib) lists.erl:1354: :lists.mapfoldl/3\n\n\n\nFunction capturing cho ph\u00e9p \"capture\" m\u1ed9t function c\u00f3 t\u00ean th\u00e0nh m\u1ed9t anonymous function, v\u00e0 l\u00fac \u0111\u00f3 ta c\u00f3 th\u1ec3 g\u00e1n n\u00f3, g\u1ecdi n\u00f3 nh\u01b0 argument:\n\nC\u00f3 2 c\u00fa ph\u00e1p \u0111\u1ec3 capture function, m\u1ed9t l\u00e0 d\u00f9ng function/arity, c\u00e1ch kh\u00e1c l\u00e0 d\u00f9ng capture \u0111\u1ec3 bi\u1ec3u di\u1ec5n l\u01b0\u1ee3ng argument m\u00e0 function nh\u1eadn v\u00e0o:\n\niex(12)> fun = &rem/2\n&:erlang.rem/2\niex(13)> fun = &rem(&1, &2)\n&:erlang.rem/2\niex(14)> fun.(5,2)\n1\n\n\u0110\u1ec3 g\u1ecdi anonymous function, ph\u1ea3i d\u00f9ng d\u1ea5u `.` gi\u1eefa t\u00ean bi\u1ebfn v\u00e0 d\u1ea5u g\u1ecdi function `()`.\n\nHai anonymous function sau l\u00e0 t\u01b0\u01a1ng \u0111\u01b0\u01a1ng \n\n\n\n\n\niex(16)> fun = &(&1 + &2)\n&:erlang.+/2\niex(17)> fun.(4, 9)\n13\n\n\niex(18)> fun = fn(x,y) -> x + y end\n\n\nFunction<12.52032458/2 in :erl_eval.expr/5>\n\n\niex(19)> fun.(4, 9)\n13\n\n\n\nPass function \u0111\u00f3 khi g\u1ecdi Enum.map\n\n\n\n\n\niex(20)> Enum.map([1,2,3], &(&1 * 2))\n[2, 4, 6]\niex(21)> Enum.map([1,2,3], fn x -> x * 2 end)\n[2, 4, 6]\n```",
            "title": "After basic"
        },
        {
            "location": "/after-basic/#sau-bat-au",
            "text": "Sau khi \u0111\u00e3 n\u1eafm \u0111\u01b0\u1ee3c c\u00fa ph\u00e1p c\u01a1 b\u1ea3n c\u1ee7a Elixir, ta c\u1ea7n g\u00ec \u0111\u00f3 \u0111\u1ec3 code. M\u1eb7c d\u00f9 l\u00e0m website l\u00e0 m\u1ed9t th\u1ebf m\u1ea1nh c\u1ee7a Elixir, nh\u01b0ng n\u1ebfu trong \u0111\u1ea7u b\u1ea1n kh\u00f4ng ngh\u0129 ra ngay m\u1ed9t webapp n\u00e0o b\u1ea1n c\u1ea7n l\u00e0m, th\u00ec \u0111i theo con \u0111\u01b0\u1eddng \u1ea5y l\u00e0 kh\u00f4ng t\u1ed1i \u01b0u. B\u1edfi n\u1ebfu ch\u1ec9 l\u00e0m xong tutorial v\u00e0 l\u00e0m ra m\u1ed9t trang web v\u00ed d\u1ee5 n\u00e0o \u0111\u00f3, m\u1ecdi ki\u1ebfn th\u1ee9c l\u1ea1i tr\u00f4i v\u00e0o qu\u00ean l\u00e3ng.  V\u1eady n\u00ean trong th\u1eddi gian ch\u1edd c\u00e1c \u00fd t\u01b0\u1edfng hi\u1ec7n l\u00ean, ta ti\u1ebfp t\u1ee5c \u0111\u00e0o s\u00e2u v\u00e0o Elixir, nh\u01b0ng b\u1eb1ng c\u00e1ch gi\u1ea3i c\u00e1c b\u00e0i to\u00e1n tr\u00ean website: hackerrank.com. M\u1ee5c \"Functional programming\":\nhttps://www.hackerrank.com/domains/fp/intro  C\u00e1c v\u1ea5n \u0111\u1ec1 s\u1ebd \u0111i t\u1eeb d\u1ec5 \u0111\u1ebfn kh\u00f3. H\u00e3y b\u1eaft \u0111\u1ea7u v\u1edbi d\u1ec5:  https://www.hackerrank.com/challenges/fp-list-replication  B\u00e0i n\u00e0y y\u00eau c\u1ea7u cho \u0111\u1ea7u v\u00e0o l\u00e0 1 s\u1ed1 N, v\u00e0 m\u1ed9t d\u00e3y s\u1ed1 theo sau, m\u1ee5c ti\u00eau l\u00e0 t\u1ea1o ra m\u1ed9t d\u00e3y s\u1ed1 m\u00e0 m\u1ed7i s\u1ed1 l\u1eafp l\u1ea1i N l\u1ea7n.\nV\u00ed d\u1ee5 cho N=3, d\u00e3y s\u1ed1 2 3 4, c\u1ea7n in ra m\u00e0n h\u00ecnh:  2\n2\n2\n3\n3\n3\n4\n4\n4  Hai \u0111i\u1ec3m c\u1ea7n ch\u00fa \u00fd:\n- Ta c\u1ea7n bi\u1ebft \u0111\u1ecdc d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o tr\u00ean Elixir  Khi vi\u1ebft code trong b\u00e0i n\u00e0y, m\u00ecnh s\u1eed d\u1ee5ng m\u1ed9t t\u00ean bi\u1ebfn l\u00e0 \"S\", v\u00e0 m\u1ecdi l\u1ed7i k\u1ef3 l\u1ea1 b\u1eaft \u0111\u1ea7u x\u1ea3y ra, m\u1ecdi th\u1ee9 tr\u1edf l\u1ea1i b\u00ecnh th\u01b0\u1eddng n\u1ebfu s\u1eed d\u1ee5ng t\u00ean bi\u1ebfn l\u00e0 ch\u1eef s vi\u1ebft th\u01b0\u1eddng. TODO t\u00ecm hi\u1ec3u t\u1ea1i sao.  V\u1ea5n \u0111\u1ec1 th\u1ee9 2 l\u00e0 khi vi\u1ebft function tr\u1ea3 v\u1ec1 1 list, n\u1ebfu b\u1eadt iex l\u00ean v\u00e0 in k\u1ebft qu\u1ea3 function tr\u1ea3 v\u1ec1 s\u1ebd th\u1ea5y list \u0111\u00f3, nh\u01b0ng n\u1ebfu vi\u1ebft code IO.puts myfunc() th\u00ec ch\u1ec9 th\u1ea5y k\u1ebft qu\u1ea3 in ra d\u00f2ng tr\u1eafng.",
            "title": "Sau b\u1eaft \u0111\u1ea7u"
        },
        {
            "location": "/after-basic/#todo-tai-sao",
            "text": "https://www.hackerrank.com/challenges/fp-filter-array",
            "title": "TODO t\u1ea1i sao?"
        },
        {
            "location": "/after-basic/#todo",
            "text": "why it still can compare string with number  why [head|tail] and there is a case head == \"\" ?\nbecause of how I split string  data = IO.read(:stdio, :all) |> String.trim |> String.split([\" \", \"\\n\"])  Add String.trim to clean thing up",
            "title": "TODO"
        },
        {
            "location": "/after-basic/#filter-odd-element",
            "text": "iex(1)> Enum.with_index [\"a\", \"b\", \"c\"]\n[{\"a\", 0}, {\"b\", 1}, {\"c\", 2}]",
            "title": "Filter odd element:"
        },
        {
            "location": "/after-basic/#process",
            "text": "extremely lightweight not like thread in other lang  spawn/1 : spawning new process\nspawn/1 takes a function\nreturn a PID  Process.alive?(pid)  Retrieve the PID of the current process by calling self/0  send message:\nsend/2: TO, MESSAGE  when msg is sent to a process, the msg is stored in the process mailbox.  receive/1 searching for 1 msg that match a given pattern in mailbox.  send/2 does not block  receive block or can be timeout.  flush/0 flushes and print all msgs in the mailbox  spawn_link/1: like spawn, but link to parrent  \"failing fast\" is a common philosophy in Elixir world  Task.start/1 and Task.start_link/1  return {:ok, pid}  Storing \"state\": http://elixir-lang.org/getting-started/processes.html  Process.register(pid, NAME)\nsend NAME, VALUE  Agent is an abstract for that.",
            "title": "Process"
        },
        {
            "location": "/after-basic/#todo-otp",
            "text": "http://elixir-lang.org/getting-started/processes.html  ====\nModule  alias Foo.Bar, as Bar\nlike import FooBar as Bar  # Python  require Foo # ensuring the module is compiled and available (usually for macro)  import Foo # import functions from Foo module, so can call without  Foo.  - auto require it  use Foo # ch\u1ea1y custom code trong Foo  alias/require/import : directive v\u00ec c\u00f3 lexical scope\nV\u00ec l\u00e0 lexical scope n\u00ean c\u00f3 th\u1ec3 set alias trong function\nv\u00e0 ch\u1ec9 c\u00f3 th\u1ec3 d\u00f9ng trong function \u0111\u00f3.  Macro:\ncode that generates code.\nExecuted and expanded at compilation time.  iex(14)> require Integer\nInteger\niex(15)> In\nInspect    Integer\niex(15)> Integer.is_\nis_even/1    is_odd/1\niex(15)> Integer.is_odd(3)\ntrue  iex(16)> import List, only: [duplicate: 2]\nList  only: :macros\n only: :functions\n except: somethign  An alias in Elixir is a capitalized identifier which is converted to an atom during compilation.",
            "title": "TODO OTP"
        },
        {
            "location": "/after-basic/#module-attributes",
            "text": "annotate the module\nconstant\ntemporary module storage  @moduledoc # doc for module\n@doc # doc for func\n@behaviour\n@before_compile  defmodule Math do\n  @moduledoc \"\"\"  <--- heredocs: Markdown\n  doc go\n  \"\"\"  @doc \"\"\"\n  calculate ...\n  \"\"\"\n  def sum(a,b), do: a + b\nend",
            "title": "Module attributes"
        },
        {
            "location": "/after-basic/#constant",
            "text": "Exist only during compilation time  @initial_state %{host: \"127.0.0.1\", port:3456}",
            "title": "Constant"
        },
        {
            "location": "/after-basic/#todo-later",
            "text": "",
            "title": "TODO later"
        },
        {
            "location": "/after-basic/#struct",
            "text": "Built on top of maps\nprovide: compile-time checks and default value  defmodule User do\n  defstruct name: \"HVN\", age: 27\n  end  Structs take the name of the module they\u2019re defined in.  Same syntax with map  structs are bare maps (just storage,access, no protocol  default is nil\n@enforce_keys [:make]",
            "title": "Struct"
        },
        {
            "location": "/after-basic/#protocol",
            "text": "http://elixir-lang.org/getting-started/protocols.html  English: dispatching on a protocol\ndispatch : send off to a dest  Protocol definition:  defprotocol Size do\n  @doc \"Calculate the size of a data structure\"\n  def size(data)\nend  defimpl Size, for: Map do\n  def size(map), do: map_size(map)\nend  Then we can use it for multiple data type => polymophism",
            "title": "Protocol"
        },
        {
            "location": "/after-basic/#protocol-and-struct",
            "text": "defimpl Size, for: MapSet do\n  def size(set), do: MapSet.size(set)\n  end",
            "title": "Protocol and struct"
        },
        {
            "location": "/after-basic/#derive-a-protocol-impolementation-for-all-t-ype",
            "text": "use  Any  defimpl Size, for: Any do\n  def size(_), do: 0  defmodule OtherUser do\n  @derive [Size]\n  defstruct [:name, :age]\nend  Fallback  @fallback_to_any true  Builtin protocol\nEnumerable (map/reduce ...)\nString.Chars (to_string)\nInspect protocol",
            "title": "Derive a protocol impolementation for all t ype:"
        },
        {
            "location": "/after-basic/#protocol-consolidation",
            "text": "English: consolidation : strengthen, make stronger.",
            "title": "Protocol consolidation"
        },
        {
            "location": "/after-basic/#sigils",
            "text": "Sigil: start with the tilde ( ~ ), followed by a letter (which identify the sigil)  Regular expression\n~r/foo|bar/  \"foo\" =~ regex # match regex  PRARE.  \"HELLO\" =~ ~r/hello/i # i is modifier  Sigils support 8 different delimiters.  / | \" ' ( [ { <  Sigils\n- Regex: ~r\n- String: ~s\n- Char list: ~c\n- Word list: ~w(foo bar bat)\n- ~S no escappe/interpolation",
            "title": "Sigils"
        },
        {
            "location": "/after-basic/#typespec",
            "text": "Function spec  :: means that the function on the left side returns a value whose type is what\u2019s on the right side. Function specs are written with the @spec directive, placed right before the function definition. The round/1 function could be written as:  @spec round(number) :: integer\ndef round(number), do: # implementation..",
            "title": "Typespec"
        },
        {
            "location": "/after-basic/#behaviours",
            "text": "is a specification for composable module  defmodule Parser do\n  @callback parse(String.t) :: any\n  @callback extensions() :: [String.t]\nend  Adopting behaviours:  defmodule JSONParser do\n  @behaviour Parser\n\n  def parse(str), do: ...\n\n\nend\n\n\n\n## Erlang Library\n\n:io.format(\"Pi ~10.3f~n\", [:math.pi])\n\n# :crypto\n- not standard,\n\n:crypto.hash(:sha256, \"Elixir\")\n\n# :digraph\nDealing with directed graphs\n\n# ETS - Erlang term storage\nDets: disk ETS\nallow to create a table containing tuples.\n\nFunction in ets module wil modify the state of the table as\na side-effect.\n\n\n\niex(8)> :ets.insert(table, {\"HVN\", 27})\ntrue\niex(9)> :ets.i(table)\n<1   > {<<\"HVN\">>,27}\nEOT  (q)uit (p)Digits (k)ill /Regexp -->1\nEOT  (q)uit (p)Digits (k)ill /Regexp -->2\nEOT  (q)uit (p)Digits (k)ill /Regexp -->q\n:ok\n\n\n## :math\n\n:math.sin\n:math.exp\n:math.log\n\n\n\n## :queue\nFIFO\n\n\nq = :queue.new\nq = :queue.in(\"A\", q)\n\n{value, q} = :queue.out(q)\n\n\n## :rand\n\n:rand.uniform\n:rand.seed\n\n\n## :zip\n\n:zip.foldl(...)\n\n:zlib\n\n\n## Mix and OTP\n\n### Agent\nis simple wrapper around state.\n\n\n\natoms are not garbage collected.\n\n### GenServer\n\ncall: sync\ncast: async\n\n\n\n\nhttp://erlang.org/pipermail/erlang-questions/2014-November/081570.html#\nhttps://blog.codeship.com/concurrency-in-elixir/\n\n\n\n\n\n### Enum functions\n\nEnum.concat/1 : n\u1ed1i c\u00e1c enumerable trong 1 enumerable (e.g flatten a list)\n\nEnum.chunk/2 \n\ndef chunk(enumerable, count)\nShortcut to chunk(enumerable, count, count).\n\nC\u1eaft enum th\u00e0nh `count` enum nh\u1ecf h\u01a1n:\n\niex(3)> Enum.chunk([1,2,3,4,5,6], 3)\n[[1, 2, 3], [4, 5, 6]]\niex(4)> Enum.chunk([1,2,3,4,5,6], 2)\n[[1, 2], [3, 4], [5, 6]]\n\n\niex(6)> Enum.dedup([1,2,2,1,2,2,2,1,1,])\n[1, 2, 1, 2, 1]\niex(7)> Enum.uniq([1,2,2,1,2,2,2,1,1,])\n[1, 2]\n\niex(8)> Enum.empty?([])\ntrue\n\niex(9)> Enum.zip([1,2,3], [\"meo\", \"cho\", \"ga\", \"trau\"])\n[{1, \"meo\"}, {2, \"cho\"}, {3, \"ga\"}]\n\nTrong Elixir, function kh\u00f4ng ph\u1ea3i first-class citizen.\nTa kh\u00f4ng th\u1ec3 pass 1 function c\u00f3 t\u00ean th\u00e0nh argument cho function kh\u00e1c.  iex(10)> is_function(rem)\n** (CompileError) iex:10: undefined function rem/0  iex(10)> is_function(rem/2)\n** (CompileError) iex:10: undefined function rem/0\n    (stdlib) lists.erl:1354: :lists.mapfoldl/3  \nFunction capturing cho ph\u00e9p \"capture\" m\u1ed9t function c\u00f3 t\u00ean th\u00e0nh m\u1ed9t anonymous function, v\u00e0 l\u00fac \u0111\u00f3 ta c\u00f3 th\u1ec3 g\u00e1n n\u00f3, g\u1ecdi n\u00f3 nh\u01b0 argument:\n\nC\u00f3 2 c\u00fa ph\u00e1p \u0111\u1ec3 capture function, m\u1ed9t l\u00e0 d\u00f9ng function/arity, c\u00e1ch kh\u00e1c l\u00e0 d\u00f9ng capture \u0111\u1ec3 bi\u1ec3u di\u1ec5n l\u01b0\u1ee3ng argument m\u00e0 function nh\u1eadn v\u00e0o:\n\niex(12)> fun = &rem/2\n&:erlang.rem/2\niex(13)> fun = &rem(&1, &2)\n&:erlang.rem/2\niex(14)> fun.(5,2)\n1\n\n\u0110\u1ec3 g\u1ecdi anonymous function, ph\u1ea3i d\u00f9ng d\u1ea5u `.` gi\u1eefa t\u00ean bi\u1ebfn v\u00e0 d\u1ea5u g\u1ecdi function `()`.\n\nHai anonymous function sau l\u00e0 t\u01b0\u01a1ng \u0111\u01b0\u01a1ng   iex(16)> fun = &(&1 + &2)\n&:erlang.+/2\niex(17)> fun.(4, 9)\n13  iex(18)> fun = fn(x,y) -> x + y end",
            "title": "Behaviours"
        },
        {
            "location": "/after-basic/#function12520324582-in-erl_evalexpr5",
            "text": "iex(19)> fun.(4, 9)\n13  \nPass function \u0111\u00f3 khi g\u1ecdi Enum.map  iex(20)> Enum.map([1,2,3], &(&1 * 2))\n[2, 4, 6]\niex(21)> Enum.map([1,2,3], fn x -> x * 2 end)\n[2, 4, 6]\n```",
            "title": "Function&lt;12.52032458/2 in :erl_eval.expr/5&gt;"
        },
        {
            "location": "/http-client/",
            "text": "HTTP & JSON\n\n\nSau khi \u0111\u00e3 n\u1eafm \u0111\u01b0\u1ee3c c\u00e1c kh\u00e1i ni\u1ec7m c\u01a1 b\u1ea3n c\u1ee7a Elixir, th\u00ec m\u1ed9t vi\u1ec7c \u1eaft ph\u1ea3i l\u00e0m v\u00ec v\u00f4 c\u00f9ng quan tr\u1ecdng: \u0111\u00f3 l\u00e0 bi\u1ebft c\u00e1ch d\u00f9ng th\u01b0 vi\u1ec7n ngo\u00e0i (th\u01b0 vi\u1ec7n kh\u00f4ng c\u00f3 s\u1eb5n khi c\u00e0i Elixir/ th\u01b0 vi\u1ec7n b\u00ean th\u1ee9 3).\n\n\nCh\u1ecdn th\u01b0 vi\u1ec7n n\u00e0o?\n\n\nC\u00e2u h\u1ecfi t\u01b0\u1edfng ch\u1eebng \u0111\u01a1n gi\u1ea3n n\u00e0y th\u1ef1c ra l\u00e0 m\u1ed9t c\u00e2u h\u1ecfi r\u1ea5t nguy hi\u1ec3m, kh\u00f3 tr\u1ea3 l\u1eddi, c\u0169ng c\u00f9ng ki\u1ec3u nh\u01b0 c\u00e2u \"t\u1ed1i nay \u0103n g\u00ec\" \u0111\u00e3 khi\u1ebfn cho h\u00e0ng ng\u00e0n c\u1eb7p \u0111\u00f4i r\u01a1i v\u00e0o nh\u1eefng cu\u1ed9c c\u00e3i c\u1ecd...\n\n\nTa kh\u00f4ng c\u1ea7n ph\u1ea3i \u0111au \u0111\u1ea7u hay \u0111\u1eafn \u0111o g\u00ec, m\u1ed9t th\u01b0 vi\u1ec7n h\u1ed7 tr\u1ee3 g\u1eedi HTTP request (GET/POST) s\u1ebd l\u00e0 th\u1ee9 h\u1eefu d\u1ee5ng v\u00e0 th\u1ef1c t\u1ebf nh\u1ea5t b\u1ea1n c\u00f3 th\u1ec3 d\u00f9ng. Ch\u1ec9 \u0111\u01a1n thu\u1ea7n bi\u1ebft d\u00f9ng HTTP client g\u1ecdi v\u00e0o c\u00e1c API, ta \u0111\u00e3 c\u00f3 m\u1ed9t \u0111\u1ed1ng d\u1eef li\u1ec7u \u0111\u1ec3 l\u00e0m ra m\u1ed9t c\u00e1i g\u00ec \u0111\u00f3 c\u00f3 \u00edch.\nD\u1eef li\u1ec7u tr\u1ea3 v\u1ec1 khi ta g\u1ecdi c\u00e1c API s\u1ebd c\u00f3 format JSON, m\u1ed9t th\u01b0 vi\u1ec7n JSON s\u1ebd l\u00e0 v\u00f4 c\u00f9ng quan tr\u1ecdng \u1edf \u0111\u00e2y.\n\n\nHTTPotion - HTTP client\n\n\nElixir ch\u1ea1y tr\u00ean m\u00e1y \u1ea3o BEAM c\u1ee7a Erlang, n\u00ean th\u01b0 vi\u1ec7n HTTP client c\u1ee7a Erlang th\u00ec \u0111\u00e3 s\u1eb5n, ho\u00e0n thi\u1ec7n h\u00e0ng ch\u1ee5c n\u0103m r\u1ed3i. Ng\u01b0\u1eddi ta ch\u1ec9 c\u1ea7n th\u00eam b\u1edbt m\u1ed9t ch\u00fat sao cho tr\u00f4ng n\u00f3 \"Elixir\" h\u01a1n l\u00e0 \u0111\u01b0\u1ee3c.\n\n\nHTTPotion\n l\u00e0 th\u01b0 vi\u1ec7n \u0111\u01b0\u1ee3c l\u1ef1a ch\u1ecdn \u1edf \u0111\u00e2y, n\u00f3 c\u0169ng c\u00f3 v\u1ebb l\u00e0 th\u01b0 vi\u1ec7n ph\u1ed5 bi\u1ebfn nh\u1ea5t trong c\u00e1c HTTP client c\u1ee7a Elixir.  HTTPotion x\u00e2y d\u1ef1ng d\u1ef1a tr\u00ean th\u01b0 vi\u1ec7n \"hackney\" c\u1ee7a Erlang.\n\n\nVi\u1ec7c qu\u1ea3n l\u00fd c\u00e1c th\u01b0 vi\u1ec7n \u0111\u01b0\u1ee3c Mix x\u1eed l\u00fd r\u1ea5t \u0111\u01a1n gi\u1ea3n:\n- Th\u00eam t\u00ean c\u1ee7a th\u01b0 vi\u1ec7n v\u00e0o list trong function \ndeps\n\n- Ch\u1ea1y \nmix deps.get\n \u0111\u1ec3 t\u1ea3i th\u01b0 vi\u1ec7n v\u1ec1\n- B\u1eadt \niex -S mix\n \u0111\u1ec3 load th\u01b0 vi\u1ec7n v\u00e0o r\u1ed3i d\u00f9ng trong ch\u1ebf \u0111\u1ed9 interactive.\n\n\ndefp deps do\n  [\n    {:poison, \"~> 3.1\"}\n    {:httpotion, \"~> 3.0.2\"},\n    #...\n  ]\nend\n\n\n\n\nPoison - JSON library\n\n\nTa c\u00e0i \nth\u01b0 vi\u1ec7n Poison - th\u01b0 vi\u1ec7n x\u1eed l\u00fd JSON\n ph\u1ed5 bi\u1ebfn nh\u1ea5t c\u1ee7a Elixir.\n\n\nL\u1ea5y d\u1eef li\u1ec7u t\u1eeb GitHub API\n\n\nTh\u1eed d\u00f9ng b\u1ed9 \u0111\u00f4i th\u01b0 vi\u1ec7n n\u00e0y \u0111\u1ec3 l\u1ea5y danh s\u00e1ch c\u00e1c contributor c\u1ee7a \nSaltStack\n d\u00f9ng GitHub API:\n\n\niex(2)> {:ok, response} = HTTPoison.get \"https://api.github.com/repos/saltstack/salt/contributors?page=3\"\n{:ok,\n %HTTPoison.Response{body: \"[{\\\"login\\\":\\\"kjkuan\\\",\\\"id\\\":973329,\\\"avatar_url\\\":\\\"\n...\n\niex(5)> {:ok, contribs} = Poison.decode(Map.get(response, :body))\n{:ok,\n [%{\"avatar_url\" => \"https://avatars3.githubusercontent.com/u/973329?v=3\",\n    \"contributions\" => 88,\n    \"events_url\" => \"https://api.github.com/users/kjkuan/events{/privacy}\",\n...\n\niex(6)> contribs |> Enum.map(fn contrib -> Map.get(contrib, \"login\") end)\n[\"kjkuan\", \"thedrow\", \"alexbleotu\", \"bdrung\", \"robertkeizer\", \"hvnsweeting\",\n \"jhutchins\", \"giantlock\", \"aboe76\", \"multani\", \"herlo\", \"0xf10e\", \"ranl\",\n \"evinrude\", \"baijum\", \"cedwards\", \"lorengordon\", \"syphernl\", \"bbinet\", \"m03\",\n \"kaithar\", \"MTecknology\", \"rominf\", \"akissa\", \"claudiupopescu\", \"jodv\",\n \"inthecloud247\", \"castor-morveer\", \"fxdgear\", \"markusgattol\"]\n\n\n\n\n\u0110\u01a1n gi\u1ea3n, ng\u1eafn g\u1ecdn, s\u1ea1ch s\u1ebd \ud83c\udfc6",
            "title": "Http client"
        },
        {
            "location": "/http-client/#http-json",
            "text": "Sau khi \u0111\u00e3 n\u1eafm \u0111\u01b0\u1ee3c c\u00e1c kh\u00e1i ni\u1ec7m c\u01a1 b\u1ea3n c\u1ee7a Elixir, th\u00ec m\u1ed9t vi\u1ec7c \u1eaft ph\u1ea3i l\u00e0m v\u00ec v\u00f4 c\u00f9ng quan tr\u1ecdng: \u0111\u00f3 l\u00e0 bi\u1ebft c\u00e1ch d\u00f9ng th\u01b0 vi\u1ec7n ngo\u00e0i (th\u01b0 vi\u1ec7n kh\u00f4ng c\u00f3 s\u1eb5n khi c\u00e0i Elixir/ th\u01b0 vi\u1ec7n b\u00ean th\u1ee9 3).",
            "title": "HTTP &amp; JSON"
        },
        {
            "location": "/http-client/#chon-thu-vien-nao",
            "text": "C\u00e2u h\u1ecfi t\u01b0\u1edfng ch\u1eebng \u0111\u01a1n gi\u1ea3n n\u00e0y th\u1ef1c ra l\u00e0 m\u1ed9t c\u00e2u h\u1ecfi r\u1ea5t nguy hi\u1ec3m, kh\u00f3 tr\u1ea3 l\u1eddi, c\u0169ng c\u00f9ng ki\u1ec3u nh\u01b0 c\u00e2u \"t\u1ed1i nay \u0103n g\u00ec\" \u0111\u00e3 khi\u1ebfn cho h\u00e0ng ng\u00e0n c\u1eb7p \u0111\u00f4i r\u01a1i v\u00e0o nh\u1eefng cu\u1ed9c c\u00e3i c\u1ecd...  Ta kh\u00f4ng c\u1ea7n ph\u1ea3i \u0111au \u0111\u1ea7u hay \u0111\u1eafn \u0111o g\u00ec, m\u1ed9t th\u01b0 vi\u1ec7n h\u1ed7 tr\u1ee3 g\u1eedi HTTP request (GET/POST) s\u1ebd l\u00e0 th\u1ee9 h\u1eefu d\u1ee5ng v\u00e0 th\u1ef1c t\u1ebf nh\u1ea5t b\u1ea1n c\u00f3 th\u1ec3 d\u00f9ng. Ch\u1ec9 \u0111\u01a1n thu\u1ea7n bi\u1ebft d\u00f9ng HTTP client g\u1ecdi v\u00e0o c\u00e1c API, ta \u0111\u00e3 c\u00f3 m\u1ed9t \u0111\u1ed1ng d\u1eef li\u1ec7u \u0111\u1ec3 l\u00e0m ra m\u1ed9t c\u00e1i g\u00ec \u0111\u00f3 c\u00f3 \u00edch.\nD\u1eef li\u1ec7u tr\u1ea3 v\u1ec1 khi ta g\u1ecdi c\u00e1c API s\u1ebd c\u00f3 format JSON, m\u1ed9t th\u01b0 vi\u1ec7n JSON s\u1ebd l\u00e0 v\u00f4 c\u00f9ng quan tr\u1ecdng \u1edf \u0111\u00e2y.",
            "title": "Ch\u1ecdn th\u01b0 vi\u1ec7n n\u00e0o?"
        },
        {
            "location": "/http-client/#httpotion-http-client",
            "text": "Elixir ch\u1ea1y tr\u00ean m\u00e1y \u1ea3o BEAM c\u1ee7a Erlang, n\u00ean th\u01b0 vi\u1ec7n HTTP client c\u1ee7a Erlang th\u00ec \u0111\u00e3 s\u1eb5n, ho\u00e0n thi\u1ec7n h\u00e0ng ch\u1ee5c n\u0103m r\u1ed3i. Ng\u01b0\u1eddi ta ch\u1ec9 c\u1ea7n th\u00eam b\u1edbt m\u1ed9t ch\u00fat sao cho tr\u00f4ng n\u00f3 \"Elixir\" h\u01a1n l\u00e0 \u0111\u01b0\u1ee3c.  HTTPotion  l\u00e0 th\u01b0 vi\u1ec7n \u0111\u01b0\u1ee3c l\u1ef1a ch\u1ecdn \u1edf \u0111\u00e2y, n\u00f3 c\u0169ng c\u00f3 v\u1ebb l\u00e0 th\u01b0 vi\u1ec7n ph\u1ed5 bi\u1ebfn nh\u1ea5t trong c\u00e1c HTTP client c\u1ee7a Elixir.  HTTPotion x\u00e2y d\u1ef1ng d\u1ef1a tr\u00ean th\u01b0 vi\u1ec7n \"hackney\" c\u1ee7a Erlang.  Vi\u1ec7c qu\u1ea3n l\u00fd c\u00e1c th\u01b0 vi\u1ec7n \u0111\u01b0\u1ee3c Mix x\u1eed l\u00fd r\u1ea5t \u0111\u01a1n gi\u1ea3n:\n- Th\u00eam t\u00ean c\u1ee7a th\u01b0 vi\u1ec7n v\u00e0o list trong function  deps \n- Ch\u1ea1y  mix deps.get  \u0111\u1ec3 t\u1ea3i th\u01b0 vi\u1ec7n v\u1ec1\n- B\u1eadt  iex -S mix  \u0111\u1ec3 load th\u01b0 vi\u1ec7n v\u00e0o r\u1ed3i d\u00f9ng trong ch\u1ebf \u0111\u1ed9 interactive.  defp deps do\n  [\n    {:poison, \"~> 3.1\"}\n    {:httpotion, \"~> 3.0.2\"},\n    #...\n  ]\nend",
            "title": "HTTPotion - HTTP client"
        },
        {
            "location": "/http-client/#poison-json-library",
            "text": "Ta c\u00e0i  th\u01b0 vi\u1ec7n Poison - th\u01b0 vi\u1ec7n x\u1eed l\u00fd JSON  ph\u1ed5 bi\u1ebfn nh\u1ea5t c\u1ee7a Elixir.",
            "title": "Poison - JSON library"
        },
        {
            "location": "/http-client/#lay-du-lieu-tu-github-api",
            "text": "Th\u1eed d\u00f9ng b\u1ed9 \u0111\u00f4i th\u01b0 vi\u1ec7n n\u00e0y \u0111\u1ec3 l\u1ea5y danh s\u00e1ch c\u00e1c contributor c\u1ee7a  SaltStack  d\u00f9ng GitHub API:  iex(2)> {:ok, response} = HTTPoison.get \"https://api.github.com/repos/saltstack/salt/contributors?page=3\"\n{:ok,\n %HTTPoison.Response{body: \"[{\\\"login\\\":\\\"kjkuan\\\",\\\"id\\\":973329,\\\"avatar_url\\\":\\\"\n...\n\niex(5)> {:ok, contribs} = Poison.decode(Map.get(response, :body))\n{:ok,\n [%{\"avatar_url\" => \"https://avatars3.githubusercontent.com/u/973329?v=3\",\n    \"contributions\" => 88,\n    \"events_url\" => \"https://api.github.com/users/kjkuan/events{/privacy}\",\n...\n\niex(6)> contribs |> Enum.map(fn contrib -> Map.get(contrib, \"login\") end)\n[\"kjkuan\", \"thedrow\", \"alexbleotu\", \"bdrung\", \"robertkeizer\", \"hvnsweeting\",\n \"jhutchins\", \"giantlock\", \"aboe76\", \"multani\", \"herlo\", \"0xf10e\", \"ranl\",\n \"evinrude\", \"baijum\", \"cedwards\", \"lorengordon\", \"syphernl\", \"bbinet\", \"m03\",\n \"kaithar\", \"MTecknology\", \"rominf\", \"akissa\", \"claudiupopescu\", \"jodv\",\n \"inthecloud247\", \"castor-morveer\", \"fxdgear\", \"markusgattol\"]  \u0110\u01a1n gi\u1ea3n, ng\u1eafn g\u1ecdn, s\u1ea1ch s\u1ebd \ud83c\udfc6",
            "title": "L\u1ea5y d\u1eef li\u1ec7u t\u1eeb GitHub API"
        },
        {
            "location": "/process/",
            "text": "D\u00f9 trong Elixir hay Python hay b\u1ea5t c\u1ee9 ng\u00f4n ng\u1eef n\u00e0o th\u00ec code c\u0169ng ch\u1ea1y trong process.\n\n\nNh\u01b0ng process trong Elixir (kh\u00f4ng ph\u1ea3i process cung c\u1ea5p b\u1edfi h\u1ec7 \u0111i\u1ec1u h\u00e0nh m\u00e0 l\u00e0 process do ch\u00ednh m\u00e1y \u1ea3o BEAM thi\u1ebft k\u1ebf v\u00e0 v\u1eadn h\u00e0nh) c\u00f3 nh\u1eefng t\u00ednh n\u0103ng v\u01b0\u1ee3t tr\u1ed9i gi\u00fap ng\u01b0\u1eddi d\u00f9ng c\u00f3 th\u1ec3 d\u1ec5 d\u00e0ng vi\u1ebft ch\u01b0\u01a1ng tr\u00ecnh ch\u1ea1y \u0111\u1ed3ng th\u1eddi, ph\u00e2n t\u00e1n.\n\n\nKh\u00e1i ni\u1ec7m process/thread lu\u00f4n l\u00e0 m\u1ed9t kh\u00e1i ni\u1ec7m ph\u1ee9c t\u1ea1p / l\u1eb1ng nh\u1eb1ng trong nh\u1eefng ng\u00f4n ng\u1eef kh\u00e1c nh\u01b0ng v\u1edbi Elixir/Erlang, n\u00f3 tr\u1edf n\u00ean \u0111\u01a1n gi\u1ea3n h\u01a1n nhi\u1ec1u.\n\n\nT\u1ea1o m\u1ed9t process\n\n\n\u0110\u1ec3 sinh m\u1ed9t process v\u00e0 ch\u1ea1y m\u1ed9t function trong process \u0111\u00f3, d\u00f9ng function \nspawn/1\n, function n\u00e0y tr\u1ea3 v\u1ec1 PID (process identifier) - m\u1ed9t con s\u1ed1 \u0111\u1ec3 x\u00e1c \u0111\u1ecbnh process n\u00e0y, gi\u00fap ta c\u00f3 th\u1ec3 g\u1eedi tin nh\u1eafn cho process n\u00e0y hay t\u1eaft n\u00f3...\n\n\niex(9)> pid = spawn fn -> 1 + 2 end\n#PID<0.93.0>\n\n\n\n\nNgay khi ch\u1ea1y xong function, process s\u1ebd t\u1ef1 k\u1ebft th\u00fac. Ki\u1ec3m tra xem process c\u00f2n s\u1ed1ng kh\u00f4ng:\n\n\niex(11)> h Process.alive?/1\n\nReturns true if the process exists and is alive (i.e. it is not exiting and has\nnot exited yet). Otherwise, returns false.\n\npid must refer to a process at the local node.\n\niex(12)> Process.alive? pid\nfalse\n\n\n\n\nK\u1ebft qu\u1ea3 l\u00e0 false, t\u1ee9c process c\u1ee7a ta \u0111\u00e3 ch\u1ebft (exit) sau khi n\u00f3 ho\u00e0n th\u00e0nh function.\n\n\nKi\u1ec3m tra process ch\u00ednh \u0111ang ch\u1ea1y ch\u01b0\u01a1ng tr\u00ecnh m\u00e0 ta \u0111ang g\u00f5 l\u1ec7nh:\n\n\niex(13)> Process.alive? self()\ntrue\niex(14)> self()\n#PID<0.80.0>\n\n\n\n\nself/0\n tr\u1ea3 v\u1ec1 PID c\u1ee7a process hi\u1ec7n t\u1ea1i.\n\n\nG\u1eedi nh\u1eadn message /\u02c8m\u025bs\u026ad\u0292/\n\n\nWhen a message is sent to a process, the message is stored in the process mailbox. The receive/1 block goes through the current process mailbox searching for a message that matches any of the given patterns. receive/1 supports guards and many clauses, such as case/2.\n\n\nActor model\n\n\nC\u00e1c process trong Elixir c\u00f3 th\u1ec3 g\u1eedi message (tin nh\u1eafn) cho nhau. \u0110\u00e2y l\u00e0 c\u01a1 ch\u1ebf ho\u1ea1t \u0111\u1ed9ng c\u1ee7a Erlang/Elixir khi 2 process c\u1ea7n trao \u0111\u1ed5i b\u1ea5t k\u1ef3 th\u00f4ng tin g\u00ec v\u00e0 th\u01b0\u1eddng \u0111\u01b0\u1ee3c nh\u1eafc t\u1edbi nh\u01b0 \"Actor model\".\n\n\nAsynchronous /e\u026a\u02c8s\u026a\u014bkr\u0259n\u0259s/\n\n\nKhi process X g\u1eedi message t\u1edbi process Y, message n\u00e0y \u0111\u01b0\u1ee3c ch\u1ee9a trong mailbox c\u1ee7a Y. G\u1eedi xong X s\u1ebd ti\u1ebfp t\u1ee5c c\u00f4ng vi\u1ec7c c\u1ee7a n\u00f3 ch\u1ee9 kh\u00f4ng \u0111\u1ee3i (block) Y nh\u1eadn hay x\u1eed l\u00fd message. C\u01a1 ch\u1ebf kh\u00f4ng \u0111\u1ee3i n\u00e0y g\u1ecdi l\u00e0  asynchronous (c\u00f3 t\u00ednh b\u1ea5t/kh\u00f4ng \u0111\u1ed3ng b\u1ed9)\n C\u00fa ph\u00e1p g\u1eedi r\u1ea5t \u0111\u01a1n gi\u1ea3n:\n\n\niex(22)> me = self()\n#PID<0.80.0>\niex(23)> send me, {:hello, \"world\"}\n{:hello, \"world\"}\niex(24)> send me, {:hello, \"PyMi\"}\n{:hello, \"PyMi\"}\niex(25)> receive do\n...(25)>   msg -> msg\n...(25)> end\n{:hello, \"world\"}\niex(26)> receive do\n...(26)>   msg -> msg\n...(26)> end\n{:hello, \"PyMi\"}\niex(27)>\n\n\n\n\nMessage \u0111\u01b0\u1ee3c g\u1eedi (t\u1eeb ch\u00ednh process hi\u1ec7n t\u1ea1i) \u0111\u01b0\u1ee3c ch\u1ee9a trong mailbox, khi d\u00f9ng \nreceive do... end\n, ta nh\u1eadn \u0111\u01b0\u1ee3c t\u1eebng message theo th\u1ee9 t\u1ef1 g\u1eedi tr\u01b0\u1edbc nh\u1eadn tr\u01b0\u1edbc (FIFO - queue).\n\n\nSynchronous /\u02c8s\u026a\u014bkr\u0259n\u0259s/\n\n\nV\u1edbi ng\u00f4n ng\u1eef kh\u00e1c, nh\u01b0 Golang, khi A g\u1eedi \"th\u00f4ng tin\" cho B quan channel, A s\u1ebd d\u1eebng l\u1ea1i, \u0111\u1ee3i (block) cho \u0111\u1ebfn khi B x\u1eed l\u00fd xong m\u1edbi ti\u1ebfp t\u1ee5c. C\u01a1 ch\u1ebf \u0111\u1ee3i \u0111\u1ed1i ph\u01b0\u01a1ng th\u1ef1c hi\u1ec7n nh\u01b0 th\u1ebf n\u00e0y g\u1ecdi l\u00e0 \"synchronous\" (c\u00f3 t\u00ednh \u0111\u1ed3ng b\u1ed9).\n\n\nReceive\n\n\nN\u1ebfu trong mailbox c\u00f3 message, process g\u1ecdi \nreceive do ...end\n s\u1ebd x\u1eed l\u00fd ngay message \u0111\u00f3, nh\u01b0ng n\u1ebfu kh\u00f4ng c\u00f3 message n\u00e0o, n\u00f3 s\u1ebd \u0111\u1ee3i (block) cho \u0111\u1ebfn khi c\u00f3 message.\nTr\u1eeb khi \u0111\u01b0\u1ee3c g\u1ecdi v\u1edbi \"after\" \u0111\u1ec3 th\u1ef1c hi\u1ec7n \"timeout\" sau m\u1ed9t kho\u1ea3n th\u1eddi gian c\u1ed1 \u0111\u1ecbnh. V\u00ed d\u1ee5 code sau s\u1ebd \u0111\u1ee3i message trong 2s (2000 milli gi\u00e2y):\n\n\niex(27)> receive do\n...(27)>   msg -> msg\n...(27)> after 2_000 -> \"Nothing after 2s\"\n...(27)> end\n\"Nothing after 2s\"\n\n\n\n\nreceive\n c\u00f3 h\u1ed7 tr\u1ee3 pattern matching.\n\n\nSinh process \u0111\u1ec3 g\u1eedi message\n\n\niex(28)> parent = self()\n#PID<0.80.0>\niex(29)> spawn fn -> send(parent, {:hello, self()}) end\n#PID<0.129.0>\niex(30)> receive do\n...(30)>   {:hello, pid} -> \"Got hello from #{inspect pid}\"\n...(30)> end\n\"Got hello from #PID<0.129.0>\"\n\n\n\n\nfunction \nflush/0\n gi\u00fap \"flush\" v\u00e0 in t\u1ea5t c\u1ea3 c\u00e1c messages \u0111ang n\u1eb1m trong mailbox.\n\n\niex(34)> send self(), 5\n5\niex(35)> send self(), 7\n7\niex(36)> send self(), 9\n9\niex(37)> flush()\n5\n7\n9\n:ok\n\n\n\n\nTasks\n\n\nTask l\u00e0 kh\u00e1i ni\u1ec7m x\u00e2y d\u1ef1ng tr\u00ean \nspawn/1\n \u0111\u1ec3 t\u1ea1o process, nh\u01b0ng cung c\u1ea5p nhi\u1ec1u t\u00ednh n\u0103ng h\u01a1n. C\u00e1ch d\u00f9ng t\u01b0\u01a1ng t\u1ef1 \nspawn/1\n nh\u01b0ng tr\u1ea3 v\u1ec1 tuple {:ok, pid} thay v\u00ec PID nh\u01b0 \nspawn/1\n\n\niex(32)> Task.start fn -> send(parent, {:hello, self()}) end\n{:ok, #PID<0.136.0>}\niex(33)> receive do\n...(33)>   {:hello, pid} -> \"Got hello from #{inspect pid}\"\n...(33)> end\n\"Got hello from #PID<0.136.0>\"\n\n\n\n\nG\u1eedi message qua l\u1ea1i gi\u1eefa 2 process\n\n\nNh\u1eefng v\u00ed d\u1ee5 \u0111\u01a1n gi\u1ea3n tr\u00ean ch\u1ec9 g\u1eedi message t\u1eeb m\u1ed9t process \u0111\u1ebfn process c\u00f2n l\u1ea1i m\u00e0 kh\u00f4ng h\u1ec1 c\u00f3 ph\u1ea3n h\u1ed3i,\n\u0111\u1ec3 process Y ph\u1ea3n h\u1ed3i sau khi nh\u1eadn \u0111\u01b0\u1ee3c message t\u1eeb X, Y ph\u1ea3i bi\u1ebft \"\u0111\u1ecba ch\u1ec9\" c\u1ee7a X - \u1edf \u0111\u00e2y l\u00e0 PID. V\u00ec v\u1eady khi g\u1eedi message, ta g\u1eedi k\u00e8m PID c\u1ee7a process g\u1eedi (gi\u1ed1ng nh\u01b0 g\u1eedi th\u01b0, mu\u1ed1n nh\u1eadn ph\u1ea3i ghi \u0111\u1ecba ch\u1ec9 ng\u01b0\u1eddi nh\u1eadn). \u0110\u1ec3 qu\u00e1 tr\u00ecnh n\u00e0y tr\u00f4ng gi\u1ed1ng nh\u01b0 2 process c\u00f9ng \u0111ang ch\u1ea1y v\u00e0 n\u00f3i chuy\u1ec7n v\u1edbi nhau, ta s\u1ebd vi\u1ebft function cho process nh\u1eadn s\u1ebd ch\u1ea1y m\u00e3i cho \u0111\u1ebfn khi nh\u1eadn \u0111\u01b0\u1ee3c message c\u00f3 ch\u1ee9a atom :quit.\n\n\n\u0110\u1ecbnh ngh\u0129a 1 module v\u00e0 vi\u1ebft v\u00e0o 1 file c\u00f3 t\u00ean b\u1ea5t k\u1ef3:\n\n\ndefmodule CoolProcess do\n  def loop() do\n    receive do\n      {:msg, msg, pid} ->\n        send(pid, {:msg, \"Got it:\" <> msg , self()})\n        loop()\n      {:quit, pid} ->\n        send(pid, {\"Goodbye\", self()})\n      {_, pid} ->\n        send(pid, {\"I dont understand you\", self()})\n        loop()\n      _ ->\n        IO.puts \"What?\"\n        loop()\n    end\n  end\n\n  def start_link do\n    Task.start_link(fn -> loop() end)\n  end\nend\n\n\n\n\n\n\u1ede m\u1ed7i tr\u01b0\u1eddng h\u1ee3p (tr\u1eeb {:quit, pid}), function loop() s\u1ebd g\u1ecdi l\u1ea1i ch\u00ednh n\u00f3, t\u1ea1o n\u00ean m\u1ed9t v\u00f2ng l\u1eb7p v\u00f4 h\u1ea1n, nh\u01b0ng ta s\u1ebd kh\u00f4ng b\u1ecb l\u1ed7i g\u00ec li\u00ean quan \u0111\u1ebfn gi\u1edbi h\u1ea1n recursive b\u1edfi c\u00e1c c\u00e2u g\u1ecdi \nloop()\n \u0111\u1ec1u l\u00e0 c\u00e2u l\u1ec7nh cu\u1ed1i c\u00f9ng, Elixir bi\u1ebft c\u00e1ch x\u1eed l\u00fd nh\u1eefng tr\u01b0\u1eddng h\u1ee3p nh\u01b0 v\u1eady - v\u00e0 n\u00f3 c\u00f3 t\u00ean l\u00e0 \"tail recursive\".\n\n\nGi\u1edd ch\u1ea1y \niex filename.exs\n v\u00e0 g\u1ecdi function c\u1ee7a CoolProcess.start_link/0 \u0111\u1ec3 t\u1ea1o m\u1ed9t process m\u1edbi,\ng\u1eedi c\u00e1c message \u0111\u1ebfn n\u00f3 v\u00e0 nh\u1eadn ph\u1ea3n h\u1ed3i, g\u1eedi {:quit, PID} \u0111\u1ec3 t\u1eaft process (do kh\u1ed1i code t\u01b0\u01a1ng\n\u1ee9ng khi nh\u1eadn \u0111\u01b0\u1ee3c :quit kh\u00f4ng g\u1ecdi loop() n\u1eefa )\n\n\niex(3)> {:ok, pid} = CoolProcess.start_link\n{:ok, #PID<0.90.0>}\niex(4)> Pro\nProcess     Protocol\niex(4)> Process.alive? pid\ntrue\niex(5)> send pid, {:msg, \"hello\", self()}\n{:msg, \"hello\", #PID<0.84.0>}\niex(6)> flush()\n{:msg, \"Got it:hello\", #PID<0.90.0>}\n:ok\niex(7)> send pid, {:nothing, self()}\n{:nothing, #PID<0.84.0>}\niex(8)> flush()\n{\"I dont understand you\", #PID<0.90.0>}\n:ok\niex(9)> send pid, {:quit, self()}\n{:quit, #PID<0.84.0>}\niex(10)> flush()\n{\"Goodbye\", #PID<0.90.0>}\n:ok\niex(11)> Process.alive? pid\nfalse\n\n\n\n\nNh\u1eefng kh\u00e1i ni\u1ec7m \"process\", send, receive kh\u00f4ng qu\u00e1 ph\u1ee9c t\u1ea1p l\u00e0 ph\u1ea7n c\u1ed1t y\u1ebfu \u0111\u1ec3u gi\u00fap Erlang/Elixir t\u1ea1o n\u00ean nh\u1eefng h\u1ec7 th\u1ed1ng c\u00f3 th\u1ec3 ch\u1ea1y h\u00e0ng tr\u0103m ng\u00e0n process c\u00f9ng m\u1ed9t l\u00fac. Khi v\u1ea5n \u0111\u1ec1 l\u00e0 m\u1ed9t, hai process, ch\u00fang ta quan t\u00e2m \u0111\u1ebfn t\u1eebng process, nh\u01b0ng khi b\u00e0i to\u00e1n l\u1edbn l\u00ean, ta s\u1ebd c\u1ea7n quan t\u00e2m \u0111\u1ebfn vi\u1ec7c l\u00e0m sao qu\u1ea3n l\u00fd \u0111\u01b0\u1ee3c nhi\u1ec1u process, v\u00e0 \u0111i\u1ec1u khi\u1ec3n ch\u00fang ch\u1ea1y th\u1ebf n\u00e0o cho ph\u00f9 h\u1ee3p. Ph\u1ea7n #TODO s\u1ebd \u0111i chi ti\u1ebft v\u00e0o vi\u1ec7c qu\u1ea3n l\u00fd c\u00e1c process v\u1edbi s\u1ee9c m\u1ea1nh c\u1ee7a OTP.\n\n\nTham kh\u1ea3o\n\n\n\n\nhttps://elixir-lang.org/getting-started/processes.html\n\n\nhttp://learnyousomeerlang.com/the-hitchhikers-guide-to-concurrency",
            "title": "Process"
        },
        {
            "location": "/process/#tao-mot-process",
            "text": "\u0110\u1ec3 sinh m\u1ed9t process v\u00e0 ch\u1ea1y m\u1ed9t function trong process \u0111\u00f3, d\u00f9ng function  spawn/1 , function n\u00e0y tr\u1ea3 v\u1ec1 PID (process identifier) - m\u1ed9t con s\u1ed1 \u0111\u1ec3 x\u00e1c \u0111\u1ecbnh process n\u00e0y, gi\u00fap ta c\u00f3 th\u1ec3 g\u1eedi tin nh\u1eafn cho process n\u00e0y hay t\u1eaft n\u00f3...  iex(9)> pid = spawn fn -> 1 + 2 end\n#PID<0.93.0>  Ngay khi ch\u1ea1y xong function, process s\u1ebd t\u1ef1 k\u1ebft th\u00fac. Ki\u1ec3m tra xem process c\u00f2n s\u1ed1ng kh\u00f4ng:  iex(11)> h Process.alive?/1\n\nReturns true if the process exists and is alive (i.e. it is not exiting and has\nnot exited yet). Otherwise, returns false.\n\npid must refer to a process at the local node.\n\niex(12)> Process.alive? pid\nfalse  K\u1ebft qu\u1ea3 l\u00e0 false, t\u1ee9c process c\u1ee7a ta \u0111\u00e3 ch\u1ebft (exit) sau khi n\u00f3 ho\u00e0n th\u00e0nh function.  Ki\u1ec3m tra process ch\u00ednh \u0111ang ch\u1ea1y ch\u01b0\u01a1ng tr\u00ecnh m\u00e0 ta \u0111ang g\u00f5 l\u1ec7nh:  iex(13)> Process.alive? self()\ntrue\niex(14)> self()\n#PID<0.80.0>  self/0  tr\u1ea3 v\u1ec1 PID c\u1ee7a process hi\u1ec7n t\u1ea1i.",
            "title": "T\u1ea1o m\u1ed9t process"
        },
        {
            "location": "/process/#gui-nhan-message-msd",
            "text": "When a message is sent to a process, the message is stored in the process mailbox. The receive/1 block goes through the current process mailbox searching for a message that matches any of the given patterns. receive/1 supports guards and many clauses, such as case/2.",
            "title": "G\u1eedi nh\u1eadn message /\u02c8m\u025bs\u026ad\u0292/"
        },
        {
            "location": "/process/#actor-model",
            "text": "C\u00e1c process trong Elixir c\u00f3 th\u1ec3 g\u1eedi message (tin nh\u1eafn) cho nhau. \u0110\u00e2y l\u00e0 c\u01a1 ch\u1ebf ho\u1ea1t \u0111\u1ed9ng c\u1ee7a Erlang/Elixir khi 2 process c\u1ea7n trao \u0111\u1ed5i b\u1ea5t k\u1ef3 th\u00f4ng tin g\u00ec v\u00e0 th\u01b0\u1eddng \u0111\u01b0\u1ee3c nh\u1eafc t\u1edbi nh\u01b0 \"Actor model\".",
            "title": "Actor model"
        },
        {
            "location": "/process/#asynchronous-eskrns",
            "text": "Khi process X g\u1eedi message t\u1edbi process Y, message n\u00e0y \u0111\u01b0\u1ee3c ch\u1ee9a trong mailbox c\u1ee7a Y. G\u1eedi xong X s\u1ebd ti\u1ebfp t\u1ee5c c\u00f4ng vi\u1ec7c c\u1ee7a n\u00f3 ch\u1ee9 kh\u00f4ng \u0111\u1ee3i (block) Y nh\u1eadn hay x\u1eed l\u00fd message. C\u01a1 ch\u1ebf kh\u00f4ng \u0111\u1ee3i n\u00e0y g\u1ecdi l\u00e0  asynchronous (c\u00f3 t\u00ednh b\u1ea5t/kh\u00f4ng \u0111\u1ed3ng b\u1ed9)\n C\u00fa ph\u00e1p g\u1eedi r\u1ea5t \u0111\u01a1n gi\u1ea3n:  iex(22)> me = self()\n#PID<0.80.0>\niex(23)> send me, {:hello, \"world\"}\n{:hello, \"world\"}\niex(24)> send me, {:hello, \"PyMi\"}\n{:hello, \"PyMi\"}\niex(25)> receive do\n...(25)>   msg -> msg\n...(25)> end\n{:hello, \"world\"}\niex(26)> receive do\n...(26)>   msg -> msg\n...(26)> end\n{:hello, \"PyMi\"}\niex(27)>  Message \u0111\u01b0\u1ee3c g\u1eedi (t\u1eeb ch\u00ednh process hi\u1ec7n t\u1ea1i) \u0111\u01b0\u1ee3c ch\u1ee9a trong mailbox, khi d\u00f9ng  receive do... end , ta nh\u1eadn \u0111\u01b0\u1ee3c t\u1eebng message theo th\u1ee9 t\u1ef1 g\u1eedi tr\u01b0\u1edbc nh\u1eadn tr\u01b0\u1edbc (FIFO - queue).",
            "title": "Asynchronous /e\u026a\u02c8s\u026a\u014bkr\u0259n\u0259s/"
        },
        {
            "location": "/process/#synchronous-skrns",
            "text": "V\u1edbi ng\u00f4n ng\u1eef kh\u00e1c, nh\u01b0 Golang, khi A g\u1eedi \"th\u00f4ng tin\" cho B quan channel, A s\u1ebd d\u1eebng l\u1ea1i, \u0111\u1ee3i (block) cho \u0111\u1ebfn khi B x\u1eed l\u00fd xong m\u1edbi ti\u1ebfp t\u1ee5c. C\u01a1 ch\u1ebf \u0111\u1ee3i \u0111\u1ed1i ph\u01b0\u01a1ng th\u1ef1c hi\u1ec7n nh\u01b0 th\u1ebf n\u00e0y g\u1ecdi l\u00e0 \"synchronous\" (c\u00f3 t\u00ednh \u0111\u1ed3ng b\u1ed9).",
            "title": "Synchronous /\u02c8s\u026a\u014bkr\u0259n\u0259s/"
        },
        {
            "location": "/process/#receive",
            "text": "N\u1ebfu trong mailbox c\u00f3 message, process g\u1ecdi  receive do ...end  s\u1ebd x\u1eed l\u00fd ngay message \u0111\u00f3, nh\u01b0ng n\u1ebfu kh\u00f4ng c\u00f3 message n\u00e0o, n\u00f3 s\u1ebd \u0111\u1ee3i (block) cho \u0111\u1ebfn khi c\u00f3 message.\nTr\u1eeb khi \u0111\u01b0\u1ee3c g\u1ecdi v\u1edbi \"after\" \u0111\u1ec3 th\u1ef1c hi\u1ec7n \"timeout\" sau m\u1ed9t kho\u1ea3n th\u1eddi gian c\u1ed1 \u0111\u1ecbnh. V\u00ed d\u1ee5 code sau s\u1ebd \u0111\u1ee3i message trong 2s (2000 milli gi\u00e2y):  iex(27)> receive do\n...(27)>   msg -> msg\n...(27)> after 2_000 -> \"Nothing after 2s\"\n...(27)> end\n\"Nothing after 2s\"  receive  c\u00f3 h\u1ed7 tr\u1ee3 pattern matching.",
            "title": "Receive"
        },
        {
            "location": "/process/#sinh-process-e-gui-message",
            "text": "iex(28)> parent = self()\n#PID<0.80.0>\niex(29)> spawn fn -> send(parent, {:hello, self()}) end\n#PID<0.129.0>\niex(30)> receive do\n...(30)>   {:hello, pid} -> \"Got hello from #{inspect pid}\"\n...(30)> end\n\"Got hello from #PID<0.129.0>\"  function  flush/0  gi\u00fap \"flush\" v\u00e0 in t\u1ea5t c\u1ea3 c\u00e1c messages \u0111ang n\u1eb1m trong mailbox.  iex(34)> send self(), 5\n5\niex(35)> send self(), 7\n7\niex(36)> send self(), 9\n9\niex(37)> flush()\n5\n7\n9\n:ok",
            "title": "Sinh process \u0111\u1ec3 g\u1eedi message"
        },
        {
            "location": "/process/#tasks",
            "text": "Task l\u00e0 kh\u00e1i ni\u1ec7m x\u00e2y d\u1ef1ng tr\u00ean  spawn/1  \u0111\u1ec3 t\u1ea1o process, nh\u01b0ng cung c\u1ea5p nhi\u1ec1u t\u00ednh n\u0103ng h\u01a1n. C\u00e1ch d\u00f9ng t\u01b0\u01a1ng t\u1ef1  spawn/1  nh\u01b0ng tr\u1ea3 v\u1ec1 tuple {:ok, pid} thay v\u00ec PID nh\u01b0  spawn/1  iex(32)> Task.start fn -> send(parent, {:hello, self()}) end\n{:ok, #PID<0.136.0>}\niex(33)> receive do\n...(33)>   {:hello, pid} -> \"Got hello from #{inspect pid}\"\n...(33)> end\n\"Got hello from #PID<0.136.0>\"",
            "title": "Tasks"
        },
        {
            "location": "/process/#gui-message-qua-lai-giua-2-process",
            "text": "Nh\u1eefng v\u00ed d\u1ee5 \u0111\u01a1n gi\u1ea3n tr\u00ean ch\u1ec9 g\u1eedi message t\u1eeb m\u1ed9t process \u0111\u1ebfn process c\u00f2n l\u1ea1i m\u00e0 kh\u00f4ng h\u1ec1 c\u00f3 ph\u1ea3n h\u1ed3i,\n\u0111\u1ec3 process Y ph\u1ea3n h\u1ed3i sau khi nh\u1eadn \u0111\u01b0\u1ee3c message t\u1eeb X, Y ph\u1ea3i bi\u1ebft \"\u0111\u1ecba ch\u1ec9\" c\u1ee7a X - \u1edf \u0111\u00e2y l\u00e0 PID. V\u00ec v\u1eady khi g\u1eedi message, ta g\u1eedi k\u00e8m PID c\u1ee7a process g\u1eedi (gi\u1ed1ng nh\u01b0 g\u1eedi th\u01b0, mu\u1ed1n nh\u1eadn ph\u1ea3i ghi \u0111\u1ecba ch\u1ec9 ng\u01b0\u1eddi nh\u1eadn). \u0110\u1ec3 qu\u00e1 tr\u00ecnh n\u00e0y tr\u00f4ng gi\u1ed1ng nh\u01b0 2 process c\u00f9ng \u0111ang ch\u1ea1y v\u00e0 n\u00f3i chuy\u1ec7n v\u1edbi nhau, ta s\u1ebd vi\u1ebft function cho process nh\u1eadn s\u1ebd ch\u1ea1y m\u00e3i cho \u0111\u1ebfn khi nh\u1eadn \u0111\u01b0\u1ee3c message c\u00f3 ch\u1ee9a atom :quit.  \u0110\u1ecbnh ngh\u0129a 1 module v\u00e0 vi\u1ebft v\u00e0o 1 file c\u00f3 t\u00ean b\u1ea5t k\u1ef3:  defmodule CoolProcess do\n  def loop() do\n    receive do\n      {:msg, msg, pid} ->\n        send(pid, {:msg, \"Got it:\" <> msg , self()})\n        loop()\n      {:quit, pid} ->\n        send(pid, {\"Goodbye\", self()})\n      {_, pid} ->\n        send(pid, {\"I dont understand you\", self()})\n        loop()\n      _ ->\n        IO.puts \"What?\"\n        loop()\n    end\n  end\n\n  def start_link do\n    Task.start_link(fn -> loop() end)\n  end\nend  \u1ede m\u1ed7i tr\u01b0\u1eddng h\u1ee3p (tr\u1eeb {:quit, pid}), function loop() s\u1ebd g\u1ecdi l\u1ea1i ch\u00ednh n\u00f3, t\u1ea1o n\u00ean m\u1ed9t v\u00f2ng l\u1eb7p v\u00f4 h\u1ea1n, nh\u01b0ng ta s\u1ebd kh\u00f4ng b\u1ecb l\u1ed7i g\u00ec li\u00ean quan \u0111\u1ebfn gi\u1edbi h\u1ea1n recursive b\u1edfi c\u00e1c c\u00e2u g\u1ecdi  loop()  \u0111\u1ec1u l\u00e0 c\u00e2u l\u1ec7nh cu\u1ed1i c\u00f9ng, Elixir bi\u1ebft c\u00e1ch x\u1eed l\u00fd nh\u1eefng tr\u01b0\u1eddng h\u1ee3p nh\u01b0 v\u1eady - v\u00e0 n\u00f3 c\u00f3 t\u00ean l\u00e0 \"tail recursive\".  Gi\u1edd ch\u1ea1y  iex filename.exs  v\u00e0 g\u1ecdi function c\u1ee7a CoolProcess.start_link/0 \u0111\u1ec3 t\u1ea1o m\u1ed9t process m\u1edbi,\ng\u1eedi c\u00e1c message \u0111\u1ebfn n\u00f3 v\u00e0 nh\u1eadn ph\u1ea3n h\u1ed3i, g\u1eedi {:quit, PID} \u0111\u1ec3 t\u1eaft process (do kh\u1ed1i code t\u01b0\u01a1ng\n\u1ee9ng khi nh\u1eadn \u0111\u01b0\u1ee3c :quit kh\u00f4ng g\u1ecdi loop() n\u1eefa )  iex(3)> {:ok, pid} = CoolProcess.start_link\n{:ok, #PID<0.90.0>}\niex(4)> Pro\nProcess     Protocol\niex(4)> Process.alive? pid\ntrue\niex(5)> send pid, {:msg, \"hello\", self()}\n{:msg, \"hello\", #PID<0.84.0>}\niex(6)> flush()\n{:msg, \"Got it:hello\", #PID<0.90.0>}\n:ok\niex(7)> send pid, {:nothing, self()}\n{:nothing, #PID<0.84.0>}\niex(8)> flush()\n{\"I dont understand you\", #PID<0.90.0>}\n:ok\niex(9)> send pid, {:quit, self()}\n{:quit, #PID<0.84.0>}\niex(10)> flush()\n{\"Goodbye\", #PID<0.90.0>}\n:ok\niex(11)> Process.alive? pid\nfalse  Nh\u1eefng kh\u00e1i ni\u1ec7m \"process\", send, receive kh\u00f4ng qu\u00e1 ph\u1ee9c t\u1ea1p l\u00e0 ph\u1ea7n c\u1ed1t y\u1ebfu \u0111\u1ec3u gi\u00fap Erlang/Elixir t\u1ea1o n\u00ean nh\u1eefng h\u1ec7 th\u1ed1ng c\u00f3 th\u1ec3 ch\u1ea1y h\u00e0ng tr\u0103m ng\u00e0n process c\u00f9ng m\u1ed9t l\u00fac. Khi v\u1ea5n \u0111\u1ec1 l\u00e0 m\u1ed9t, hai process, ch\u00fang ta quan t\u00e2m \u0111\u1ebfn t\u1eebng process, nh\u01b0ng khi b\u00e0i to\u00e1n l\u1edbn l\u00ean, ta s\u1ebd c\u1ea7n quan t\u00e2m \u0111\u1ebfn vi\u1ec7c l\u00e0m sao qu\u1ea3n l\u00fd \u0111\u01b0\u1ee3c nhi\u1ec1u process, v\u00e0 \u0111i\u1ec1u khi\u1ec3n ch\u00fang ch\u1ea1y th\u1ebf n\u00e0o cho ph\u00f9 h\u1ee3p. Ph\u1ea7n #TODO s\u1ebd \u0111i chi ti\u1ebft v\u00e0o vi\u1ec7c qu\u1ea3n l\u00fd c\u00e1c process v\u1edbi s\u1ee9c m\u1ea1nh c\u1ee7a OTP.",
            "title": "G\u1eedi message qua l\u1ea1i gi\u1eefa 2 process"
        },
        {
            "location": "/process/#tham-khao",
            "text": "https://elixir-lang.org/getting-started/processes.html  http://learnyousomeerlang.com/the-hitchhikers-guide-to-concurrency",
            "title": "Tham kh\u1ea3o"
        }
    ]
}