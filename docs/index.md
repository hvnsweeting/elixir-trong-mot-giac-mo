# Há»c Elixir trong má»™t giáº¥c mÆ¡
[BETA]

LÃ½ do báº¡n thÃ­ch há»c Haskell, LISP, Erlang, Elixir, Ocaml, Scala... nhá»¯ng ngÃ´n ngá»¯ láº­p trÃ¬nh hÃ m (functional programming language) cÃ³ váº» hay ho, mÃ  khÃ´ng bao giá» thÃ nh cÃ´ng lÃ  gÃ¬?

Sau Ä‘Ã¢y lÃ  vÃ i lÃ½ do mÃ¬nh gáº·p pháº£i:

- QuÃ¡ nhiá»u khÃ¡i niá»‡m má»›i
- Nhá»“i nhÃ©t háº¿t cÃ¡c khÃ¡i niá»‡m xong khÃ´ng cÃ³ gÃ¬ Ä‘á»ƒ lÃ m
- Chá»n ngÃ´n ngá»¯ "xá»‹n" nháº¥t: trong máº£nh Ä‘áº¥t functional programming, ráº¥t nhiá»u cÃ¡i tÃªn háº¥p dáº«n khÃ¡c nhÆ° Haskell, Ocaml, Racket, Scheme, CLisp, Scala,...

Äá»ƒ kháº¯c phá»¥c Ä‘iá»u nÃ y, ta sáº½:

- Chá»‰ táº­p trung vÃ o nhá»¯ng khÃ¡i niá»‡m Ä‘Ã£ quen thuá»™c, há»c tháº­t nhanh, tra cá»©u khi cáº§n
- CÃ³ má»™t Ã½ tÆ°á»Ÿng Ä‘á»ƒ thá»±c hiá»‡n
- Táº­p trung vÃ o Elixir vÃ¬ má»—i ngÃ´n ngá»¯ Ä‘á»u cÃ³ Ä‘iá»ƒm máº¡nh/ yáº¿u riÃªng, nhÆ°ng khi náº¯m Ä‘Æ°á»£c má»™t ngÃ´n ngá»¯, há»c cÃ¡c ngÃ´n ngá»¯ khÃ¡c sáº½ trá»Ÿ nÃªn dá»… dÃ ng hÆ¡n nhiá»u do Ä‘Ã£ quen thuá»™c cÃ¡c khÃ¡i  niá»‡m vÃ  lá»‘i tÆ° duy cá»§a functional programming.


Náº¿u khÃ´ng cÃ³ gÃ¬ Ä‘á»ƒ lÃ m, nuá»‘t xong cÃ¡c khÃ¡i niá»‡m, 1 tuáº§n sau báº¡n sáº½ láº¡i quÃªn.

Elixir/Erlang hoÃ n toÃ n Ä‘á»§ kháº£ nÄƒng Ä‘á»ƒ cho báº¡n láº­p trÃ¬nh loanh quanh máº¥y thuáº­t toÃ¡n, giáº£i cÃ¡c bÃ i toÃ¡n / váº¥n Ä‘á» trÃªn HackerRank. NhÆ°ng Ä‘iá»ƒm sÃ¡ng cá»§a ngÃ´n ngá»¯ nÃ y, thá»±c ra chá»‰ toáº£ sÃ¡ng khi ta dÃ¹ng nÃ³ Ä‘á»ƒ phÃ¡t triá»ƒn cÃ¡c há»‡ thá»‘ng lá»›n, cáº§n cháº¡y phÃ¢n tÃ¡n, hay cháº¡y song song... Ãt khi má»™t ngÆ°á»i sáº½ lÃ m háº³n má»™t project lá»›n nhÆ° váº­y. VÃ¬ váº­y, ta thÆ°á»ng khÃ´ng cÃ³ Ä‘áº¥t dÃ¹ng cho Elixir hay Erlang.

Má»™t cÃ¡ch á»©ng dá»¥ng Ä‘á»ƒ chÆ¡i vá»›i ngÃ´n ngá»¯ má»›i ná»¯a "nhá» hÆ¡n", lÃ  viáº¿t cÃ¡c cÃ¢u lá»‡nh thá»±c hiá»‡n má»™t viá»‡c gÃ¬ Ä‘Ã³ (CLI). Váº­y nhÆ°ng Elixir/Erlang khÃ´ng toáº£ sÃ¡ng/ Ä‘Æ¡n giáº£n trong cÃ´ng viá»‡c nÃ y, nÃ³ CÃ“ THá»‚ lÃ m Ä‘Æ°á»£c, nhÆ°ng trÃªn thá»±c táº¿ khÃ´ng máº¥y ai lÃ m.

VÃ­ dá»¥ standard khi há»c Erlang lÃ  lÃ m má»™t há»‡ thá»‘ng chat. TrÃªn thá»±c táº¿, há»‡ thá»‘ng chat cá»§a "Whatsapp" Ä‘Æ°á»£c viáº¿t báº±ng Erlang [há»‡ thá»‘ng nÃ y Ä‘Ã£ Ä‘Æ°á»£c bÃ¡n láº¡i cho FaceBook vá»›i giÃ¡ 19 Tá»¶ Ä‘Ã´ la Má»¹](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html) (PS: FaceBook trÆ°á»›c Ä‘Ã³ cÅ©ng Ä‘Ã£ mua láº¡i Instagram - má»™t há»‡ thá»‘ng viáº¿t báº±ng Django/Python vá»›i giÃ¡ 1 Tá»¶ Ä‘Ã´ la Má»¹)

Ta cÃ³ thá»ƒ lÃ m 1 website sau khi há»c Elixir, Ä‘Ã¢y lÃ  lÄ©nh vá»±c hiá»‡n táº¡i mÃ  Elixir máº¡nh nháº¥t.

ÄÃ£ xong pháº§n Ã½ tÆ°á»Ÿng, bÃ¢y giá» hÃ£y há»c Elixir.

Thá»±c hiá»‡n trÃªn:

```
$ elixir --version
Erlang/OTP 19 [erts-8.0.2] [source] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Elixir 1.3.2
```

PS: trong bÃ i cÃ³ má»™t sá»‘ Ä‘oáº¡n so sÃ¡nh vá»›i tÃ­nh nÄƒng tÆ°Æ¡ng tá»± trÃªn Python - bá»Ÿi tÃ¡c giáº£ lÃ  ngÆ°á»i cÃ³ kinh nghiá»‡m vá»›i Python - giÃºp cÃ¡c láº­p trÃ¬nh viÃªn Python dá»… káº¿t ná»‘i cÃ¡c khÃ¡i niá»‡m. Pháº§n so sÃ¡nh nÃ y hoÃ n toÃ n khÃ´ng cáº§n thiáº¿t vá»›i ngÆ°á»i khÃ´ng biáº¿t Python vÃ  cÃ³ thá»ƒ bá» qua.

## CÃ¡c kiá»ƒu dá»¯ liá»‡u cÆ¡ báº£n

### Integer

```
iex(33)> 42
42
iex(34)> i 42
Term
  42
Data type
  Integer
Reference modules
  Integer

DÃ¹ng ``i OBJECT`` Ä‘á»ƒ hiá»ƒn thá»‹ thÃ´ng tin vá» giÃ¡ trá»‹/ kiá»ƒu cá»§a object. NhÆ° "type(object)" trong Python hay "typeof object" trong JavaScript.
```

### Float

```
iex(35)> i 3.14
Term
  3.14
Data type
  Float
Reference modules
  Float

iex(36)> 0.1 + 0.1 + 0.1
0.30000000000000004
```

### Atom

```
iex(39)> i true
Term
  true
Data type
  Atom
Reference modules
  Atom
iex(40)> i false
Term
  false
Data type
  Atom
Reference modules
  Atom
```

### String

```
iex(42)> i "Elixir"
Term
  "Elixir"
Data type
  BitString
Byte size
  6
Description
  This is a string: a UTF-8 encoded binary. It's printed surrounded by
  "double quotes" because all UTF-8 encoded codepoints in it are printable.
Raw representation
  <<69, 108, 105, 120, 105, 114>>
Reference modules
  String, :binary
```

CÃ¡c kiá»ƒu dá»¯ liá»‡u chá»©a Ä‘Æ°á»£c kiá»ƒu khÃ¡c: list, tuple, dict

### List

```
iex(44)> i 'abc'
Term
  'abc'
Data type
  List
Description
  This is a list of integers that is printed as a sequence of characters
  delimited by single quotes because all the integers in it represent valid
  ASCII characters. Conventionally, such lists of integers are referred to as
  "charlists" (more precisely, a charlist is a list of Unicode codepoints,
  and ASCII is a subset of Unicode).
Raw representation
  [97, 98, 99]
Reference modules
  List


iex(45)> i [1,2,3,3.14]
Term
  [1, 2, 3, 3.14]
Data type
  List
Reference modules
  List

iex(46)> i []
Term
  []
Data type
  List
Reference modules
  List
```

Má»™t list cÃ³ thá»ƒ chá»©a báº¥t ká»³ kiá»ƒu dá»¯ liá»‡u nÃ o:

```
iex(6)> i ["abc", 1]
Term
  ["abc", 1]
Data type
  List
Reference modules
  List
```

Vá»›i list chá»©a cÃ¡c pháº§n tá»­ tuple-2 {atom: value}, Elixir há»— trá»£ thÃªm cÃº phÃ¡p ngáº¯n gá»n Ä‘á»ƒ táº¡o ra list nÃ y vÃ  gá»i lÃ  "keyword list" (báº£n cháº¥t váº«n lÃ  1 list bÃ¬nh thÆ°á»ng):

```
iex(38)> [{:name, "PyMi"}, {:est, 2015}]
[name: "PyMi", est: 2015]
iex(39)> [name: "PyMi", est: 2015]
[name: "PyMi", est: 2015]

iex(38)> [{:name, "PyMi"}, {:est, 2015}]
[name: "PyMi", est: 2015]
iex(39)> [name: "PyMi", est: 2015]
[name: "PyMi", est: 2015]

```

CÃ³ thá»ƒ truy cáº­p pháº§n tá»­ cá»§a keyword list báº±ng key, khi nhiá»u key trÃ¹ng nhau,
truy cáº­p sáº½ tráº£ vá» giÃ¡ trá»‹ Ä‘áº§u tiÃªn á»©ng vá»›i key.
```
iex(16)> [foo: "pika", foo: "pikachu"]
[foo: "pika", foo: "pikachu"]
iex(17)> [foo: "pika", foo: "pikachu"][:foo]
"pika"
```

### Tuple

```
iex(48)> i {100, 'abc'}
Term
  {100, 'abc'}
Data type
  Tuple
Reference modules
  Tuple
iex(49)> i {}
Term
  {}
Data type
  Tuple
Reference modules
  Tuple

```

KhÃ´ng giá»‘ng Python, trong Elixir, Táº¤T Cáº¢ cÃ¡c kiá»ƒu dá»¯ liá»‡u Ä‘á»u lÃ  immutable, tá»©c má»™t khi Ä‘Ã£ táº¡o ra, khÃ´ng thá»ƒ thay Ä‘á»•i. Muá»‘n "thay Ä‘á»•i", ta pháº£i táº¡o má»›i.

TrÃªn Python, nhá»¯ng Ä‘iá»u sau Ä‘á»u cÃ³ thá»ƒ lÃ m trÃªn list hay tuple:
- duyá»‡t qua tá»«ng pháº§n tá»­ (loop)
- truy cáº­p index
- slice Ä‘á»ƒ thu Ä‘Æ°á»£c má»™t táº­p con

Sá»± giá»‘ng nhau vá» tÃ­nh nÄƒng khiáº¿n ngÆ°á»i dÃ¹ng thÆ°á»ng há»i khi nÃ o dÃ¹ng list, khi nÃ o dÃ¹ng tuple.
Vá»›i Python, ta cÃ³ thá»ƒ thay Ä‘á»•i 1 list, nhÆ°ng khÃ´ng thá»ƒ thay Ä‘á»•i má»™t tuple sau khi Ä‘Ã£ táº¡o ra nÃ³.
Vá»›i Elixir, cáº£ list vÃ  tuple Ä‘á»u khÃ´ng thá»ƒ thay Ä‘á»•i Ä‘Æ°á»£c (immutable).
Äáº·c Ä‘iá»ƒm nÃ y sáº½ giÃºp tháº¥y rÃµ hÆ¡n khi nÃ o dÃ¹ng tuple vÃ  khi nÃ o nÃªn dÃ¹ng list:
- list THÆ¯á»œNG dÃ¹ng Ä‘á»ƒ chá»©a cÃ¡c dá»¯ liá»‡u tÆ°Æ¡ng tá»± nhau (heterogenious)
- tuple thÆ°á»ng Ä‘á»ƒ chá»©a cÃ¡c thÃ´ng tin liÃªn quan Ä‘áº¿n nhau, nhÆ° cÃ¡c cá»™t trong 1 dÃ²ng cá»§a database, cÃ¡c toáº¡ Ä‘á»™ cá»§a má»™t Ä‘iá»ƒm, cÃ¡c Ä‘áº·c tÃ­nh cá»§a má»™t con mÃ¨o...

Khi Ä‘Ã³, ta sáº½ thÆ°á»ng loop qua 1 list, vÃ  thÆ°á»ng truy cáº­p Ä‘áº¿n cÃ¡c pháº§n tá»­ cá»§a tuple thÃ´ng qua indexing/unpacking.

```
iex(52)> person = {"HVN", 27, "Python"}
{"HVN", 27, "Python"}
iex(53)> {name, age, language} = person
{"HVN", 27, "Python"}
iex(54)> name
"HVN"
```

http://elixir-lang.org/getting-started/basic-types.html#lists-or-tuples
http://stackoverflow.com/questions/31192923/lists-vs-tuples-what-to-use-and-when

### Map (dictionary)

```
iex(51)> i %{"name": "FAMILUG"}
Term
  %{name: "FAMILUG"}
Data type
  Map
Reference modules
  Map
```

### MapSet - kiá»ƒu dá»¯ liá»‡u táº­p há»£p
Chá»©a má»—i pháº§n tá»­ 1 láº§n, khÃ´ng cÃ³ thá»© tá»± [trá»« 32 pháº§n tá»­ Ä‘áº§u](http://stackoverflow.com/a/40408469) (tá»©c khÃ´ng thá»ƒ sáº¯p xáº¿p, pháº£i Ä‘á»•i thÃ nh kiá»ƒu list má»›i sáº¯p xáº¿p Ä‘Æ°á»£c.)

```
iex(2)> i MapSet.new([1,2,2,3,2,1])
Term
  #MapSet<[1, 2, 3]>
Data type
  MapSet
Description
  This is a struct. Structs are maps with a __struct__ key.
Reference modules
  MapSet, Map
Implemented protocols
  IEx.Info, Enumerable, Inspect, Collectable
```

### Struct

Struct lÃ  dáº¡ng Ä‘áº·c biá»‡t cá»§a Map, dÃ¹ng Ä‘á»ƒ biá»ƒu diá»…n cÃ¡c kiá»ƒu dá»¯ liá»‡u
do ngÆ°á»i dÃ¹ng tá»± Ä‘á»‹nh nghÄ©a.

```
iex(1)> defmodule Person do
...(1)>   defstruct [:name, :age]
...(1)> end
{:module, Person,
 <<70, 79, 82, 49, 0, 0, 8, 20, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0,
   234, 0, 0, 0, 22, 13, 69, 108, 105, 120, 105, 114, 46, 80, 101, 114,
   115, 111, 110, 8, 95, 95, 105, 110, 102, 111, 95, 95, ...>>,
 %Person{age: nil, name: nil}}
iex(2)> i %Person{name: "HVN", age: 27}
Term
  %Person{age: 27, name: "HVN"}
Data type
  Person
Description
  This is a struct. Structs are maps with a __struct__ key.
Reference modules
  Person, Map
Implemented protocols
  IEx.Info, Inspect
```

## CÃ¡c thao tÃ¡c cÆ¡ báº£n vá»›i cÃ¡c kiá»ƒu dá»¯ liá»‡u

### Thao tÃ¡c vá»›i sá»‘

- TÃ­nh bÃ¬nh phÆ°Æ¡ng, cÄƒn, sin, cos... sá»­ dá»¥ng module `:math` cá»§a Erlang
```
iex(11)> :math.pow(2,4)
16.0
iex(12)> :math.sin(2 * :math.pi)
-2.4492935982947064e-16
iex(17)> :math.sqrt(4)
2.0
```

- Convert float thÃ nh integer (bá» pháº§n tháº­p phÃ¢n)
```
iex(24)> trunc 5.7
5
iex(25)> trunc 5.1
5
```

- Convert string thÃ nh integer:
```
iex(26)> "5" |> String.to_integer
5
```

- LÃ m trÃ²n float thÃ nh integer gáº§n nháº¥t
```
iex(28)> round 6.5
7
iex(29)> round 7.5
8
iex(30)> round 7.1
7
```

### Thao tÃ¡c vá»›i String

ChÃº Ã½: Äá»ƒ tÆ°Æ¡ng thÃ­ch vá»›i Unicode, cÃ¡c function trong String háº§u háº¿t cÃ³ Ä‘á»™ phá»©c táº¡p
lÃ  O(n), khÃ¡ cháº­m. Tháº­m chÃ­ náº¿u báº¡n cáº§n láº¥y kÃ½ tá»± á»Ÿ vá»‹ trÃ­ thá»© N, Elixir cÅ©ng pháº£i
Ä‘i láº§n lÆ°á»£t tá»«ng kÃ½ tá»± cho Ä‘áº¿n kÃ½ tá»± thá»© N.
Náº¿u khÃ´ng cáº§n xá»­ lÃ½ string Unicode, cÃ³ thá»ƒ dÃ¹ng cÃ¡c binary function Ä‘á»ƒ cÃ³ tá»‘c Ä‘á»™ O(1).
(Xem chi tiáº¿t trong tÃ i liá»‡u cá»§a String module).

```
iex(30)> String.length("abcdef")
6
iex(31)> byte_size("abcdef")
6
iex(32)> String.at("abcdef", 5)
"f"
iex(33)> :binary.at("abcdef", 5)
102
iex(34)> binary_part("abcdef", 5, 1)
"f"
```

- Táº¡o string tá»« kiá»ƒu dá»¯ liá»‡u khÃ¡c:
```
iex(2)> Integer.to_string(42) <> List.to_string(["a", "b"])
"42ab"
```

- Kiá»ƒm tra string con:

```
iex(9)> String.contains?("Python", "on")
true
iex(10)> String.contains?("Python", "ON")
false
```

ChÃº Ã½ tÃªn function cÃ³ dáº¥u ?

- Kiá»ƒm tra báº¯t Ä‘áº§u vÃ  káº¿t thÃºc:

```
iex(11)> String.starts_with?("Python", "Py")
true
iex(12)> String
String      StringIO
iex(12)> String.ends_with?("Python.mp3", ".mp3")
true
```

Dá»… tháº¥y, nhá»¯ng function tráº£ vá» true/false Ä‘á»u Ä‘Æ°á»£c Ä‘áº·t tÃªn káº¿t thÃºc báº±ng dáº¥u ?

- Láº¥y index #TODO


- Ná»‘i cÃ¡c pháº§n tá»­ cá»§a list (KHÃ”NG THá»‚ Ná»I TUPLE):

```
iex(55)> Enum.join(["Python", "PyMi.vn"], " ")
"Python PyMi.vn"
iex(57)> ["Elixir", "PyMi.vn"] |> Enum.join("+")
"Elixir+PyMi.vn"
iex(61)> "Há»c Python" <> " " <> "táº¡i PyMi.vn"
"Há»c Python táº¡i PyMi.vn"

iex(7)> Enum.join {1, 2}
** (Protocol.UndefinedError) protocol Enumerable not implemented for {1, 2}
    (elixir) lib/enum.ex:1: Enumerable.impl_for!/1
    (elixir) lib/enum.ex:116: Enumerable.reduce/3
    (elixir) lib/enum.ex:1636: Enum.reduce/3
    (elixir) lib/enum.ex:1154: Enum.join/2
iex(7)> Enum.join [1, 2]
"12"
```

- Cáº¯t string, biáº¿n thÃ nh list:

```
iex(63)> String.split("MÃ¬nh thÃ­ch thÃ¬ mÃ¬nh há»c \tthÃ´i", " ")
["MÃ¬nh", "thÃ­ch", "thÃ¬", "mÃ¬nh", "há»c", "\tthÃ´i"]
iex(64)> String.split("MÃ¬nh thÃ­ch thÃ¬ mÃ¬nh     há»c \tthÃ´i")
["MÃ¬nh", "thÃ­ch", "thÃ¬", "mÃ¬nh", "há»c", "thÃ´i"]
```

Giá»‘ng nhÆ° Python.

NhÆ°ng Elixir cÃ²n cÃ³ thá»ƒ Split táº¡i nhiá»u "separator":

```
iex(7)> String.split("a-b+c", ["-", "+"])
["a", "b", "c"]
```

- trim/trim_leading/trim_trailing

```
iex(14)> String.trim("   a\t abc\n")
"a\t abc"
iex(15)> String.trim_leading("   a\t abc\n")
"a\t abc\n"
iex(16)> String.trim_trailing("   a\t abc\n")
"   a\t abc"
```

- replace

```
iex(17)> String.replace("Python", "Py", "Jy")
"Jython"
```

- Chá»¯ hoa, chá»¯ thÆ°á»ng:

```
iex(18)> String.upcase("Python")
"PYTHON"
iex(19)> String.downcase("PYThon")
"python"
iex(20)> String.capitalize("python is an animal")
"Python is an animal"
```

- Biáº¿n thÃ nh kiá»ƒu integer

```
iex(22)> String.to_integer("   42  ")
** (ArgumentError) argument error
    :erlang.binary_to_integer("   42  ")
iex(22)> String.to_integer("42")
42

```
Function nÃ y trong Elixir khÃ´ng cÃ³ kháº£ nÄƒng bá» Ä‘i whitespace nhÆ° Python:

```
In [1]: int("   42 \n\t   ")
Out[1]: 42
```

- Láº¥y Ä‘á»™ dÃ i

```
iex(59)>  String.length("Láº¡c trÃ´i")
8
iex(60)>  String.length("Láº¡c trÃ´iğŸ˜")
9
```

- Slice: slice(string, start, len)

```
iex(1)> String.slice("Python", 0, 2)
"Py"
iex(2)> String.slice("Python", 2, 10)
"thon"
```

- Äáº£o ngÆ°á»£c:

```
iex(4)> String.reverse("DOICAN")
"NACIOD"
```

https://hexdocs.pm/elixir/1.4.2/String.html#content

### List

Sá»­ dá»¥ng module `List`. CÃ¡c function cÃ³ sáºµn cá»§a module List khÃ´ng giá»‘ng nhÆ° trong Python, bá»Ÿi List trong Python cÃ³ thá»ƒ thay Ä‘á»•i Ä‘Æ°á»£c (thÃªm bá»›t, sá»­a pháº§n tá»­) cÃ²n List trong Elixir thÃ¬ khÃ´ng.

- Táº¡o list

```
iex(8)> li = [1, "PyMi", "Python", "Elixir"]
[1, "PyMi", "Python", "Elixir"]
iex(10)> i li
Term
  [1, "PyMi", "Python", "Elixir"]
Data type
  List
Reference modules
  List
```

Tá»« cÃ¡c kiá»ƒu dá»¯ liá»‡u khÃ¡c:

String thÃ nh charlist:

```
iex(5)> String.to_charlist "Elixir"
'Elixir'

```

String thÃ nh list
```
iex(7)> String.graphemes("Viá»‡t Nam")
["V", "i", "á»‡", "t", " ", "N", "a", "m"]
```

- Láº¥y Ä‘áº§u (head)

```
iex(11)> hd li
1
```

- Láº¥y Ä‘uÃ´i (tail)

```
iex(12)> tl li
["PyMi", "Python", "Elixir"]
```

- Láº¥y Ä‘áº§u vÃ  Ä‘uÃ´i:

```
iex(24)> [head | tail] = ["Python", "PyMi", "Golang", "FAMILUG.org"]
["Python", "PyMi", "Golang", "FAMILUG.org"]
iex(25)> head
"Python"
iex(26)> tail
["PyMi", "Golang", "FAMILUG.org"]
```
- Láº¥y pháº§n tá»­ Ä‘áº§u tiÃªn, cuá»‘i cÃ¹ng
```
iex(9)> List.first ["Python", "Golang", "Elixir"]
"Python"
iex(10)> List.last ["Python", "Golang", "Elixir"]
"Elixir"
```
- GÃ³i dá»¯ liá»‡u vÃ o má»™t list (náº¿u nÃ³ chÆ°a pháº£i 1 list)
```
iex(13)> List.wrap("Lac troi")
["Lac troi"]
iex(14)> List.wrap(0)
[0]
iex(15)> List.wrap(nil)
[]
```

- Kiá»ƒm tra sá»‘ pháº§n tá»­
```
iex(14)> length li
4
```

- Kiá»ƒm tra má»™t pháº§n tá»­ cÃ³ trong list khÃ´ng

```
iex(5)> Enum.member?([1,2,4], 3)
false
```

Hay dÃ¹ng cÃº phÃ¡p `left in right`:

```
iex(21)> 1 in [1, 2, 3]
true
```

ChÃº Ã½ cÃº phÃ¡p `in` nÃ y khÃ´ng hoáº¡t Ä‘á»™ng vá»›i tuple, map (nhÆ° trong Python).

```
iex(21)> 1 in {1, 2, 3}
** (Protocol.UndefinedError) protocol Enumerable not implemented for {1, 2, 3}
    (elixir) lib/enum.ex:1: Enumerable.impl_for!/1
    (elixir) lib/enum.ex:131: Enumerable.member?/2
    (elixir) lib/enum.ex:1352: Enum.member?/2
iex(22)> :a in %{:a => value}
** (CompileError) iex:22: undefined function value/0
    (elixir) expanding macro: Kernel.in/2
             iex:22: (file)
```


- Ná»‘i 2 list *concatenate*

```
iex(18)> li ++ [2, "Erlang"]
[1, "PyMi", "Python", "Elixir", 2, "Erlang"]
```

- Trá»« 2 list *subtract*

```
iex(22)> [1, 2, 3, 2, 1] -- [2]
[1, 3, 2, 1]
iex(23)> [1, 2, 3, 2, 1] -- [2, 3]
[1, 2, 1]
```

- "ThÃªm" pháº§n tá»­ vÃ o list: thá»±c ra lÃ  táº¡o má»™t list má»›i
ThÃªm "Zero" vÃ o index 0

```
iex(21)> List.insert_at(li, 0, "Zero")
["Zero", 1, "PyMi", "Python", "Elixir"]
```

- "ThÃªm" má»™t pháº§n tá»­ vÃ o Ä‘áº§u list (siÃªu tá»‘c - constant time O(1)):

```
iex(27)> l3 = ["Python", "PyMi", "Golang", "FAMILUG.org"]
["Python", "PyMi", "Golang", "FAMILUG.org"]
iex(28)> ["h" | l3]
["h", "Python", "PyMi", "Golang", "FAMILUG.org"]
```

- "ThÃªm" má»™t pháº§n tá»­ xuá»‘ng cuá»‘i list (cháº­m, linear time O(n))

```
iex(30)> l3 ++ ["t"]
["Python", "PyMi", "Golang", "FAMILUG.org", "t"]
```

- Thay má»™t pháº§n tá»­ cá»§a list táº¡i 1 index:
```
iex(33)> List.replace_at(["Python", "PyMi", "Golang", "FAMILUG.org", "t"], 2, "Elixir")
["Python", "PyMi", "Elixir", "FAMILUG.org", "t"]
```

- "XoÃ¡" pháº§n tá»­ khá»i list (dÃ¹ng value cá»§a pháº§n tá»­ vÃ  dÃ¹ng index):

```
iex(31)> List.delete(["Python", "PyMi", "Golang", "FAMILUG.org", "t"], "Golang")
["Python", "PyMi", "FAMILUG.org", "t"]
iex(32)> List.delete_at(["Python", "PyMi", "Golang", "FAMILUG.org", "t"], 2)
["Python", "PyMi", "FAMILUG.org", "t"]
```
- LÃ m pháº³ng 1 list (chá»©a cÃ¡c list khÃ¡c)
```
iex(11)> List.flatten ["Python", ["Erlang", "Elixir"]]
["Python", "Erlang", "Elixir"]
```

- Láº¥y má»™t list con tá»« list (slice):
slice(enumerable, start, amount)

```
iex(36)>  Enum.slice(["Python", "PyMi", "Elixir", "FAMILUG.org"], 1, 10)
["PyMi", "Elixir", "FAMILUG.org"]
```

**ChÃº Ã½** argument thá»© 3 lÃ  sÃ³ pháº§n tá»­ sáº½ slice,
khÃ´ng pháº£i index káº¿t thÃºc nhÆ° trong Python.

- Sáº¯p xáº¿p 1 list

Theo báº£ng chá»¯ cÃ¡i
```
iex(37)> Enum.sort(["Python", "PyMi", "Elixir", "FAMILUG.org", "t"])
["Elixir", "FAMILUG.org", "PyMi", "Python", "t"]
```

Theo tiÃªu chÃ­ nháº¥t Ä‘á»‹nh (function)
```
iex(35)> Enum.sort_by(["Python", "PyMi", "Elixir", "FAMILUG.org", "t"], &String.length/1)
["t", "PyMi", "Python", "Elixir", "FAMILUG.org"]
```

https://hexdocs.pm/elixir/Enum.html#content

### Tuple
LuÃ´n chÃº Ã½ ráº±ng trong Elixir, má»i kiá»ƒu dá»¯ liá»‡u Ä‘á»u lÃ  immutable, nÃªn má»i
function thay Ä‘á»•i dá»¯ liá»‡u Ä‘á»u tráº£ vá» má»™t giÃ¡ trá»‹ má»›i, khÃ´ng thay Ä‘á»•i Ä‘áº§u vÃ o Ä‘Ã£
gá»i vá»›i function.

Thay má»™t pháº§n tá»­ táº¡i index
```
iex(2)> put_elem {:foo, "bar"}, 1, "bye"
{:foo, "bye"}
```

ThÃªm má»™t giÃ¡ trá»‹ vÃ o index
```
iex(4)> Tuple.insert_at {"toi", "em"}, 1, "thang ay"
{"toi", "thang ay", "em"}

```

ThÃªm vÃ o cuá»‘i tuple:

```
iex(5)> Tuple.append {6, 9}, "Tail"
{6, 9, "Tail"}
```

XÃ³a táº¡i index

```
iex(6)> Tuple.delete_at {"Elixir", "is", :not, "great"}, 2
{"Elixir", "is", "great"}
```

Biáº¿n thÃ nh list
```
iex(7)> Tuple.to_list {:x, :y, :z}
[:x, :y, :z]
```

### Map

lÃ  má»™t cáº¥u trÃºc dá»¯ liá»‡u cÃ³ thá»ƒ gá»i lÃ  "key-value" store.
TÃªn khÃ¡c (trong ngÃ´n ngá»¯ khÃ¡c): dictionary, associative array

```
map = %{:a => 1, :b => 2}
```

- Táº¡o map:
%{key => value1, key => value2}

```
iex(47)>  %{:a => 1, :b =>2}
%{a: 1, b: 2}
iex(48)> %{"name" => "PYMI", "country" => "VN"}
%{"country" => "VN", "name" => "PYMI"}
```

- Táº¡o map tá»« list cá»§a cÃ¡c tuple-2:

```
iex(59)> [{1, 7}, {2, 3}] |> Map.new
%{1 => 7, 2 => 3}
```

- Táº¡o list tá»« map:

```
iex(60)> [{1, 7}, {2, 3}] |> Map.new |> Map.to_list
[{1, 7}, {2, 3}]
```

- Äáº¿m sá»‘ pháº§n tá»­
- Truy cáº­p value:

```
iex(68)> %{:name => who} = %{:name => "HVN"}
%{name: "HVN"}
iex(69)> who
"HVN"

iex(44)> map = %{:a => 1, :b =>2}
%{a: 1, b: 2}
iex(46)> map[:b]
2
iex(47)> map[:c]
nil
```

Hay

```
iex(60)> Map.get(map, :b)
2
iex(64)> Map.get(%{first_name: "Jon", last_name: "Snow"}, :age)
nil
```

Hoáº·c
```
iex(2)> Map.fetch(%{first_name: "Jon", last_name: "Snow"}, :last_name)
{:ok, "Snow"}
iex(3)> Map.fetch(%{first_name: "Jon", last_name: "Snow"}, :age)
:error
```

- Kiá»ƒm tra key cÃ³ trong map khÃ´ng

```
iex(3)> Map.has_key?(%{:name => "HVN"}, :age)
false
```

- "ThÃªm" key-value má»›i:

```
iex(62)> Map.put(%{:a => 1}, :h, 4)
%{a: 1, h: 4}
```

- XoÃ¡ key-value:

```
iex(1)> Map.delete(%{:name => "HVN", :age => 27}, :age)
%{name: "HVN"}
```

XoÃ¡ key khÃ´ng tá»“n táº¡i khÃ´ng áº£nh hÆ°á»Ÿng gÃ¬:
```
iex(2)> Map.delete(%{:name => "HVN", :age => 27}, :language)
%{age: 27, name: "HVN"}
```

- Duyá»‡t qua tá»«ng key # TODO

- Gá»™p (merge) 2 map
```
iex(6)> Map.merge(%{first_name: "Jon", last_name: "Snow"}, %{last_name: "Water", age: 27})
%{age: 27, first_name: "Jon", last_name: "Water"}
```
- Biáº¿n thÃ nh list cÃ¡c tuple key-value:

```
iex(63)> Map.to_list(%{:name => "HVN", :age => 27})
[age: 27, name: "HVN"]
```

- Update value cá»§a 1 key Ä‘Ã£ trong map (khÃ´ng thÃªm):
```
iex(65)> %{ map | :b => 5}
%{a: 1, b: 5}
iex(66)> %{ map | :c => 5}
** (KeyError) key :c not found in: %{a: 1, b: 2}
```

- Truy cáº­p cÃ¡c atom key báº±ng `.`:

```
iex(66)> student = %{:name => "HVN"}
%{name: "HVN"}
iex(67)> student.name
"HVN"
```

- Update value nested dict vá»›i `put_in/2`:

```
iex(70)> users = [hvn: %{name: "HVN", age: 27, language: ["Erlang", "Elixir", "Python"]},
hails: %{name: "HaiLS", age: 26, language: ["Golang", "JS"]}]
[hvn: %{age: 27, language: ["Erlang", "Elixir", "Python"], name: "HVN"},
 hails: %{age: 26, language: ["Golang", "JS"], name: "HaiLS"}]

iex(72)> put_in users[:hvn].age, 29
[hvn: %{age: 29, language: ["Erlang", "Elixir", "Python"], name: "HVN"},
 hails: %{age: 26, language: ["Golang", "JS"], name: "HaiLS"}]
```

- Biáº¿n map nÃ y thÃ nh map khÃ¡c, sá»­ dá»¥ng `Enum.into/3`:

```
iex(2)>  %{a: [1, 2, 3], b: ["meo", "ga"]} |> Enum.into(%{}, fn {k, v} -> {k, length(v)} end)
%{a: 3, b: 2}
```

Má»—i kiá»ƒu dá»¯ liá»‡u Ä‘á»u cÃ³ má»™t module tÆ°Æ¡ng á»©ng cung cáº¥p cÃ¡c function cáº§n thiáº¿t: List, Map, String. Module `Enum` dÃ¹ng chung cho cÃ¡c kiá»ƒu dá»¯ liá»‡u cho phÃ©p duyá»‡t qua tá»«ng pháº§n tá»­: nhÆ° `List`

### MapSet
- Kiá»ƒm tra pháº§n tá»­
```
iex(12)> MapSet.member?(MapSet.new([1, 3, 43, 98]) , 9)
false
```

- CÃ¡c phÃ©p toÃ¡n táº­p há»£p (giao - intersection, há»£p - union,...)
```
iex(16)> MapSet.intersection(MapSet.new([1,3,5]), MapSet.new([1,5,2]))
#MapSet<[1, 5]>
#MapSet<[1, 2, 3, 5]>
```

### Struct
Láº¥y giÃ¡ trá»‹ cá»§a field
```
iex(1)> defmodule Person do
...(1)>   defstruct [:name, :age]
...(1)> end
...
iex(3)> Map.fetch %Person{name: "HVN", age: 27}, :name
{:ok, "HVN"}
```

Thay Ä‘á»•i giÃ¡ trá»‹ cá»§a cÃ¡c field trong struct
```
iex(4)> hvn = %Person{name: "HVN", age: 27}
%Person{age: 27, name: "HVN"}
iex(5)> %{hvn | age: hvn.age + 1}
%Person{age: 28, name: "HVN"}
```

Thay Ä‘á»•i giÃ¡ trá»‹ cá»§a nested value (value cá»§a field trong struct trong struct khÃ¡c ...)
```
iex(2)> defmodule Class do
...(2)>   defstruct person: %Person{}, name: "PyMI"
...(2)> end
...
iex(4)> pymi = %Class{person: %Person{name: "HVN", age: 27}}
%Class{name: "PyMI", person: %Person{age: 27, name: "HVN"}}
iex(5)> put_in pymi.person.age, 28
%Class{name: "PyMI", person: %Person{age: 28, name: "HVN"}}
```

## Pattern matching

`=` : the match operator
- Khi gÃ¡n biáº¿n, biáº¿n pháº£i náº±m bÃªn trÃ¡i dáº¥u `=`

```
iex(7)> x = 5
5
iex(8)> 6 = y
** (CompileError) iex:8: undefined function y/0
```

- Váº¿ trÃ¡i cÃ³ thá»ƒ lÃ  kiá»ƒu dá»¯ liá»‡u phá»©c táº¡p hÆ¡n, dÃ¹ng Ä‘á»ƒ "destructuring" hay "unpacking" dá»¯ liá»‡u phÃ­a tay pháº£i.
Sá»‘ pháº§n tá»­ 2 bÃªn pháº£i báº±ng nhau, cÃ¹ng kiá»ƒu:

```
iex(18)> {name, age} = {"PyMI.vn", 2}
{"PyMI.vn", 2}
iex(19)> name
"PyMI.vn"
iex(20)> age
2

iex(1)> [x, y, z] = [1, 2, 4]  # list
[1, 2, 4]
iex(2)> x
1
iex(3)> z
4
```

Khi bÃªn pháº£i chá»©a giÃ¡ trá»‹ thay vÃ¬ biáº¿n, 2 bÃªn chá»‰ match nhau náº¿u giÃ¡ trá»‹ bÃªn tay trÃ¡i match giÃ¡ trá»‹ bÃªn tay pháº£i:

```
iex(4)> {:ok, 1, salary} = {:ok, 1, 15}
{:ok, 1, 15}
iex(5)> {:ok, 1, income} = {:ok, 3, 20}
** (MatchError) no match of right hand side value: {:ok, 3, 20}

iex(10)> {x, x} = {1, 1}
{1, 1}
iex(11)> {x, x} = {1, 2}
** (MatchError) no match of right hand side value: {1, 2}


```
Khi 2 bÃªn khÃ´ng "match", MatchError sáº½ xáº£y ra.

- Matching vá»›i cÃº phÃ¡p [head | tail]:

```
iex(5)> [h | t] = [1, 2, 3, 4]
[1, 2, 3, 4]
iex(6)> h
1
iex(7)> t
[2, 3, 4]
```

Giá»‘ng nhÆ° gá»i function `hd` vÃ  `tl`:

```
iex(8)> hd [1, 2, 3, 4]
1
iex(9)> tl [1, 2, 3, 4]
[2, 3, 4]
```

CÃº phÃ¡p nÃ y rÃµ rÃ ng khÃ´ng match list rá»—ng:

```
iex(10)> [h | t] = []
** (MatchError) no match of right hand side value: []

```

- Truy cáº­p giÃ¡ trá»‹ cá»§a má»™t biáº¿n thay vÃ¬ gÃ¡n láº¡i nÃ³ báº±ng `^` - pin operator:
```
iex(11)> x = 5
5
iex(12)> x = 7
7
iex(13)> x
7
iex(14)> ^x = 8
** (MatchError) no match of right hand side value: 8
VÃ¬ giá»‘ng nhÆ° viáº¿t: 7 = 8
iex(14)> 7 = 8
** (MatchError) no match of right hand side value: 8
```


## Control flow: case, cond, if, unless, do/end

### if

if/2 lÃ  má»™t function, tá»©c nÃ³ sáº½ tráº£ vá» má»™t giÃ¡ trá»‹ sau khi cháº¡y. KhÃ¡c vá»›i Python hay nhiá»u ngÃ´n ngá»¯ khÃ¡c, if trong Python lÃ  má»™t "statement" (cÃ¢u lá»‡nh), vÃ  nÃ³ chá»‰ thá»±c hiá»‡n Ä‘iá»u khiá»ƒn luá»“ng chá»© khÃ´ng tráº£ vá» giÃ¡ trá»‹ nÃ o.
(PS: thá»±c sá»± if/2 mÃ  1 macro - khÃ¡i niá»‡m macro sáº½ Ä‘Æ°á»£c nÃ³i sau)

```
iex(15)> k = if 5 > 4 do
...(15)> "yeah"
...(15)> end
"yeah"
iex(16)> k
"yeah"
```

if/2 tráº£ vá» nil náº¿u Ä‘iá»u kiá»‡n nÃ³ nháº­n Ä‘Æ°á»£c tráº£ vá» false hay nil.

```
iex(17)> h = if 5 < 4 do
...(17)> "hey"
...(17)> end
nil
iex(18)> h
nil
```

Máº«u cÃº phÃ¡p:

```
if condition do
SOMETHING
end
```

`if` cÃ³ thá»ƒ Ä‘i kÃ¨m vá»›i `else`:
```
iex(19)> m = if 5 < 4 do
...(19)> "smaller"
...(19)> else
...(19)> "bigger"
...(19)> end
"bigger"
iex(20)> m
"bigger"
```

Trong Elixir chá»‰ cÃ³ `if/else/end` khÃ´ng cÃ³ elif nhÆ° trong Python, khi cáº§n xá»­ lÃ½ nhiá»u trÆ°á»ng há»£p, ta cÃ³ thá»ƒ dÃ¹ng cond.

Äá»c thÃªm: https://hexdocs.pm/elixir/Kernel.html#if/2

### cond
`cond do ... end` cho phÃ©p xá»­ lÃ½ nhiá»u Ä‘iá»u kiá»‡n, giá»‘ng nhÆ° elif hay else if trong cÃ¡c ngÃ´n ngá»¯ khÃ¡c:

```
iex(24)> x = 18
18
iex(25)> cond do
...(25)>   x < 18 ->
...(25)>     "Not permitted"
...(25)>   x == 18 ->
...(25)>     "Okay"
...(25)>   x > 18 ->
...(25)>     "Too old"
...(25)> end
"Okay"
```

### unless
NhÆ° if, nhÆ°ng ngÆ°á»£c láº¡i.

```
iex(26)> x = 18
18
iex(27)> unless x < 18 do
...(27)>   "got this"
...(27)> end
"got this"
iex(28)> if x < 18 do
...(28)>   "no"
...(28)> end
nil
```

### case
`case` sá»­ dá»¥ng pattern matching, vÃ  chá»‰ dá»«ng láº¡i khi ta tÃ¬m tháº¥y giÃ¡ trá»‹ nÃ o match. Ta tháº¥y `case` chá»‰ dÃ¹ng Ä‘á»ƒ kiá»ƒm tra xem 1 giÃ¡ trá»‹ cÃ³ báº±ng má»™t giÃ¡ trá»‹ khÃ¡c, chá»© khÃ´ng dÃ¹ng so sÃ¡nh >, < ... nhÆ° `if`.

```
iex(22)> case 5 do
...(22)>   4 ->
...(22)>
...(22)> "Won't match"
...(22)> _ ->
...(22)> "will match"
...(22)> end
"will match"
```

```
iex(23)> case {1, 2, 3} do
...(23)>   {1, x, 3} when x > 0 ->
...(23)>     "will match"
...(23)>   _ ->
...(23)>     "Would match, if guard cond were not sastified"
...(23)> end
"will match"
```


`when x > 0` gá»i lÃ  guard condition. Ta tháº¥y `case` cÅ©ng lÃ  má»™t macro chá»© khÃ´ng pháº£i "statement" nhÆ° trong cÃ¡c ngÃ´n ngá»¯ khÃ¡c.


CÃº phÃ¡p:

```
case SOMETHING do
  CLAUSE1 [GUARD] ->
      "OTHERTHING"
  CLAUSE2 [GUARD] ->
     ...
  _ ->
     "LAST PATTERN MATCH REMAIN"
end
```

Náº¿u khÃ´ng clause nÃ o match, error sáº½ Ä‘Æ°á»£c raise:

```
iex(24)> case :ok do
...(24)>   :error ->
...(24)>     "Not match"
...(24)> end
** (CaseClauseError) no case clause matching: :ok

```


### Guard
Trong guard khÃ´ng Ä‘Æ°á»£c dÃ¹ng && || !
Error trong guard sáº½ khiáº¿n guard fail.


### do/end
Trong `if` `unless` `cond` `case` Ä‘á»u cÃ³ dÃ¹ng `do` vÃ 
káº¿t thÃºc báº±ng `end`.

```
if true do
...
end
```

TÆ°Æ¡ng Ä‘Æ°Æ¡ng vá»›i:

```
if true, do: (
...
)
```
`do/end` lÃ  syntactix sugar (cÃº phÃ¡p Ä‘á»ƒ viáº¿t cho dá»…).

## Function

### Gá»i function (calling):

CÃº phÃ¡p thÃ´ng thÆ°á»ng:

```
iex(1)> String.to_integer(String.trim("  42 \n "))
42
iex(7)> String.split("42-15\n17", ["-", "\n"])
["42", "15", "17"]
```

CÃº phÃ¡p bá» dáº¥u `()`:

```
iex(8)> String.split "42-15\n17", ["-", "\n"]
["42", "15", "17"]

iex(10)> Enum.map(String.split("42-15\n17", ["-", "\n"]), fn(x) -> String.to_integer(x) end)
[42, 15, 17]
```

#### ToÃ¡n tá»­ pipe (pipe operator)
CÃº phÃ¡p sá»­ dá»¥ng "pipe", dá»¯ liá»‡u sáº½ cháº¡y tá»« output cá»§a 1 function, qua pipe vÃ  trá»Ÿ thÃ nh argument Ä‘áº§u tiÃªn cá»§a function tiáº¿p theo (giá»‘ng Pipeline trÃªn UNIX shell).

```
iex(11)> String.split("42-15\n17", ["-", "\n"]) |> Enum.map(fn(x) -> String.to_integer(x) end)
[42, 15, 17]

iex(23)> 1..1000 |> Enum.filter(fn(x) -> (rem(x, 3) == 0 || rem(x, 5) == 0) end) |> Enum.sum
234168
```

### Äá»‹nh nghÄ©a function
Function cÃ³ tÃªn pháº£i Ä‘Æ°á»£c Ä‘á»‹nh nghÄ©a trong module.
Function sáº½ tráº£ vá» giÃ¡ trá»‹ cuá»‘i cÃ¹ng nÃ³ tÃ­nh Ä‘Æ°á»£c - khÃ´ng cÃ³ cÃ¢u lá»‡nh "return".
Äoáº¡n code sau Ä‘á»‹nh nghÄ©a module `Math` vÃ  function `sum` tráº£ vá» tá»•ng cá»§a 2 argument a, b:

```
defmodule Math do
  def sum(a, b) do
    a + b
  end
end
```

hoáº·c

```
defmodule Hacker, do: def hack(x), do: x*2
```
khi chá»‰ cÃ³ 1 function vÃ  function chá»‰ cÃ³ 1 dÃ²ng.

`defmodule` vÃ  `def` Ä‘á»u lÃ  cÃ¡c macro.

### Private function
Äá»‹nh nghÄ©a báº±ng macro `defp/2`, tá»« module khÃ¡c khÃ´ng thá»ƒ cháº¡y cÃ¡c function nÃ y.

### KÃ½ hiá»‡u (notation)
Khi nháº¯c tá»›i function, trong Elixir dÃ¹ng kÃ½ hiá»‡u:
`name/arity` vá»›i name lÃ  tÃªn , vÃ  arity lÃ  sá»‘ argument function Ä‘Ã³ nháº­n.

Math.sum á»Ÿ trÃªn kÃ½ hiá»‡u lÃ  `Math.sum/2`

### Multiple clause function
Má»™t function cÃ³ thá»ƒ cÃ³ nhiá»u `clause`:

Má»—i "clause" thÆ°á»ng Ä‘i kÃ¨m má»™t "guard", náº¿u argument pass vÃ o match vá»›i argument cá»§a clause vÃ  guard Ä‘i kÃ¨m tráº£ vá» `true`, clause Ä‘Ã³ sáº½ Ä‘Æ°á»£c gá»i.

```
defmodule Foo do
  def rprint(msg, n) when n <= 1 do
    IO.puts msg
  end

  def rprint(msg, n) do
    IO.puts msg
    rprint(msg, n - 1)
  end
end

Foo.rprint("Hello", 5)
```

### Function capturing

#### TODO

### Default argument

```
def join(a, b, sep \\ ",") do
  a <> sep <> b
end
```
"," lÃ  default argument, khi gá»i funtion mÃ  khÃ´ng pass giÃ¡ trá»‹ cho argument `sep`, `sep` sáº½ sá»­ dá»¥ng giÃ¡ trá»‹ máº·c Ä‘á»‹nh ",".

### CÃ¡c pháº§n cá»§a má»™t function

```
def sum(a, b) do
  a + b
end
```

- Function head: `def sum(a, b)`
- Function body: tá»« `do` Ä‘áº¿n `end`

Khi function vá»›i default value cÃ³ nhiá»u má»‡nh Ä‘á», pháº£i khai bÃ¡o má»™t function head Ä‘á»ƒ khai bÃ¡o giÃ¡ trá»‹ default.

#### TODO more detail

## Module

### Compile

CÃ³ thá»ƒ viáº¿t module vÃ o file `NAME.ex`: `math.ex`.

Compile module:

```
$ elixirc math.ex  # táº¡o ra file Elixir.Math.beam
```

Báº­t `iex` cÃ¹ng thÆ° má»¥c sáº½ tá»± Ä‘á»™ng load module, chá»‰ viá»‡c gá»i.

### Script
LÆ°u file vá»›i Ä‘uÃ´i .exs, Elixir sáº½ hiá»ƒu Ä‘Ã³ lÃ  1 "script" vÃ  sáº½ khÃ´ng táº¡o file cÃ³ Ä‘uÃ´i .beam ná»¯a, cháº¡y nÃ³ nhÆ° cháº¡y cÃ¡c script khÃ¡c (Python, bash...):

```
$ elixir math.exs
```

## Loop báº±ng recursion, reduce vÃ  map

Trong Elixir, má»i thá»© Ä‘á»u lÃ  "immutable" (khÃ´ng thay Ä‘á»•i Ä‘Æ°á»£c), vÃ¬ váº­y nhá»¯ng khÃ¡i niá»‡m Ä‘á»ƒ láº·p nhÆ° trong cÃ¡c ngÃ´n ngá»¯ C, Python, Java, PHP, Golang ... sáº½ khÃ´ng Ä‘Æ°á»£c á»©ng dá»¥ng:

```
for i in 'Elixir':
    print(i)
```

á» vÃ²ng láº·p for nÃ y, giÃ¡ trá»‹ cá»§a i láº§n lÆ°á»£t thay Ä‘á»•i thÃ nh cÃ¡c kÃ½ tá»± trong "Elixir" -> khÃ´ng Ä‘áº£m báº£o Ä‘Æ°á»£c tÃ­nh immutable cá»§a Elixir.

```
i = 0
while True:
    print(i)
    i = i + 1
```

TÆ°Æ¡ng tá»±, trong vÃ²ng láº·p while nÃ y i cÅ©ng thay Ä‘á»•i sau má»—i vÃ²ng láº·p, khÃ´ng Ä‘áº£m báº£o tÃ­nh immutable.

Elixir hay cÃ¡c ngÃ´n ngá»¯ láº­p trÃ¬nh hÃ m (functional programming language) khÃ¡c sá»­ dá»¥ng recursive function Ä‘á»ƒ táº¡o hiá»‡u á»©ng/ káº¿t quáº£ nhÆ° loop.

### Recursive function
LÃ  function mÃ  bÃªn trong pháº§n body, nÃ³ tá»± gá»i Ä‘áº¿n chÃ­nh nÃ³ cho Ä‘áº¿n khi gáº·p má»™t Ä‘iá»u kiá»‡n Ä‘á»ƒ dá»«ng láº¡i. Sáº½ khÃ´ng cÃ³ gÃ¬ bá»‹ thay Ä‘á»•i khi dÃ¹ng recursive function, bá»Ÿi ta sáº½ sinh ra giÃ¡ trá»‹ má»›i, chá»© khÃ´ng thay Ä‘á»•i giÃ¡ trá»‹ cÅ©. Má»i khÃ¡i niá»‡m sáº½ rÃµ rÃ ng khi thá»­ vá»›i function tÃ­nh giai thá»«a cá»§a 1 sá»‘:

Giai thá»«a cá»§a má»™t sá»‘ nguyÃªn khÃ´ng Ã¢m Ä‘Æ°á»£c tÃ­nh báº±ng tÃ­ch cá»§a sá»‘ Ä‘Ã³ nhÃ¢n vá»›i giai thá»­a cá»§a sá»‘ nhá» hÆ¡n nÃ³ 1 Ä‘Æ¡n vá»‹. Hay viáº¿t á»Ÿ dáº¡ng cÃ´ng thá»©c toÃ¡n:
factorial(n) = n * factorial(n - 1)
khi n = 0 thÃ¬ factorial(0) = 1. # Ä‘iá»u kiá»‡n dá»«ng

Thá»­ tÃ­nh factorial cá»§a 3:

factorial(3) = 3 * factorial(2)
factorial(2) = 2 * factorial(1)
factorial(1) = 1 * factorial(0)
factorial(0) = 1

Sau khi Ä‘Ã£ cháº¡m Ä‘áº¿n Ä‘iá»u kiá»‡n dá»±ng, ta láº¥y káº¿t quáº£ thu Ä‘Æ°á»£c thay ngÆ°á»£c lÃªn trÃªn.
factorial(1) = 1 * factorial(0) = 1 * 1 = 1
factorial(2) = 2 * factorial(1) = 2 * 1 = 2
factorial(3) = 3 * factorial(2) = 3 * 2 = 6

Káº¿t quáº£ lÃ  factorial(3) báº±ng 6.

```
defmodule Rescusion do
  def fact(n) when n <= 0 do
    1
  end

  def fact(n) do
    n * fact(n - 1)
  end
end
```

Trong bÃ i nÃ y, code cá»§a Elixir chá»‰ Ä‘Æ¡n giáº£n lÃ  chuyá»ƒn cÃ´ng thá»©c toÃ¡n há»c thÃ nh code.

### Map
Má»™t viá»‡c lÃ m thÆ°á»ng xuyÃªn khi sá»­ dá»¥ng loop lÃ  Ä‘á»ƒ biáº¿n 1 táº­p giÃ¡ trá»‹, thÃ nh 1 táº­p giÃ¡ trá»‹ khÃ¡c.

VÃ­ dá»¥, cho má»™t list `L = [1, 2, 3 ,4]`, cáº§n thu Ä‘Æ°á»£c káº¿t quáº£ lÃ  má»™t list mÃ  pháº§n tá»­ cá»§a nÃ³ lÃ  má»—i pháº§n tá»­ cá»§a `L` nhÃ¢n vá»›i 2.

Viá»‡c biáº¿n má»™t táº­p thÃ nh má»™t táº­p khÃ¡c báº±ng cÃ¡ch gá»i function vá»›i má»—i pháº§n tá»­ cá»§a táº­p gá»i lÃ  "mapping" (Ã¡nh xáº¡ trong toÃ¡n há»c).
Ta "map" má»™t pháº§n tá»­ tá»« táº­p ban Ä‘áº§u thÃ nh pháº§n tá»­ trong táº­p má»›i.

Viáº¿t function Ä‘á»ƒ map list nÃ³i trÃªn:

```
iex(41)> defmodule Double do
...(41)>   def double_each([head | tail]) do
...(41)>     [head * 2 | double_each(tail)]
...(41)>   end
...(41)>
...(41)>   def double_each([]) do
...(41)>     []
...(41)>   end
...(41)> end
{:module, Double,
...
iex(42)> Double.double_each([1,2,3,4])
[2, 4, 6, 8]
```

CÃ³ thá»ƒ dÃ¹ng function cÃ³ sáºµn `Enum.map/2` Ä‘á»ƒ thá»±c hiá»‡n mapping:

```
iex(45)> Enum.map([1,2,3,4], fn(x) -> x * 2 end)
[2, 4, 6, 8]
```

### Reduce
Má»™t á»©ng dá»¥ng khÃ¡c thÆ°á»ng dÃ¹ng khi láº·p lÃ  Ä‘á»ƒ tÃ­nh má»™t giÃ¡ trá»‹ nÃ o Ä‘Ã³ sáº½ thu Ä‘Æ°á»£c sau khi duyá»‡t qua táº¥t cáº£ giÃ¡ trá»‹ trong táº­p, nhÆ° tÃ­nh tá»•ng, tÃ­ch cá»§a táº­p.

á» Ä‘Ã¢y ta biáº¿n tá»« 1 táº­p nhiá»u pháº§n tá»­ thÃ nh 1 giÃ¡ trá»‹ cuá»‘i cÃ¹ng. Viá»‡c "thu gá»n" nÃ y cÃ³ tÃªn lÃ  "reducing".

Map vÃ  reduce lÃ  2 thuáº­t toÃ¡n cá»‘t lÃµi cá»§a "big data".

```
iex(46)> defmodule Reduce do
...(46)>   def sum_list([head | tail], accumulator) do
...(46)>     sum_list(tail, head + accumulator)
...(46)>   end
...(46)>
...(46)>   def sum_list([], accumulator) do
...(46)>     accumulator
...(46)>   end
...(46)> end

iex(47)> Reduce.sum_list([1,2,3], 0)
6
```

Hay dÃ¹ng module cÃ³ sáºµn `Enum.reduce/2`:

```
iex(48)> Enum.reduce([1,2,3], 0, fn(x, acc) -> x + acc end)
6
```

## IO - xá»­ lÃ½ dá»¯ liá»‡u vÃ o ra.
### In ra mÃ n hÃ¬nh

Máº·c dÃ¹ háº§u háº¿t cÃ¡c sÃ¡ch dáº¡y láº­p trÃ¬nh / trÆ°á»ng há»c sáº½ luÃ´n báº¯t Ä‘áº§u báº±ng viá»‡c dáº¡y "print" ra mÃ n hÃ¬nh (vÃ  Ä‘i kÃ¨m lÃ  Ä‘á»c nhá»¯ng gÃ¬ ngÆ°á»i dÃ¹ng nháº­p vÃ o), nhÆ°ng trÃªn thá»±c táº¿, cÃ³ khoáº£ng < 5% ngÆ°á»i thá»±c sá»± dÃ¹ng print trong chÆ°Æ¡ng trÃ¬nh cá»§a mÃ¬nh.

HÃ£y thá»­ nghÄ© vá»›i ngÆ°á»i dÃ¹ng Windows, cÃ³ bao giá» báº¡n báº­t `cmd` lÃªn vÃ  gÃµ lá»‡nh? CÃ¡c chÆ°Æ¡ng trÃ¬nh Ä‘á»u giao tiáº¿p vá»›i ngÆ°á»i dÃ¹ng qua giao diá»‡n Ä‘á»“ hoáº¡ / web, chá»© khÃ´ng pháº£i cÃ¡c dÃ²ng lá»‡nh. Nhá»¯ng ngÆ°á»i lÃ m viá»‡c vá»›i dÃ²ng lá»‡nh chá»§ yáº¿u lÃ  cÃ¡c Linux Sysadmin / láº­p trÃ¬nh viÃªn / hacker.
Náº¿u báº¡n lÃ  má»™t web developer, báº¡n Ä‘Æ°a ná»™i dung ra trang web chá»© khÃ´ng print nÃ³.

Elixir sá»­ dá»¥ng module `IO` cho cÃ¡c thao tÃ¡c nÃ y:

```
iex(49)> IO.puts "Hello"
Hello
:ok
iex(50)> IO.puts "Hello FAMILUG"
Hello FAMILUG
:ok
iex(51)> answer = IO.gets("yes or no? ")
yes or no? yes
"yes\n"
iex(52)> IO.puts(answer)
yes

:ok
```

CÃ³ thá»ƒ ghi ra stderr:

```
iex(53)> IO.puts(:stderr, "Hello standard error")
Hello standard error
:ok
```

Äá»ƒ khÃ´ng thÃªm kÃ½ tá»± newline (`\n`) sau má»—i dÃ²ng, sá»­ dá»¥ng `IO.write` thay
vÃ¬ `IO.puts`.

`puts` chá»‰ nháº­n argument lÃ  string, muá»‘n "in ra" má»™t list, tuple hay object báº¥t
ká»³, hÃ£y dÃ¹ng `IO.inspect`.

Khi dÃ¹ng `IO.inspect` in ra list cÃ³ nhiá»u pháº§n tá»­ (>50), Elixir sáº½ chá»‰ in ra 50
pháº§n tá»­ Ä‘áº§u vÃ  ghi ... Ä‘á»ƒ kÃ½ hiá»‡u cÃ²n tiáº¿p. Muá»‘n hiá»‡n Ä‘áº§y Ä‘á»§, cÃ³ thá»ƒ gá»i thÃªm
argument:

```
iex(9)> IO.inspect(1..100|>Enum.map(fn x -> x*2 end))

[2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, ...]

iex(10)> IO.inspect(1..100|>Enum.map(fn x -> x*2 end), limit: :infinity)
[2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82,
 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116,
 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148,
 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180,
 182, 184, 186, 188, 190, 192, 194, 196, 198, 200]

```

### Äá»c ghi file

Module `File` chá»©a cÃ¡c function Ä‘á»ƒ tÆ°Æ¡ng tÃ¡c vá»›i file, tá»« Ä‘á»c, ghi, xoÃ¡, copy...


```
iex(53)> IO.puts(:stderr, "Hello standard error")
Hello standard error
:ok
iex(54)> {:ok, file} = File.open("hellofile.txt", [:write])
{:ok, #PID<0.260.0>}
iex(55)> IO.binwrite(file, "Hello world!")
:ok
iex(56)> File.close(file)
:ok
iex(57)> File.read("hellofile.txt")
{:ok, "Hello world!"}
```

CÃ¡c function xá»­ lÃ½ file:

`File.rm/1`, `File.mkdir/1`, `File.cp_r/2`, ...

## Xá»­ lÃ½ lá»—i

### Errror (hay exception)

```
iex(58)> "abc" + 1
** (ArithmeticError) bad argument in arithmetic expression
    :erlang.+("abc", 1)
iex(58)> raise "oizoioi"
** (RuntimeError) oizoioi

iex(58)> raise ArgumentError, message: "invalid argument"
** (ArgumentError) invalid argument

```

### try/rescue/catch/after
TÆ°Æ¡ng tá»± nhÆ° try/except trong Python hay try/catch trong Java, Elixir cÃ³ try/recuse vÃ  try/catch, nhÆ°ng trong Elixir, sá»­ dá»¥ng chÃºng lÃ  Ä‘iá»u khÃ´ng nÃªn / hiáº¿m khi dÃ¹ng.

```
iex(61)> try do
...(61)>   r = 1/0
...(61)> rescue
...(61)>   ArithmeticError -> "Error"
...(61)> end
"Error"
```

Váº­y Elixir lÃ m gÃ¬ khi gáº·p lá»—i? cÃ³ "exception" thÃ¬ xá»­ lÃ½ tháº¿ nÃ o?
Trong triáº¿t lÃ½ cá»§a Erlang/Elixir, "lá»—i" lÃ  má»™t pháº§n cá»§a chÆ°Æ¡ng trÃ¬nh, vÃ  há»‡ thá»‘ng náº±m dÆ°á»›i ngÃ´n ngá»¯ (BEAM/OTP) sáº½ xá»­ lÃ½ chÃºng má»™t cÃ¡ch ngon lÃ nh. Táº¡m thá»i bá» qua á»Ÿ Ä‘Ã¢y.

## Báº¯t Ä‘áº§u code má»™t project
Äáº¿n Ä‘Ã¢y Ä‘Ã£ Ä‘á»§ cÃ¡c cÃ´ng cá»¥ cÆ¡ báº£n Ä‘á»ƒ viáº¿t nhá»¯ng chÆ°Æ¡ng trÃ¬nh bÃ¬nh thÆ°á»ng / luyá»‡n táº­p vá»›i cÃ¡c thuáº­t toÃ¡n ... cho Ä‘áº¿n khi quen vá»›i ngÃ´n ngá»¯.
Elixir cÃ²n nhiá»u khÃ¡i niá»‡m khÃ¡c, Ä‘áº·c biá»‡t Ä‘Æ°á»£c Ä‘Æ°a ra Ä‘á»ƒ xá»­ lÃ½ trong mÃ´i trÆ°á»ng "phÃ¢n tÃ¡n", nhÆ°ng táº­p trung vÃ o nhá»¯ng tÃ­nh nÄƒng Ä‘Ã³ ngay bÃ¢y giá» chá»‰ lÃ m cho ngÆ°á»i há»c bá»‹ quÃ¡ táº£i vá»›i nhá»¯ng khÃ¡i niá»‡m má»›i láº¡, trong khi váº«n chÆ°a náº¯m rÃµ pháº§n cÆ¡ báº£n. Váº­y nÃªn, cÃ¡c khÃ¡i niá»‡m "khÃ¡c" Ä‘Ã³ sáº½ Ä‘Æ°á»£c dÃ nh cho pháº§n sau. CÃ²n bÃ¢y giá», táº¡o má»™t project Elixir vÃ  code:

`Mix` lÃ  "build tool" cá»§a Elixir, Ä‘á»ƒ táº¡o má»™t project má»›i, dÃ¹ng cÃ¢u lá»‡nh:

```
 mix new hello_familug
* creating README.md
* creating .gitignore
* creating mix.exs
* creating config
* creating config/config.exs
* creating lib
* creating lib/hello_familug.ex
* creating test
* creating test/test_helper.exs
* creating test/hello_familug_test.exs

Your Mix project was created successfully.
You can use "mix" to compile it, test it, and more:

    cd hello_familug
    mix test

Run "mix help" for more commands.
```

Sá»­a ná»™i dung file `lib/hello_familug.ex` nhÆ° sau:

```
defmodule HelloFamilug do
  def main(args) do
    IO.puts "Hello FAMILUG!"
  end
end
```

ThÃªm dÃ²ng:

```
      escript: escript,
```

vÃ o sau dÃ²ng

```
      elixir: "~> VERSION",
```

trong mix.exs.

ThÃªm function sau vÃ o trong file `mix.exs`

```
  def escript do
    [main_module: HelloFamilug]  # tÃªn module sáº½ Ä‘Æ°á»£c cháº¡y
  end
```

Compile vÃ  cháº¡y:

```
$ mix escript.build
Compiling 1 file (.ex)
warning: variable args is unused
  lib/hello_familug.ex:2

Generated hello_familug app
Generated escript hello_familug with MIX_ENV=dev
$ ./hello_familug
Hello FAMILUG!
```

Sá»­a láº¡i code Ä‘á»ƒ nháº­n vÃ o input tá»« ngÆ°á»i dÃ¹ng:

```
defmodule HelloFamilug do
  def main(args) do
    {_, [name], _} = OptionParser.parse(args)
    IO.puts "Hello " <> name
  end
end
```

Táº¡m thá»i bá» qua chi tiáº¿t OptionParser.parse/1 lÃ m gÃ¬,
build láº¡i vÃ  gá»i vá»›i má»™t cÃ¡i tÃªn:

```
$ mix escript.build
Compiling 1 file (.ex)
Generated escript hello_familug with MIX_ENV=dev
$ ./hello_familug Python
Hello Python
```

ChÆ°Æ¡ng trÃ¬nh dÃ²ng lá»‡nh (CLI tool) khÃ´ng pháº£i lÃ  tháº¿ máº¡nh cá»§a Elixir, nhÆ°ng nÃ³ hoÃ n toÃ n cÃ³ thá»ƒ lÃ m Ä‘Æ°á»£c vÃ  khÃ´ng há» phá»©c táº¡p. Vá»›i tá»«ng áº¥y Ä‘á»§ Ä‘á»ƒ ta báº¯t Ä‘áº§u cuá»™c hÃ nh trÃ¬nh vÃ o nhá»¯ng giáº¥c mÆ¡ sÃ¢u vÃ´ táº­n trong tháº¿ giá»›i cá»§a nhÃ  giáº£ kim vÃ  Elixir (thuá»‘c tiÃªn).


## FAQs
### Táº¡i sao tÃªn láº¡i nháº£m nhÃ­ váº­y "há»c Elixir trong má»™t giáº¥c mÆ¡"?

VÃ¬ viá»‡c Ä‘á»c tiáº¿ng Anh á»Ÿ Viá»‡t Nam ráº¥t "tháº£m hoáº¡".
Chá»¯ "Python" - rÃµ rÃ ng Ä‘á»c lÃ  "pai-thon" thÃ¬ pháº§n lá»›n láº­p trÃ¬nh viÃªn láº¡i Ä‘á»c lÃ  "Pi-thÃ´ng". Váº­y nÃªn tÃ´i Ä‘áº·t tÃªn cÃ³ váº§n Ä‘á»ƒ ngÆ°á»i há»c cÃ³ thá»ƒ Ä‘á»c Ä‘Ãºng "Há»c `i lÃ­k sÆ¡` trong má»™t giáº¥c mÆ¡".
