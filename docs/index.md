# H·ªçc Elixir trong m·ªôt gi·∫•c m∆°
[BETA]

L√Ω do b·∫°n th√≠ch h·ªçc Haskell, LISP, Erlang, Elixir, Ocaml, Scala... nh·ªØng ng√¥n ng·ªØ l·∫≠p tr√¨nh h√†m (functional programming language) c√≥ v·∫ª hay ho, m√† kh√¥ng bao gi·ªù th√†nh c√¥ng l√† g√¨?

Sau ƒë√¢y l√† v√†i l√Ω do m√¨nh g·∫∑p ph·∫£i:

- Qu√° nhi·ªÅu kh√°i ni·ªám m·ªõi
- Nh·ªìi nh√©t h·∫øt c√°c kh√°i ni·ªám xong kh√¥ng c√≥ g√¨ ƒë·ªÉ l√†m
- Ch·ªçn ng√¥n ng·ªØ "x·ªãn" nh·∫•t: trong m·∫£nh ƒë·∫•t functional programming, r·∫•t nhi·ªÅu c√°i t√™n h·∫•p d·∫´n kh√°c nh∆∞ Haskell, Ocaml, Racket, Scheme, CLisp, Scala,...

ƒê·ªÉ kh·∫Øc ph·ª•c ƒëi·ªÅu n√†y, ta s·∫Ω:

- Ch·ªâ t·∫≠p trung v√†o nh·ªØng kh√°i ni·ªám ƒë√£ quen thu·ªôc, h·ªçc th·∫≠t nhanh, tra c·ª©u khi c·∫ßn
- C√≥ m·ªôt √Ω t∆∞·ªüng ƒë·ªÉ th·ª±c hi·ªán
- T·∫≠p trung v√†o Elixir v√¨ m·ªói ng√¥n ng·ªØ ƒë·ªÅu c√≥ ƒëi·ªÉm m·∫°nh/ y·∫øu ri√™ng, nh∆∞ng khi n·∫Øm ƒë∆∞·ª£c m·ªôt ng√¥n ng·ªØ, h·ªçc c√°c ng√¥n ng·ªØ kh√°c s·∫Ω tr·ªü n√™n d·ªÖ d√†ng h∆°n nhi·ªÅu do ƒë√£ quen thu·ªôc c√°c kh√°i  ni·ªám v√† l·ªëi t∆∞ duy c·ªßa functional programming.


N·∫øu kh√¥ng c√≥ g√¨ ƒë·ªÉ l√†m, nu·ªët xong c√°c kh√°i ni·ªám, 1 tu·∫ßn sau b·∫°n s·∫Ω l·∫°i qu√™n.

Elixir/Erlang ho√†n to√†n ƒë·ªß kh·∫£ nƒÉng ƒë·ªÉ cho b·∫°n l·∫≠p tr√¨nh loanh quanh m·∫•y thu·∫≠t to√°n, gi·∫£i c√°c b√†i to√°n / v·∫•n ƒë·ªÅ tr√™n HackerRank. Nh∆∞ng ƒëi·ªÉm s√°ng c·ªßa ng√¥n ng·ªØ n√†y, th·ª±c ra ch·ªâ to·∫£ s√°ng khi ta d√πng n√≥ ƒë·ªÉ ph√°t tri·ªÉn c√°c h·ªá th·ªëng l·ªõn, c·∫ßn ch·∫°y ph√¢n t√°n, hay ch·∫°y song song... √çt khi m·ªôt ng∆∞·ªùi s·∫Ω l√†m h·∫≥n m·ªôt project l·ªõn nh∆∞ v·∫≠y. V√¨ v·∫≠y, ta th∆∞·ªùng kh√¥ng c√≥ ƒë·∫•t d√πng cho Elixir hay Erlang.

M·ªôt c√°ch ·ª©ng d·ª•ng ƒë·ªÉ ch∆°i v·ªõi ng√¥n ng·ªØ m·ªõi n·ªØa "nh·ªè h∆°n", l√† vi·∫øt c√°c c√¢u l·ªánh th·ª±c hi·ªán m·ªôt vi·ªác g√¨ ƒë√≥ (CLI). V·∫≠y nh∆∞ng Elixir/Erlang kh√¥ng to·∫£ s√°ng/ ƒë∆°n gi·∫£n trong c√¥ng vi·ªác n√†y, n√≥ C√ì TH·ªÇ l√†m ƒë∆∞·ª£c, nh∆∞ng tr√™n th·ª±c t·∫ø kh√¥ng m·∫•y ai l√†m.

V√≠ d·ª• standard khi h·ªçc Erlang l√† l√†m m·ªôt h·ªá th·ªëng chat. Tr√™n th·ª±c t·∫ø, h·ªá th·ªëng chat c·ªßa "Whatsapp" ƒë∆∞·ª£c vi·∫øt b·∫±ng Erlang [h·ªá th·ªëng n√†y ƒë√£ ƒë∆∞·ª£c b√°n l·∫°i cho FaceBook v·ªõi gi√° 19 T·ª∂ ƒë√¥ la M·ªπ](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html) (PS: FaceBook tr∆∞·ªõc ƒë√≥ c≈©ng ƒë√£ mua l·∫°i Instagram - m·ªôt h·ªá th·ªëng vi·∫øt b·∫±ng Django/Python v·ªõi gi√° 1 T·ª∂ ƒë√¥ la M·ªπ)

Ta c√≥ th·ªÉ l√†m 1 website sau khi h·ªçc Elixir, ƒë√¢y l√† lƒ©nh v·ª±c hi·ªán t·∫°i m√† Elixir m·∫°nh nh·∫•t.

ƒê√£ xong ph·∫ßn √Ω t∆∞·ªüng, b√¢y gi·ªù h√£y h·ªçc Elixir.

Th·ª±c hi·ªán tr√™n:

```
$ elixir --version
Erlang/OTP 19 [erts-8.0.2] [source] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Elixir 1.3.2
```

## C√°c ki·ªÉu d·ªØ li·ªáu c∆° b·∫£n

### Integer

```
iex(33)> 42
42
iex(34)> i 42
Term
  42
Data type
  Integer
Reference modules
  Integer

D√πng ``i OBJECT`` ƒë·ªÉ hi·ªÉn th·ªã th√¥ng tin v·ªÅ gi√° tr·ªã/ ki·ªÉu c·ªßa object. Nh∆∞ "type(object)" trong Python hay "typeof object" trong JavaScript.
```

### Float

```
iex(35)> i 3.14
Term
  3.14
Data type
  Float
Reference modules
  Float

iex(36)> 0.1 + 0.1 + 0.1
0.30000000000000004
```

### Atom

```
iex(39)> i true
Term
  true
Data type
  Atom
Reference modules
  Atom
iex(40)> i false
Term
  false
Data type
  Atom
Reference modules
  Atom
```

### String

```
iex(42)> i "Elixir"
Term
  "Elixir"
Data type
  BitString
Byte size
  6
Description
  This is a string: a UTF-8 encoded binary. It's printed surrounded by
  "double quotes" because all UTF-8 encoded codepoints in it are printable.
Raw representation
  <<69, 108, 105, 120, 105, 114>>
Reference modules
  String, :binary
```

C√°c ki·ªÉu d·ªØ li·ªáu ch·ª©a ƒë∆∞·ª£c ki·ªÉu kh√°c: list, tuple, dict

### List

```
iex(44)> i 'abc'
Term
  'abc'
Data type
  List
Description
  This is a list of integers that is printed as a sequence of characters
  delimited by single quotes because all the integers in it represent valid
  ASCII characters. Conventionally, such lists of integers are referred to as
  "charlists" (more precisely, a charlist is a list of Unicode codepoints,
  and ASCII is a subset of Unicode).
Raw representation
  [97, 98, 99]
Reference modules
  List


iex(45)> i [1,2,3,3.14]
Term
  [1, 2, 3, 3.14]
Data type
  List
Reference modules
  List

iex(46)> i []
Term
  []
Data type
  List
Reference modules
  List
```

M·ªôt list c√≥ th·ªÉ ch·ª©a b·∫•t k·ª≥ ki·ªÉu d·ªØ li·ªáu n√†o:

```
iex(6)> i ["abc", 1]
Term
  ["abc", 1]
Data type
  List
Reference modules
  List
```

V·ªõi list ch·ª©a c√°c ph·∫ßn t·ª≠ tuple-2 {atom: value}, Elixir h·ªó tr·ª£ th√™m c√∫ ph√°p ng·∫Øn g·ªçn ƒë·ªÉ t·∫°o ra list n√†y v√† g·ªçi l√† "keyword list" (b·∫£n ch·∫•t v·∫´n l√† 1 list b√¨nh th∆∞·ªùng):

```
iex(38)> [{:name, "PyMi"}, {:est, 2015}]
[name: "PyMi", est: 2015]
iex(39)> [name: "PyMi", est: 2015]
[name: "PyMi", est: 2015]

iex(38)> [{:name, "PyMi"}, {:est, 2015}]
[name: "PyMi", est: 2015]
iex(39)> [name: "PyMi", est: 2015]
[name: "PyMi", est: 2015]
```

### Tuple

```
iex(48)> i {100, 'abc'}
Term
  {100, 'abc'}
Data type
  Tuple
Reference modules
  Tuple
iex(49)> i {}
Term
  {}
Data type
  Tuple
Reference modules
  Tuple

```

Kh√¥ng gi·ªëng Python, trong Elixir, T·∫§T C·∫¢ c√°c ki·ªÉu d·ªØ li·ªáu ƒë·ªÅu l√† immutable, t·ª©c m·ªôt khi ƒë√£ t·∫°o ra, kh√¥ng th·ªÉ thay ƒë·ªïi. Mu·ªën "thay ƒë·ªïi", ta ph·∫£i t·∫°o m·ªõi.

Tr√™n Python, nh·ªØng ƒëi·ªÅu sau ƒë·ªÅu c√≥ th·ªÉ l√†m tr√™n list hay tuple:
- duy·ªát qua t·ª´ng ph·∫ßn t·ª≠ (loop)
- truy c·∫≠p index
- slice ƒë·ªÉ thu ƒë∆∞·ª£c m·ªôt t·∫≠p con

S·ª± gi·ªëng nhau v·ªÅ t√≠nh nƒÉng khi·∫øn ng∆∞·ªùi d√πng th∆∞·ªùng h·ªèi khi n√†o d√πng list, khi n√†o d√πng tuple.
V·ªõi Python, ta c√≥ th·ªÉ thay ƒë·ªïi 1 list, nh∆∞ng kh√¥ng th·ªÉ thay ƒë·ªïi m·ªôt tuple sau khi ƒë√£ t·∫°o ra n√≥.
V·ªõi Elixir, c·∫£ list v√† tuple ƒë·ªÅu kh√¥ng th·ªÉ thay ƒë·ªïi ƒë∆∞·ª£c (immutable).
ƒê·∫∑c ƒëi·ªÉm n√†y s·∫Ω gi√∫p th·∫•y r√µ h∆°n khi n√†o d√πng tuple v√† khi n√†o n√™n d√πng list:
- list TH∆Ø·ªúNG d√πng ƒë·ªÉ ch·ª©a c√°c d·ªØ li·ªáu t∆∞∆°ng t·ª± nhau (heterogenious)
- tuple th∆∞·ªùng ƒë·ªÉ ch·ª©a c√°c th√¥ng tin li√™n quan ƒë·∫øn nhau, nh∆∞ c√°c c·ªôt trong 1 d√≤ng c·ªßa database, c√°c to·∫° ƒë·ªô c·ªßa m·ªôt ƒëi·ªÉm, c√°c ƒë·∫∑c t√≠nh c·ªßa m·ªôt con m√®o...

Khi ƒë√≥, ta s·∫Ω th∆∞·ªùng loop qua 1 list, v√† th∆∞·ªùng truy c·∫≠p ƒë·∫øn c√°c ph·∫ßn t·ª≠ c·ªßa tuple th√¥ng qua indexing/unpacking.

```
iex(52)> person = {"HVN", 27, "Python"}
{"HVN", 27, "Python"}
iex(53)> {name, age, language} = person
{"HVN", 27, "Python"}
iex(54)> name
"HVN"
```

http://elixir-lang.org/getting-started/basic-types.html#lists-or-tuples
http://stackoverflow.com/questions/31192923/lists-vs-tuples-what-to-use-and-when

### Map (dictionary)

```
iex(51)> i %{"name": "FAMILUG"}
Term
  %{name: "FAMILUG"}
Data type
  Map
Reference modules
  Map
```

## C√°c thao t√°c c∆° b·∫£n v·ªõi c√°c ki·ªÉu d·ªØ li·ªáu

### Thao t√°c v·ªõi String
- Ki·ªÉm tra string con:

```
iex(9)> String.contains?("Python", "on")
true
iex(10)> String.contains?("Python", "ON")
false
```

Ch√∫ √Ω t√™n function c√≥ d·∫•u ?

- Ki·ªÉm tra b·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c:

```
iex(11)> String.starts_with?("Python", "Py")
true
iex(12)> String
String      StringIO
iex(12)> String.ends_with?("Python.mp3", ".mp3")
true
```

D·ªÖ th·∫•y, nh·ªØng function tr·∫£ v·ªÅ true/false ƒë·ªÅu ƒë∆∞·ª£c ƒë·∫∑t t√™n k·∫øt th√∫c b·∫±ng d·∫•u ?

- L·∫•y index #TODO


- N·ªëi c√°c ph·∫ßn t·ª≠ c·ªßa list (KH√îNG TH·ªÇ N·ªêI TUPLE):

```
iex(55)> Enum.join(["Python", "PyMi.vn"], " ")
"Python PyMi.vn"
iex(57)> ["Elixir", "PyMi.vn"] |> Enum.join("+")
"Elixir+PyMi.vn"
iex(61)> "H·ªçc Python" <> " " <> "t·∫°i PyMi.vn"
"H·ªçc Python t·∫°i PyMi.vn"

iex(7)> Enum.join {1, 2}
** (Protocol.UndefinedError) protocol Enumerable not implemented for {1, 2}
    (elixir) lib/enum.ex:1: Enumerable.impl_for!/1
    (elixir) lib/enum.ex:116: Enumerable.reduce/3
    (elixir) lib/enum.ex:1636: Enum.reduce/3
    (elixir) lib/enum.ex:1154: Enum.join/2
iex(7)> Enum.join [1, 2]
"12"
```

- C·∫Øt string, bi·∫øn th√†nh list:

```
iex(63)> String.split("M√¨nh th√≠ch th√¨ m√¨nh h·ªçc \tth√¥i", " ")
["M√¨nh", "th√≠ch", "th√¨", "m√¨nh", "h·ªçc", "\tth√¥i"]
iex(64)> String.split("M√¨nh th√≠ch th√¨ m√¨nh     h·ªçc \tth√¥i")
["M√¨nh", "th√≠ch", "th√¨", "m√¨nh", "h·ªçc", "th√¥i"]
```

Gi·ªëng nh∆∞ Python.

Nh∆∞ng Elixir c√≤n c√≥ th·ªÉ Split t·∫°i nhi·ªÅu "separator":

```
iex(7)> String.split("a-b+c", ["-", "+"])
["a", "b", "c"]
```

- trim/trim_leading/trim_trailing

```
iex(14)> String.trim("   a\t abc\n")
"a\t abc"
iex(15)> String.trim_leading("   a\t abc\n")
"a\t abc\n"
iex(16)> String.trim_trailing("   a\t abc\n")
"   a\t abc"
```

- replace

```
iex(17)> String.replace("Python", "Py", "Jy")
"Jython"
```

- Ch·ªØ hoa, ch·ªØ th∆∞·ªùng:

```
iex(18)> String.upcase("Python")
"PYTHON"
iex(19)> String.downcase("PYThon")
"python"
iex(20)> String.capitalize("python is an animal")
"Python is an animal"
```

- Bi·∫øn th√†nh ki·ªÉu integer

```
iex(22)> String.to_integer("   42  ")
** (ArgumentError) argument error
    :erlang.binary_to_integer("   42  ")
iex(22)> String.to_integer("42")
42

```
Function n√†y trong Elixir kh√¥ng c√≥ kh·∫£ nƒÉng b·ªè ƒëi whitespace nh∆∞ Python:

```
In [1]: int("   42 \n\t   ")
Out[1]: 42
```

- L·∫•y ƒë·ªô d√†i

```
iex(59)>  String.length("L·∫°c tr√¥i")
8
iex(60)>  String.length("L·∫°c tr√¥iüòù")
9
```

- Slice: slice(string, start, len)

```
iex(1)> String.slice("Python", 0, 2)
"Py"
iex(2)> String.slice("Python", 2, 10)
"thon"
```

- ƒê·∫£o ng∆∞·ª£c:

```
iex(4)> String.reverse("DOICAN")
"NACIOD"
```

https://hexdocs.pm/elixir/1.4.2/String.html#content

### List

S·ª≠ d·ª•ng module `List`. C√°c function c√≥ s·∫µn c·ªßa module List kh√¥ng gi·ªëng nh∆∞ trong Python, b·ªüi List trong Python c√≥ th·ªÉ thay ƒë·ªïi ƒë∆∞·ª£c (th√™m b·ªõt, s·ª≠a ph·∫ßn t·ª≠) c√≤n List trong Elixir th√¨ kh√¥ng.

- T·∫°o list

```
iex(8)> li = [1, "PyMi", "Python", "Elixir"]
[1, "PyMi", "Python", "Elixir"]
iex(10)> i li
Term
  [1, "PyMi", "Python", "Elixir"]
Data type
  List
Reference modules
  List
```

- L·∫•y ƒë·∫ßu (head)

```
iex(11)> hd li
1
```

- L·∫•y ƒëu√¥i (tail)

```
iex(12)> tl li
["PyMi", "Python", "Elixir"]
```

- L·∫•y ƒë·∫ßu v√† ƒëu√¥i:

```
iex(24)> [head | tail] = ["Python", "PyMi", "Golang", "FAMILUG.org"]
["Python", "PyMi", "Golang", "FAMILUG.org"]
iex(25)> head
"Python"
iex(26)> tail
["PyMi", "Golang", "FAMILUG.org"]
```

- Ki·ªÉm tra s·ªë ph·∫ßn t·ª≠
```
iex(14)> length li
4
```

- Ki·ªÉm tra m·ªôt ph·∫ßn t·ª≠ c√≥ trong list kh√¥ng

```
iex(5)> Enum.member?([1,2,4], 3)
false
```

Hay d√πng c√∫ ph√°p `left in right`:

```
iex(21)> 1 in [1, 2, 3]
true
```

Ch√∫ √Ω c√∫ ph√°p `in` n√†y kh√¥ng ho·∫°t ƒë·ªông v·ªõi tuple, map (nh∆∞ trong Python).

```
iex(21)> 1 in {1, 2, 3}
** (Protocol.UndefinedError) protocol Enumerable not implemented for {1, 2, 3}
    (elixir) lib/enum.ex:1: Enumerable.impl_for!/1
    (elixir) lib/enum.ex:131: Enumerable.member?/2
    (elixir) lib/enum.ex:1352: Enum.member?/2
iex(22)> :a in %{:a => value}
** (CompileError) iex:22: undefined function value/0
    (elixir) expanding macro: Kernel.in/2
             iex:22: (file)
```


- N·ªëi 2 list *concatenate*

```
iex(18)> li ++ [2, "Erlang"]
[1, "PyMi", "Python", "Elixir", 2, "Erlang"]
```

- Tr·ª´ 2 list *subtract*

```
iex(22)> [1, 2, 3, 2, 1] -- [2]
[1, 3, 2, 1]
iex(23)> [1, 2, 3, 2, 1] -- [2, 3]
[1, 2, 1]
```

- "Th√™m" ph·∫ßn t·ª≠ v√†o list: th·ª±c ra l√† t·∫°o m·ªôt list m·ªõi
Th√™m "Zero" v√†o index 0

```
iex(21)> List.insert_at(li, 0, "Zero")
["Zero", 1, "PyMi", "Python", "Elixir"]
```

- "Th√™m" m·ªôt ph·∫ßn t·ª≠ v√†o ƒë·∫ßu list (si√™u t·ªëc - constant time O(1)):

```
iex(27)> l3 = ["Python", "PyMi", "Golang", "FAMILUG.org"]
["Python", "PyMi", "Golang", "FAMILUG.org"]
iex(28)> ["h" | l3]
["h", "Python", "PyMi", "Golang", "FAMILUG.org"]
```

- "Th√™m" m·ªôt ph·∫ßn t·ª≠ xu·ªëng cu·ªëi list (ch·∫≠m, linear time O(n))

```
iex(30)> l3 ++ ["t"]
["Python", "PyMi", "Golang", "FAMILUG.org", "t"]
```

- Thay m·ªôt ph·∫ßn t·ª≠ c·ªßa list t·∫°i 1 index:
```
iex(33)> List.replace_at(["Python", "PyMi", "Golang", "FAMILUG.org", "t"], 2, "Elixir")
["Python", "PyMi", "Elixir", "FAMILUG.org", "t"]
```

- "Xo√°" ph·∫ßn t·ª≠ kh·ªèi list (d√πng value c·ªßa ph·∫ßn t·ª≠ v√† d√πng index):

```
iex(31)> List.delete(["Python", "PyMi", "Golang", "FAMILUG.org", "t"], "Golang")
["Python", "PyMi", "FAMILUG.org", "t"]
iex(32)> List.delete_at(["Python", "PyMi", "Golang", "FAMILUG.org", "t"], 2)
["Python", "PyMi", "FAMILUG.org", "t"]
```

- L·∫•y m·ªôt list con t·ª´ list (slice):
slice(enumerable, start, amount)

```
iex(36)>  Enum.slice(["Python", "PyMi", "Elixir", "FAMILUG.org"], 1, 10)
["PyMi", "Elixir", "FAMILUG.org"]
```

- S·∫Øp x·∫øp 1 list

Theo b·∫£ng ch·ªØ c√°i
```
iex(37)> Enum.sort(["Python", "PyMi", "Elixir", "FAMILUG.org", "t"])
["Elixir", "FAMILUG.org", "PyMi", "Python", "t"]
```

Theo ti√™u ch√≠ nh·∫•t ƒë·ªãnh (function)
```
iex(35)> Enum.sort_by(["Python", "PyMi", "Elixir", "FAMILUG.org", "t"], &String.length/1)
["t", "PyMi", "Python", "Elixir", "FAMILUG.org"]
```

https://hexdocs.pm/elixir/Enum.html#content

### Map

l√† m·ªôt c·∫•u tr√∫c d·ªØ li·ªáu c√≥ th·ªÉ g·ªçi l√† "key-value" store.
T√™n kh√°c (trong ng√¥n ng·ªØ kh√°c): dictionary, associative array

```
map = %{:a => 1, :b => 2}
```

- T·∫°o map:
%{key => value1, key => value2}

```
iex(47)>  %{:a => 1, :b =>2}
%{a: 1, b: 2}
iex(48)> %{"name" => "PYMI", "country" => "VN"}
%{"country" => "VN", "name" => "PYMI"}
```

- ƒê·∫øm s·ªë ph·∫ßn t·ª≠
- Truy c·∫≠p value:

```
iex(68)> %{:name => who} = %{:name => "HVN"}
%{name: "HVN"}
iex(69)> who
"HVN"

iex(44)> map = %{:a => 1, :b =>2}
%{a: 1, b: 2}
iex(46)> map[:b]
2
iex(47)> map[:c]
nil
```

Hay

```
iex(60)> Map.get(map, :b)
2
```

Truy c·∫≠p 1 key kh√¥ng t·ªìn t·∫°i s·∫Ω tr·∫£ v·ªÅ nil.

- Ki·ªÉm tra key c√≥ trong map kh√¥ng

```
iex(3)> Map.has_key?(%{:name => "HVN"}, :age)
false
```

- "Th√™m" key-value m·ªõi:

```
iex(62)> Map.put(%{:a => 1}, :h, 4)
%{a: 1, h: 4}
```

- Xo√° key-value:

```
iex(1)> Map.delete(%{:name => "HVN", :age => 27}, :age)
%{name: "HVN"}
```

Xo√° key kh√¥ng t·ªìn t·∫°i kh√¥ng ·∫£nh h∆∞·ªüng g√¨:
```
iex(2)> Map.delete(%{:name => "HVN", :age => 27}, :language)
%{age: 27, name: "HVN"}
```

- Duy·ªát qua t·ª´ng key # TODO

- Bi·∫øn th√†nh list c√°c tuple key-value:

```
iex(63)> Map.to_list(%{:name => "HVN", :age => 27})
[age: 27, name: "HVN"]
```

- Update value c·ªßa 1 key ƒë√£ trong map (kh√¥ng th√™m):
```
iex(65)> %{ map | :b => 5}
%{a: 1, b: 5}
iex(66)> %{ map | :c => 5}
** (KeyError) key :c not found in: %{a: 1, b: 2}
```

- Truy c·∫≠p c√°c atom key b·∫±ng `.`:

```
iex(66)> student = %{:name => "HVN"}
%{name: "HVN"}
iex(67)> student.name
"HVN"
```

- Update value nested dict v·ªõi `put_in/2`:

```
iex(70)> users = [hvn: %{name: "HVN", age: 27, language: ["Erlang", "Elixir", "Python"]},
hails: %{name: "HaiLS", age: 26, language: ["Golang", "JS"]}]
[hvn: %{age: 27, language: ["Erlang", "Elixir", "Python"], name: "HVN"},
 hails: %{age: 26, language: ["Golang", "JS"], name: "HaiLS"}]

iex(72)> put_in users[:hvn].age, 29
[hvn: %{age: 29, language: ["Erlang", "Elixir", "Python"], name: "HVN"},
 hails: %{age: 26, language: ["Golang", "JS"], name: "HaiLS"}]
```

M·ªói ki·ªÉu d·ªØ li·ªáu ƒë·ªÅu c√≥ m·ªôt module t∆∞∆°ng ·ª©ng cung c·∫•p c√°c function c·∫ßn thi·∫øt: List, Map, String. Module `Enum` d√πng chung cho c√°c ki·ªÉu d·ªØ li·ªáu cho ph√©p duy·ªát qua t·ª´ng ph·∫ßn t·ª≠: nh∆∞ `List`, `String`.
## Pattern matching

`=` : the match operator
- Khi g√°n bi·∫øn, bi·∫øn ph·∫£i n·∫±m b√™n tr√°i d·∫•u `=`

```
iex(7)> x = 5
5
iex(8)> 6 = y
** (CompileError) iex:8: undefined function y/0
```

- V·∫ø tr√°i c√≥ th·ªÉ l√† ki·ªÉu d·ªØ li·ªáu ph·ª©c t·∫°p h∆°n, d√πng ƒë·ªÉ "destructuring" hay "unpacking" d·ªØ li·ªáu ph√≠a tay ph·∫£i.
S·ªë ph·∫ßn t·ª≠ 2 b√™n ph·∫£i b·∫±ng nhau, c√πng ki·ªÉu:

```
iex(18)> {name, age} = {"PyMI.vn", 2}
{"PyMI.vn", 2}
iex(19)> name
"PyMI.vn"
iex(20)> age
2

iex(1)> [x, y, z] = [1, 2, 4]  # list
[1, 2, 4]
iex(2)> x
1
iex(3)> z
4
```

Khi b√™n ph·∫£i ch·ª©a gi√° tr·ªã thay v√¨ bi·∫øn, 2 b√™n ch·ªâ match nhau n·∫øu gi√° tr·ªã b√™n tay tr√°i match gi√° tr·ªã b√™n tay ph·∫£i:

```
iex(4)> {:ok, 1, salary} = {:ok, 1, 15}
{:ok, 1, 15}
iex(5)> {:ok, 1, income} = {:ok, 3, 20}
** (MatchError) no match of right hand side value: {:ok, 3, 20}

iex(10)> {x, x} = {1, 1}
{1, 1}
iex(11)> {x, x} = {1, 2}
** (MatchError) no match of right hand side value: {1, 2}


```
Khi 2 b√™n kh√¥ng "match", MatchError s·∫Ω x·∫£y ra.

- Matching v·ªõi c√∫ ph√°p [head | tail]:

```
iex(5)> [h | t] = [1, 2, 3, 4]
[1, 2, 3, 4]
iex(6)> h
1
iex(7)> t
[2, 3, 4]
```

Gi·ªëng nh∆∞ g·ªçi function `hd` v√† `tl`:

```
iex(8)> hd [1, 2, 3, 4]
1
iex(9)> tl [1, 2, 3, 4]
[2, 3, 4]
```

C√∫ ph√°p n√†y r√µ r√†ng kh√¥ng match list r·ªóng:

```
iex(10)> [h | t] = []
** (MatchError) no match of right hand side value: []

```

- Truy c·∫≠p gi√° tr·ªã c·ªßa m·ªôt bi·∫øn thay v√¨ g√°n l·∫°i n√≥ b·∫±ng `^` - pin operator:
```
iex(11)> x = 5
5
iex(12)> x = 7
7
iex(13)> x
7
iex(14)> ^x = 8
** (MatchError) no match of right hand side value: 8
V√¨ gi·ªëng nh∆∞ vi·∫øt: 7 = 8
iex(14)> 7 = 8
** (MatchError) no match of right hand side value: 8
```


## Control flow: case, cond, if, unless, do/end

### if

if/2 l√† m·ªôt function, t·ª©c n√≥ s·∫Ω tr·∫£ v·ªÅ m·ªôt gi√° tr·ªã sau khi ch·∫°y. Kh√°c v·ªõi Python hay nhi·ªÅu ng√¥n ng·ªØ kh√°c, if trong Python l√† m·ªôt "statement" (c√¢u l·ªánh), v√† n√≥ ch·ªâ th·ª±c hi·ªán ƒëi·ªÅu khi·ªÉn lu·ªìng ch·ª© kh√¥ng tr·∫£ v·ªÅ gi√° tr·ªã n√†o.
(PS: th·ª±c s·ª± if/2 m√† 1 macro - kh√°i ni·ªám macro s·∫Ω ƒë∆∞·ª£c n√≥i sau)

```
iex(15)> k = if 5 > 4 do
...(15)> "yeah"
...(15)> end
"yeah"
iex(16)> k
"yeah"
```

if/2 tr·∫£ v·ªÅ nil n·∫øu ƒëi·ªÅu ki·ªán n√≥ nh·∫≠n ƒë∆∞·ª£c tr·∫£ v·ªÅ false hay nil.

```
iex(17)> h = if 5 < 4 do
...(17)> "hey"
...(17)> end
nil
iex(18)> h
nil
```

M·∫´u c√∫ ph√°p:

```
if condition do
SOMETHING
end
```

`if` c√≥ th·ªÉ ƒëi k√®m v·ªõi `else`:
```
iex(19)> m = if 5 < 4 do
...(19)> "smaller"
...(19)> else
...(19)> "bigger"
...(19)> end
"bigger"
iex(20)> m
"bigger"
```

Trong Elixir ch·ªâ c√≥ `if/else/end` kh√¥ng c√≥ elif nh∆∞ trong Python, khi c·∫ßn x·ª≠ l√Ω nhi·ªÅu tr∆∞·ªùng h·ª£p, ta c√≥ th·ªÉ d√πng cond.

ƒê·ªçc th√™m: https://hexdocs.pm/elixir/Kernel.html#if/2

### cond
`cond do ... end` cho ph√©p x·ª≠ l√Ω nhi·ªÅu ƒëi·ªÅu ki·ªán, gi·ªëng nh∆∞ elif hay else if trong c√°c ng√¥n ng·ªØ kh√°c:

```
iex(24)> x = 18
18
iex(25)> cond do
...(25)>   x < 18 ->
...(25)>     "Not permitted"
...(25)>   x == 18 ->
...(25)>     "Okay"
...(25)>   x > 18 ->
...(25)>     "Too old"
...(25)> end
"Okay"
```

### unless
Nh∆∞ if, nh∆∞ng ng∆∞·ª£c l·∫°i.

```
iex(26)> x = 18
18
iex(27)> unless x < 18 do
...(27)>   "got this"
...(27)> end
"got this"
iex(28)> if x < 18 do
...(28)>   "no"
...(28)> end
nil
```

### case
`case` s·ª≠ d·ª•ng pattern matching, v√† ch·ªâ d·ª´ng l·∫°i khi ta t√¨m th·∫•y gi√° tr·ªã n√†o match. Ta th·∫•y `case` ch·ªâ d√πng ƒë·ªÉ ki·ªÉm tra xem 1 gi√° tr·ªã c√≥ b·∫±ng m·ªôt gi√° tr·ªã kh√°c, ch·ª© kh√¥ng d√πng so s√°nh >, < ... nh∆∞ `if`.

```
iex(22)> case 5 do
...(22)>   4 ->
...(22)>
...(22)> "Won't match"
...(22)> _ ->
...(22)> "will match"
...(22)> end
"will match"
```

```
iex(23)> case {1, 2, 3} do
...(23)>   {1, x, 3} when x > 0 ->
...(23)>     "will match"
...(23)>   _ ->
...(23)>     "Would match, if guard cond were not sastified"
...(23)> end
"will match"
```


`when x > 0` g·ªçi l√† guard condition. Ta th·∫•y `case` c≈©ng l√† m·ªôt macro ch·ª© kh√¥ng ph·∫£i "statement" nh∆∞ trong c√°c ng√¥n ng·ªØ kh√°c.


C√∫ ph√°p:

```
case SOMETHING do
  CLAUSE1 [GUARD] ->
      "OTHERTHING"
  CLAUSE2 [GUARD] ->
     ...
  _ ->
     "LAST PATTERN MATCH REMAIN"
end
```

N·∫øu kh√¥ng clause n√†o match, error s·∫Ω ƒë∆∞·ª£c raise:

```
iex(24)> case :ok do
...(24)>   :error ->
...(24)>     "Not match"
...(24)> end
** (CaseClauseError) no case clause matching: :ok

```


### Guard
Trong guard kh√¥ng ƒë∆∞·ª£c d√πng && || !
Error trong guard s·∫Ω khi·∫øn guard fail.


### do/end
Trong `if` `unless` `cond` `case` ƒë·ªÅu c√≥ d√πng `do` v√†
k·∫øt th√∫c b·∫±ng `end`.

```
if true do
...
end
```

T∆∞∆°ng ƒë∆∞∆°ng v·ªõi:

```
if true, do: (
...
)
```
`do/end` l√† syntactix sugar (c√∫ ph√°p ƒë·ªÉ vi·∫øt cho d·ªÖ).

## Function

### G·ªçi function (calling):

C√∫ ph√°p th√¥ng th∆∞·ªùng:

```
iex(1)> String.to_integer(String.trim("  42 \n "))
42
iex(7)> String.split("42-15\n17", ["-", "\n"])
["42", "15", "17"]
```

C√∫ ph√°p b·ªè d·∫•u `()`:

```
iex(8)> String.split "42-15\n17", ["-", "\n"]
["42", "15", "17"]

iex(10)> Enum.map(String.split("42-15\n17", ["-", "\n"]), fn(x) -> String.to_integer(x) end)
[42, 15, 17]
```

#### To√°n t·ª≠ pipe (pipe operator)
C√∫ ph√°p s·ª≠ d·ª•ng "pipe", d·ªØ li·ªáu s·∫Ω ch·∫°y t·ª´ output c·ªßa 1 function, qua pipe v√† tr·ªü th√†nh argument ƒë·∫ßu ti√™n c·ªßa function ti·∫øp theo (gi·ªëng Pipeline tr√™n UNIX shell).

```
iex(11)> String.split("42-15\n17", ["-", "\n"]) |> Enum.map(fn(x) -> String.to_integer(x) end)
[42, 15, 17]

iex(23)> 1..1000 |> Enum.filter(fn(x) -> (rem(x, 3) == 0 || rem(x, 5) == 0) end) |> Enum.sum
234168
```

### ƒê·ªãnh nghƒ©a function
Function ph·∫£i ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a trong module.

ƒêo·∫°n code sau ƒë·ªãnh nghƒ©a module `Math` v√† function `sum`:

```
defmodule Math do
  def sum(a, b) do
    a + b
  end
end
```

ho·∫∑c

```
defmodule Hacker, do: def hack(x), do: x*2
```
khi ch·ªâ c√≥ 1 function v√† function ch·ªâ c√≥ 1 d√≤ng.

`defmodule` v√† `def` ƒë·ªÅu l√† c√°c macro.

### Private function
ƒê·ªãnh nghƒ©a b·∫±ng macro `defp/2`, t·ª´ module kh√°c kh√¥ng th·ªÉ ch·∫°y c√°c function n√†y.

### K√Ω hi·ªáu (notation)
Khi nh·∫Øc t·ªõi function, trong Elixir d√πng k√Ω hi·ªáu:
`name/arity` v·ªõi name l√† t√™n , v√† arity l√† s·ªë argument function ƒë√≥ nh·∫≠n.

Math.sum ·ªü tr√™n k√Ω hi·ªáu l√† `Math.sum/2`

### Multiple clause function
M·ªôt function c√≥ th·ªÉ c√≥ nhi·ªÅu `clause`:

M·ªói "clause" th∆∞·ªùng ƒëi k√®m m·ªôt "guard", n·∫øu argument pass v√†o match v·ªõi argument c·ªßa clause v√† guard ƒëi k√®m tr·∫£ v·ªÅ `true`, clause ƒë√≥ s·∫Ω ƒë∆∞·ª£c g·ªçi.

```
defmodule Foo do
  def rprint(msg, n) when n <= 1 do
    IO.puts msg
  end

  def rprint(msg, n) do
    IO.puts msg
    rprint(msg, n - 1)
  end
end

Foo.rprint("Hello", 5)
```

### Function capturing

#### TODO

### Default argument

```
def join(a, b, sep \\ ",") do
  a <> sep <> b
end
```
"," l√† default argument, khi g·ªçi funtion m√† kh√¥ng pass gi√° tr·ªã cho argument `sep`, `sep` s·∫Ω s·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh ",".

### C√°c ph·∫ßn c·ªßa m·ªôt function

```
def sum(a, b) do
  a + b
end
```

- Function head: `def sum(a, b)`
- Function body: t·ª´ `do` ƒë·∫øn `end`

Khi function v·ªõi default value c√≥ nhi·ªÅu m·ªánh ƒë·ªÅ, ph·∫£i khai b√°o m·ªôt function head ƒë·ªÉ khai b√°o gi√° tr·ªã default.

#### TODO more detail

## Module

### Compile

C√≥ th·ªÉ vi·∫øt module v√†o file `NAME.ex`: `math.ex`.

Compile module:

```
$ elixirc math.ex  # t·∫°o ra file Elixir.Math.beam
```

B·∫≠t `iex` c√πng th∆∞ m·ª•c s·∫Ω t·ª± ƒë·ªông load module, ch·ªâ vi·ªác g·ªçi.

### Script
L∆∞u file v·ªõi ƒëu√¥i .exs, Elixir s·∫Ω hi·ªÉu ƒë√≥ l√† 1 "script" v√† s·∫Ω kh√¥ng t·∫°o file c√≥ ƒëu√¥i .beam n·ªØa, ch·∫°y n√≥ nh∆∞ ch·∫°y c√°c script kh√°c (Python, bash...):

```
$ elixir math.exs
```

## Loop b·∫±ng recursion, reduce v√† map

Trong Elixir, m·ªçi th·ª© ƒë·ªÅu l√† "immutable" (kh√¥ng thay ƒë·ªïi ƒë∆∞·ª£c), v√¨ v·∫≠y nh·ªØng kh√°i ni·ªám ƒë·ªÉ l·∫∑p nh∆∞ trong c√°c ng√¥n ng·ªØ C, Python, Java, PHP, Golang ... s·∫Ω kh√¥ng ƒë∆∞·ª£c ·ª©ng d·ª•ng:

```
for i in 'Elixir':
    print(i)
```

·ªû v√≤ng l·∫∑p for n√†y, gi√° tr·ªã c·ªßa i l·∫ßn l∆∞·ª£t thay ƒë·ªïi th√†nh c√°c k√Ω t·ª± trong "Elixir" -> kh√¥ng ƒë·∫£m b·∫£o ƒë∆∞·ª£c t√≠nh immutable c·ªßa Elixir.

```
i = 0
while True:
    print(i)
    i = i + 1
```

T∆∞∆°ng t·ª±, trong v√≤ng l·∫∑p while n√†y i c≈©ng thay ƒë·ªïi sau m·ªói v√≤ng l·∫∑p, kh√¥ng ƒë·∫£m b·∫£o t√≠nh immutable.

Elixir hay c√°c ng√¥n ng·ªØ l·∫≠p tr√¨nh h√†m (functional programming language) kh√°c s·ª≠ d·ª•ng recursive function ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng/ k·∫øt qu·∫£ nh∆∞ loop.

### Recursive function
L√† function m√† b√™n trong ph·∫ßn body, n√≥ t·ª± g·ªçi ƒë·∫øn ch√≠nh n√≥ cho ƒë·∫øn khi g·∫∑p m·ªôt ƒëi·ªÅu ki·ªán ƒë·ªÉ d·ª´ng l·∫°i. S·∫Ω kh√¥ng c√≥ g√¨ b·ªã thay ƒë·ªïi khi d√πng recursive function, b·ªüi ta s·∫Ω sinh ra gi√° tr·ªã m·ªõi, ch·ª© kh√¥ng thay ƒë·ªïi gi√° tr·ªã c≈©. M·ªçi kh√°i ni·ªám s·∫Ω r√µ r√†ng khi th·ª≠ v·ªõi function t√≠nh giai th·ª´a c·ªßa 1 s·ªë:

Giai th·ª´a c·ªßa m·ªôt s·ªë nguy√™n kh√¥ng √¢m ƒë∆∞·ª£c t√≠nh b·∫±ng t√≠ch c·ªßa s·ªë ƒë√≥ nh√¢n v·ªõi giai th·ª≠a c·ªßa s·ªë nh·ªè h∆°n n√≥ 1 ƒë∆°n v·ªã. Hay vi·∫øt ·ªü d·∫°ng c√¥ng th·ª©c to√°n:
factorial(n) = n * factorial(n - 1)
khi n = 0 th√¨ factorial(0) = 1. # ƒëi·ªÅu ki·ªán d·ª´ng

Th·ª≠ t√≠nh factorial c·ªßa 3:

factorial(3) = 3 * factorial(2)
factorial(2) = 2 * factorial(1)
factorial(1) = 1 * factorial(0)
factorial(0) = 1

Sau khi ƒë√£ ch·∫°m ƒë·∫øn ƒëi·ªÅu ki·ªán d·ª±ng, ta l·∫•y k·∫øt qu·∫£ thu ƒë∆∞·ª£c thay ng∆∞·ª£c l√™n tr√™n.
factorial(1) = 1 * factorial(0) = 1 * 1 = 1
factorial(2) = 2 * factorial(1) = 2 * 1 = 2
factorial(3) = 3 * factorial(2) = 3 * 2 = 6

K·∫øt qu·∫£ l√† factorial(3) b·∫±ng 6.

```
defmodule Rescusion do
  def fact(n) when n <= 0 do
    1
  end

  def fact(n) do
    n * fact(n - 1)
  end
end
```

Trong b√†i n√†y, code c·ªßa Elixir ch·ªâ ƒë∆°n gi·∫£n l√† chuy·ªÉn c√¥ng th·ª©c to√°n h·ªçc th√†nh code.

### Map
M·ªôt vi·ªác l√†m th∆∞·ªùng xuy√™n khi s·ª≠ d·ª•ng loop l√† ƒë·ªÉ bi·∫øn 1 t·∫≠p gi√° tr·ªã, th√†nh 1 t·∫≠p gi√° tr·ªã kh√°c.

V√≠ d·ª•, cho m·ªôt list `L = [1, 2, 3 ,4]`, c·∫ßn thu ƒë∆∞·ª£c k·∫øt qu·∫£ l√† m·ªôt list m√† ph·∫ßn t·ª≠ c·ªßa n√≥ l√† m·ªói ph·∫ßn t·ª≠ c·ªßa `L` nh√¢n v·ªõi 2.

Vi·ªác bi·∫øn m·ªôt t·∫≠p th√†nh m·ªôt t·∫≠p kh√°c b·∫±ng c√°ch g·ªçi function v·ªõi m·ªói ph·∫ßn t·ª≠ c·ªßa t·∫≠p g·ªçi l√† "mapping" (√°nh x·∫° trong to√°n h·ªçc).
Ta "map" m·ªôt ph·∫ßn t·ª≠ t·ª´ t·∫≠p ban ƒë·∫ßu th√†nh ph·∫ßn t·ª≠ trong t·∫≠p m·ªõi.

Vi·∫øt function ƒë·ªÉ map list n√≥i tr√™n:

```
iex(41)> defmodule Double do
...(41)>   def double_each([head | tail]) do
...(41)>     [head * 2 | double_each(tail)]
...(41)>   end
...(41)>
...(41)>   def double_each([]) do
...(41)>     []
...(41)>   end
...(41)> end
{:module, Double,
...
iex(42)> Double.double_each([1,2,3,4])
[2, 4, 6, 8]
```

C√≥ th·ªÉ d√πng function c√≥ s·∫µn `Enum.map/2` ƒë·ªÉ th·ª±c hi·ªán mapping:

```
iex(45)> Enum.map([1,2,3,4], fn(x) -> x * 2 end)
[2, 4, 6, 8]
```

### Reduce
M·ªôt ·ª©ng d·ª•ng kh√°c th∆∞·ªùng d√πng khi l·∫∑p l√† ƒë·ªÉ t√≠nh m·ªôt gi√° tr·ªã n√†o ƒë√≥ s·∫Ω thu ƒë∆∞·ª£c sau khi duy·ªát qua t·∫•t c·∫£ gi√° tr·ªã trong t·∫≠p, nh∆∞ t√≠nh t·ªïng, t√≠ch c·ªßa t·∫≠p.

·ªû ƒë√¢y ta bi·∫øn t·ª´ 1 t·∫≠p nhi·ªÅu ph·∫ßn t·ª≠ th√†nh 1 gi√° tr·ªã cu·ªëi c√πng. Vi·ªác "thu g·ªçn" n√†y c√≥ t√™n l√† "reducing".

Map v√† reduce l√† 2 thu·∫≠t to√°n c·ªët l√µi c·ªßa "big data".

```
iex(46)> defmodule Reduce do
...(46)>   def sum_list([head | tail], accumulator) do
...(46)>     sum_list(tail, head + accumulator)
...(46)>   end
...(46)>
...(46)>   def sum_list([], accumulator) do
...(46)>     accumulator
...(46)>   end
...(46)> end

iex(47)> Reduce.sum_list([1,2,3], 0)
6
```

Hay d√πng module c√≥ s·∫µn `Enum.reduce/2`:

```
iex(48)> Enum.reduce([1,2,3], 0, fn(x, acc) -> x + acc end)
6
```

## IO - x·ª≠ l√Ω d·ªØ li·ªáu v√†o ra.
### In ra m√†n h√¨nh

M·∫∑c d√π h·∫ßu h·∫øt c√°c s√°ch d·∫°y l·∫≠p tr√¨nh / tr∆∞·ªùng h·ªçc s·∫Ω lu√¥n b·∫Øt ƒë·∫ßu b·∫±ng vi·ªác d·∫°y "print" ra m√†n h√¨nh (v√† ƒëi k√®m l√† ƒë·ªçc nh·ªØng g√¨ ng∆∞·ªùi d√πng nh·∫≠p v√†o), nh∆∞ng tr√™n th·ª±c t·∫ø, c√≥ kho·∫£ng < 5% ng∆∞·ªùi th·ª±c s·ª± d√πng print trong ch∆∞∆°ng tr√¨nh c·ªßa m√¨nh.

H√£y th·ª≠ nghƒ© v·ªõi ng∆∞·ªùi d√πng Windows, c√≥ bao gi·ªù b·∫°n b·∫≠t `cmd` l√™n v√† g√µ l·ªánh? C√°c ch∆∞∆°ng tr√¨nh ƒë·ªÅu giao ti·∫øp v·ªõi ng∆∞·ªùi d√πng qua giao di·ªán ƒë·ªì ho·∫° / web, ch·ª© kh√¥ng ph·∫£i c√°c d√≤ng l·ªánh. Nh·ªØng ng∆∞·ªùi l√†m vi·ªác v·ªõi d√≤ng l·ªánh ch·ªß y·∫øu l√† c√°c Linux Sysadmin / l·∫≠p tr√¨nh vi√™n / hacker.
N·∫øu b·∫°n l√† m·ªôt web developer, b·∫°n ƒë∆∞a n·ªôi dung ra trang web ch·ª© kh√¥ng print n√≥.

Elixir s·ª≠ d·ª•ng module `IO` cho c√°c thao t√°c n√†y:

```
iex(49)> IO.puts "Hello"
Hello
:ok
iex(50)> IO.puts "Hello FAMILUG"
Hello FAMILUG
:ok
iex(51)> answer = IO.gets("yes or no? ")
yes or no? yes
"yes\n"
iex(52)> IO.puts(answer)
yes

:ok
```

C√≥ th·ªÉ ghi ra stderr:

```
iex(53)> IO.puts(:stderr, "Hello standard error")
Hello standard error
:ok
```

### ƒê·ªçc ghi file

Module `File` ch·ª©a c√°c function ƒë·ªÉ t∆∞∆°ng t√°c v·ªõi file, t·ª´ ƒë·ªçc, ghi, xo√°, copy...


```
iex(53)> IO.puts(:stderr, "Hello standard error")
Hello standard error
:ok
iex(54)> {:ok, file} = File.open("hellofile.txt", [:write])
{:ok, #PID<0.260.0>}
iex(55)> IO.binwrite(file, "Hello world!")
:ok
iex(56)> File.close(file)
:ok
iex(57)> File.read("hellofile.txt")
{:ok, "Hello world!"}
```

C√°c function x·ª≠ l√Ω file:

`File.rm/1`, `File.mkdir/1`, `File.cp_r/2`, ...

## X·ª≠ l√Ω l·ªói

### Errror (hay exception)

```
iex(58)> "abc" + 1
** (ArithmeticError) bad argument in arithmetic expression
    :erlang.+("abc", 1)
iex(58)> raise "oizoioi"
** (RuntimeError) oizoioi

iex(58)> raise ArgumentError, message: "invalid argument"
** (ArgumentError) invalid argument

```

### try/rescue/catch/after
T∆∞∆°ng t·ª± nh∆∞ try/except trong Python hay try/catch trong Java, Elixir c√≥ try/recuse v√† try/catch, nh∆∞ng trong Elixir, s·ª≠ d·ª•ng ch√∫ng l√† ƒëi·ªÅu kh√¥ng n√™n / hi·∫øm khi d√πng.

```
iex(61)> try do
...(61)>   r = 1/0
...(61)> rescue
...(61)>   ArithmeticError -> "Error"
...(61)> end
"Error"
```

V·∫≠y Elixir l√†m g√¨ khi g·∫∑p l·ªói? c√≥ "exception" th√¨ x·ª≠ l√Ω th·∫ø n√†o?
Trong tri·∫øt l√Ω c·ªßa Erlang/Elixir, "l·ªói" l√† m·ªôt ph·∫ßn c·ªßa ch∆∞∆°ng tr√¨nh, v√† h·ªá th·ªëng n·∫±m d∆∞·ªõi ng√¥n ng·ªØ (BEAM/OTP) s·∫Ω x·ª≠ l√Ω ch√∫ng m·ªôt c√°ch ngon l√†nh. T·∫°m th·ªùi b·ªè qua ·ªü ƒë√¢y.

## B·∫Øt ƒë·∫ßu code m·ªôt project
ƒê·∫øn ƒë√¢y ƒë√£ ƒë·ªß c√°c c√¥ng c·ª• c∆° b·∫£n ƒë·ªÉ vi·∫øt nh·ªØng ch∆∞∆°ng tr√¨nh b√¨nh th∆∞·ªùng / luy·ªán t·∫≠p v·ªõi c√°c thu·∫≠t to√°n ... cho ƒë·∫øn khi quen v·ªõi ng√¥n ng·ªØ.
Elixir c√≤n nhi·ªÅu kh√°i ni·ªám kh√°c, ƒë·∫∑c bi·ªát ƒë∆∞·ª£c ƒë∆∞a ra ƒë·ªÉ x·ª≠ l√Ω trong m√¥i tr∆∞·ªùng "ph√¢n t√°n", nh∆∞ng t·∫≠p trung v√†o nh·ªØng t√≠nh nƒÉng ƒë√≥ ngay b√¢y gi·ªù ch·ªâ l√†m cho ng∆∞·ªùi h·ªçc b·ªã qu√° t·∫£i v·ªõi nh·ªØng kh√°i ni·ªám m·ªõi l·∫°, trong khi v·∫´n ch∆∞a n·∫Øm r√µ ph·∫ßn c∆° b·∫£n. V·∫≠y n√™n, c√°c kh√°i ni·ªám "kh√°c" ƒë√≥ s·∫Ω ƒë∆∞·ª£c d√†nh cho ph·∫ßn sau. C√≤n b√¢y gi·ªù, t·∫°o m·ªôt project Elixir v√† code:

`Mix` l√† "build tool" c·ªßa Elixir, ƒë·ªÉ t·∫°o m·ªôt project m·ªõi, d√πng c√¢u l·ªánh:

```
 mix new hello_familug
* creating README.md
* creating .gitignore
* creating mix.exs
* creating config
* creating config/config.exs
* creating lib
* creating lib/hello_familug.ex
* creating test
* creating test/test_helper.exs
* creating test/hello_familug_test.exs

Your Mix project was created successfully.
You can use "mix" to compile it, test it, and more:

    cd hello_familug
    mix test

Run "mix help" for more commands.
```

S·ª≠a n·ªôi dung file `lib/hello_familug.ex` nh∆∞ sau:

```
defmodule HelloFamilug do
  def main(args) do
    IO.puts "Hello FAMILUG!"
  end
end
```

Th√™m d√≤ng:

```
      escript: escript,
```

v√†o sau d√≤ng

```
      elixir: "~> VERSION",
```

trong mix.exs.

Th√™m function sau v√†o trong file `mix.exs`

```
  def escript do
    [main_module: HelloFamilug]  # t√™n module s·∫Ω ƒë∆∞·ª£c ch·∫°y
  end
```

Compile v√† ch·∫°y:

```
$ mix escript.build
Compiling 1 file (.ex)
warning: variable args is unused
  lib/hello_familug.ex:2

Generated hello_familug app
Generated escript hello_familug with MIX_ENV=dev
$ ./hello_familug
Hello FAMILUG!
```

S·ª≠a l·∫°i code ƒë·ªÉ nh·∫≠n v√†o input t·ª´ ng∆∞·ªùi d√πng:

```
defmodule HelloFamilug do
  def main(args) do
    {_, [name], _} = OptionParser.parse(args)
    IO.puts "Hello " <> name
  end
end
```

T·∫°m th·ªùi b·ªè qua chi ti·∫øt OptionParser.parse/1 l√†m g√¨,
build l·∫°i v√† g·ªçi v·ªõi m·ªôt c√°i t√™n:

```
$ mix escript.build
Compiling 1 file (.ex)
Generated escript hello_familug with MIX_ENV=dev
$ ./hello_familug Python
Hello Python
```

Ch∆∞∆°ng tr√¨nh d√≤ng l·ªánh (CLI tool) kh√¥ng ph·∫£i l√† th·∫ø m·∫°nh c·ªßa Elixir, nh∆∞ng n√≥ ho√†n to√†n c√≥ th·ªÉ l√†m ƒë∆∞·ª£c v√† kh√¥ng h·ªÅ ph·ª©c t·∫°p. V·ªõi t·ª´ng ·∫•y ƒë·ªß ƒë·ªÉ ta b·∫Øt ƒë·∫ßu cu·ªôc h√†nh tr√¨nh v√†o nh·ªØng gi·∫•c m∆° s√¢u v√¥ t·∫≠n trong th·∫ø gi·ªõi c·ªßa nh√† gi·∫£ kim v√† Elixir (thu·ªëc ti√™n).


## FAQs
### T·∫°i sao t√™n l·∫°i nh·∫£m nh√≠ v·∫≠y "h·ªçc Elixir trong m·ªôt gi·∫•c m∆°"?

V√¨ vi·ªác ƒë·ªçc ti·∫øng Anh ·ªü Vi·ªát Nam r·∫•t "th·∫£m ho·∫°".
Ch·ªØ "Python" - r√µ r√†ng ƒë·ªçc l√† "pai-thon" th√¨ ph·∫ßn l·ªõn l·∫≠p tr√¨nh vi√™n l·∫°i ƒë·ªçc l√† "Pi-th√¥ng". V·∫≠y n√™n t√¥i ƒë·∫∑t t√™n c√≥ v·∫ßn ƒë·ªÉ ng∆∞·ªùi h·ªçc c√≥ th·ªÉ ƒë·ªçc ƒë√∫ng "H·ªçc `i l√≠k s∆°` trong m·ªôt gi·∫•c m∆°".
